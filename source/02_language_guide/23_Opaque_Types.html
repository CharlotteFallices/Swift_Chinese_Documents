
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="renderer" content="webkit">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/>
    <meta content="yes" name="apple-mobile-web-app-capable"/>
    <meta content="black" name="apple-mobile-web-app-status-bar-style"/>
    <meta content="telephone=no" name="format-detection"/>
    <meta name="renderer" content="webkit"/>
    <title>不透明类型</title>
    <link rel="stylesheet" href="data:text/css;base64,CiAgICBoMSwgaDIsIGgzLCBoNSwgaDYsICBpbWcsIHN2ZywgcHJlLCB0YWJsZSwgdHJ7cGFnZS1icmVhay1pbnNpZGU6IGF2b2lkfQoKICAgIAogICAgLnBvc3R7CiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjsKICAgIH0KICAgIGJvZHkgewogICAgICAgIGJhY2tncm91bmQ6ICMxNzFEMjE7CiAgICAgICAgZm9udC1zaXplOiAxNHB4OwogICAgICAgIGxpbmUtaGVpZ2h0OjIuNDsKICAgICAgICBmb250LWZhbWlseTogIkhlbHZldGljYSBOZXVlIiwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmOwogICAgICAgIGZvbnQtd2VpZ2h0OiBub3JtYWw7CiAgICAgICAgY29sb3I6ICNBNUIwQzA7CiAgICAgICAgcGFkZGluZzogMCAzOHB4OwogICAgICAgIG1heC13aWR0aDogODIwcHg7CiAgICAgICAgbWFyZ2luOiAwIGF1dG87CgogICAgICAgIHdvcmQtd3JhcDpicmVhay13b3JkOwogICAgICAgIHdvcmQtYnJlYWs6IG5vcm1hbDsKICAgICAgICBvdmVyZmxvdy13cmFwOmJyZWFrLXdvcmQ7CiAgICAgICAgdGV4dC1hbGlnbjoganVzdGlmeTsKCgogICAgICAgIG92ZXJmbG93LXg6IGhpZGRlbjsKICAgICAgICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVMZWdpYmlsaXR5OwogICAgICAgIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogbm9uZTsKICAgIH0KCiAgICBicnsKICAgICAgICBsaW5lLWhlaWdodDogMi40OwogICAgfQoKCgogICAgQG1lZGlhIChtYXgtd2lkdGg6IDYwMHB4KSB7CiAgICAgICAgYm9keXsKICAgICAgICAgICAgcGFkZGluZzogMCAzMHB4OwogICAgICAgIH0KICAgIH0KCiAgICBAbWVkaWEgKG1heC13aWR0aDogNDgwcHgpIHsKICAgICAgICBib2R5ewogICAgICAgICAgICBwYWRkaW5nOiAwIDIwcHg7CiAgICAgICAgfQogICAgfQoKICAgIC5naXN0ewogICAgICAgIHdvcmQtYnJlYWs6IG5vcm1hbDsKICAgIH0KCiAgICAucG9zdHsKICAgICAgICBtYXJnaW4tdG9wOiAxMHB4OwogICAgICAgIG1hcmdpbi1ib3R0b206IDUwcHg7CiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlOwogICAgfQoKCgogICAgaW1newogICAgICAgIG1heC13aWR0aDogOTglOwogICAgICAgIG1hcmdpbjogMC44ZW0gYXV0byAwLjhlbSBhdXRvOwogICAgfQoKICAgIGgxIGltZywgaDIgaW1nLCBoMyBpbWcsIGg0IGltZywgaDUgaW1nLCBoNiBpbWd7CiAgICAgICAgbWFyZ2luOiBhdXRvOwogICAgfQoKICAgIC54Ml9pbWFnZXsKICAgICAgICB6b29tOiA1MCU7CiAgICB9CgogICAgLngzX2ltYWdlewogICAgICAgIHpvb206IDMzLjMzJTsKICAgIH0KCiAgICAueDRfaW1hZ2V7CiAgICAgICAgem9vbTogMjUlOwogICAgfQoKCiAgICBwIGltZ3sKICAgICAgICBtYXJnaW46IDAgYXV0bzsKICAgIH0KCiAgICBwewogICAgICAgIC8qb3ZlcmZsb3c6aGlkZGVuOyovCiAgICAgICAgbWFyZ2luOiAxLjBlbSAwIDEuOWVtIDA7CiAgICB9CgogICAgcC5tZF9ibG9ja19hc19vcGVuaW5newogICAgICAgIG1hcmdpbi1ib3R0b206IC0wLjVlbSAhaW1wb3J0YW50OwogICAgfQoKICAgIGxpIHB7CiAgICAgICAgbGluZS1oZWlnaHQ6IDIuMTY7CiAgICAgICAgbWFyZ2luOiAwOwogICAgfQoKICAgIC5wX3BhcnQgewogICAgICAgIG1hcmdpbjogMTBweCAwOwogICAgfQoKICAgIC5wX3BhcnQgcHsKICAgICAgICBtYXJnaW46IDAgMCAwLjZlbSAwOwogICAgfQoKICAgIC8qIHRleHQgaW5kZW50IGZvciBjaGluZXNlIHN0YXJ0cyovCiAgICAvKmgyLCBoMywgaDQsIGg1LCBoNiwgLnBfcGFydCBwLCAudG9kb19pdGVtLCBwewogICAgICAgIHRleHQtaW5kZW50OiAwcHg7CiAgICB9Ki8KICAgIHRhYmxlLCBwcmUsIHN2Z3sKICAgICAgICBtYXJnaW4tbGVmdDogMHB4OwogICAgICAgIG1hcmdpbi1yaWdodDogMHB4OwogICAgfQogICAgCiAgICBzcGFuIHN2Z3sKICAgICAgICBtYXJnaW4tbGVmdDogMDsKICAgICAgICBtYXJnaW4tcmlnaHQ6IDA7CiAgICB9CgogICAgLmxpbmVub2RpdiBwcmV7CiAgICAgICAgbWFyZ2luLWxlZnQ6IDA7CiAgICAgICAgbWFyZ2luLXJpZ2h0OiAwOwoKICAgIH0KICAgIAogICAgLmhpZ2hsaWdodCBwcmV7CiAgICAgICAgbWFyZ2luLWxlZnQ6IDA7CiAgICAgICAgbWFyZ2luLXJpZ2h0OiAwOwogICAgfQogICAgCiAgICAuaGlnaGxpZ2h0dGFibGUgLmNvZGUgeyBwb3NpdGlvbjogcmVsYXRpdmV9CiAgICAKICAgIC5oaWdobGlnaHR0YWJsZSBkaXYud2l0aF9saW5lc3sgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IHdpZHRoOiAxMDAlO30KICAgIAogICAgLmhpZ2hsaWdodHRhYmxlIGRpdi53aXRoX2xpbmVzIHByZXsKICAgICAgICBwYWRkaW5nLWxlZnQ6IDEwcHg7CiAgICB9CgoKCiAgICAvKiB0ZXh0IGluZGVudCBmb3IgY2hpbmVzZSBlbmRzKi8KCgogICAgYmxvY2txdW90ZSAucF9wYXJ0IHAsIGxpIC5wX3BhcnQgcHsKICAgICAgICB0ZXh0LWluZGVudDogMCAhaW1wb3J0YW50OwogICAgfQoKCiAgICBocnsKICAgICAgICBtYXJnaW46IDM4cHggMDsKICAgICAgICBib3JkZXI6IG5vbmU7CiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IGRhc2hlZCByZ2JhKDIwNSwgMjA1LCAyMDUsIDAuMzUpOwogICAgICAgIGNvbG9yOiByZ2JhKDIwNSwgMjA1LCAyMDUsIDAuMzUpOwogICAgICAgIGhlaWdodDogMXB4OwogICAgICAgIGxpbmUtaGVpZ2h0OjFweDsKICAgICAgICBmb250LXNpemU6MXB4OwogICAgICAgIG92ZXJmbG93LXk6IGhpZGRlbjsKICAgIH0KCgogICAgaDF7CiAgICAgICAgY29sb3I6ICNENUYwRjg7CiAgICAgICAgZm9udC1zaXplOiAxLjdlbTsKICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0OwogICAgICAgIG1hcmdpbjogMDsKICAgICAgICBwYWRkaW5nOiAwOwogICAgICAgIGxpbmUtaGVpZ2h0OiAxLjdlbTsKICAgICAgICBtYXJnaW4tdG9wOiAwLjhlbTsKICAgICAgICBtYXJnaW4tYm90dG9tOiAwLjZlbTsKICAgIH0KCiAgICBoMSwgaDIsIGgzLCBoNHsKICAgICAgICBjb2xvcjogI0Q1RjBGODsKICAgIH0KICAgIAogICAgaDF7Y29sb3I6I0Q1RjBGOH0KCgoKICAgIGgyLCBoM3sKICAgICAgICBsaW5lLWhlaWdodDogMS41ZW07CiAgICAgICAgbWFyZ2luLXRvcDogMS44ZW07CiAgICAgICAgbWFyZ2luLWJvdHRvbTogMC41ZW07CiAgICB9CgogICAgLmgxNi5tZF9maXJzdF9oLm1kX2ZpcnN0X3BhcnQgewogICAgICAgIG1hcmdpbi10b3A6IDVweDsKICAgIH0KICAgIAogICAgLnNwYW5fZm9yX2h7CiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7CiAgICB9CgoKICAgIGgyIHsKICAgICAgICBmb250LXNpemU6IDEuNWVtOwogICAgfQoKICAgIGgzIHsKICAgICAgICBmb250LXNpemU6IDEuMjVlbQogICAgfQoKICAgIGg0IHsKICAgICAgICBmb250LXNpemU6IDEuMTVlbTsKICAgIH0KCiAgICBoNSB7CiAgICAgICAgZm9udC1zaXplOiAxLjFlbTsKICAgIH0KCiAgICBoNiB7Zm9udC1zaXplOiAxZW19CgoKICAgIGgxLCBoMiwgaDMsIGg0LCBoNSwgaDZ7CiAgICAgICAgZm9udC1mYW1pbHk6ICJQaW5nRmFuZyBTQyI7CiAgICB9CgoKICAgIG9sIHsKICAgICAgICBtYXJnaW46IDA7CiAgICB9CgogICAgdWx7CiAgICAgICAgcGFkZGluZzogNXB4IDM4cHg7CiAgICAgICAgbWFyZ2luOiAwOwogICAgfQoKICAgIHVsIGxpLCBsaXsKICAgICAgICBwYWRkaW5nOiAwOwogICAgICAgIG1hcmdpbjogMDsKICAgIH0KCiAgICB1bCBwLCBvbCBwewogICAgICAgIG92ZXJmbG93OiB2aXNpYmxlOwogICAgfQoKCiAgICBibG9ja3F1b3RlIHsKICAgICAgICAtbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7CiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDsKICAgICAgICBtYXJnaW46IDEuNmVtIDA7CiAgICAgICAgcGFkZGluZzogMCAwIDAgMS4yZW07CiAgICAgICAgYm9yZGVyLWxlZnQ6IDRweCBzb2xpZCAjMkE4MUM1OwogICAgICAgIGNvbG9yOiAjOUE5QTlBOwogICAgICAgIG1pbi1oZWlnaHQ6MjBweDsKICAgIH0KCgogICAgYmxvY2txdW90ZSBwIHsKICAgICAgICBtYXJnaW46IDAuOGVtIDA7CiAgICB9CgogICAgYmxvY2txdW90ZSBzcGFuLm1kX2xpbmUgewogICAgICAgIG1hcmdpbi1ib3R0b206IDAuMjVlbTsKICAgICAgICBtYXJnaW4tdG9wOiAwLjI1ZW07CiAgICB9CgogICAgYmxvY2txdW90ZSB1bHsKICAgICAgICBwYWRkaW5nOiAwIDE1cHg7CiAgICB9CgogICAgYmxvY2txdW90ZSBzbWFsbCB7CiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrOwogICAgICAgIG1hcmdpbjogMC44ZW0gMCAwLjhlbSAxLjVlbTsKICAgICAgICBmb250LXNpemU6IDAuOWVtOwogICAgICAgIGNvbG9yOiAjY2NjOwogICAgfQoKCgoKCgogICAgdGFibGUgewogICAgICAgIGxpbmUtaGVpZ2h0OiAxLjc7CiAgICAgICAgLW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94OwogICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7CiAgICAgICAgbWFyZ2luOiAxZW0gMDsKICAgICAgICB3aWR0aDogMTAwJTsKICAgICAgICBtYXgtd2lkdGg6IDEwMCU7CiAgICAgICAgYm9yZGVyLXdpZHRoOiAxcHg7CiAgICAgICAgYm9yZGVyLXN0eWxlOiBzb2xpZDsKICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsKICAgICAgICBib3JkZXItc3BhY2luZzogMDsKICAgICAgICB3b3JkLWJyZWFrOiBub3JtYWw7CiAgICB9CiAgICAKICAgIC8qIGZvciB3ZWNoYXQgb25seSBzdGFydHMgKi8KICAgIHRhYmxlIHRyewogICAgICAgIGJvcmRlci1yaWdodC1zdHlsZTogc29saWQ7CiAgICAgICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAxcHg7CiAgICB9CiAgICAKICAgIHRhYmxlIHRib2R5ewogICAgICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDFweDsKICAgICAgICBib3JkZXItYm90dG9tLXN0eWxlOiBzb2xpZDsKICAgIH0KICAgIC8qIGZvciB3ZWNoYXQgb25seSBlbmRzICovCgoKICAgIHRhYmxlLCB0YWJsZSB0ciwgdGFibGUgdHIgdGQsIHRhYmxlIHRyIHRoLCB0YWJsZSB0Ym9keSB7CiAgICAgICAgYm9yZGVyLWNvbG9yOiByZ2JhKDIwNSwgMjA1LCAyMDUsIDAuMzUpOwogICAgfQoKICAgIHRhYmxlIHRoIHsKICAgICAgICBmb250LXdlaWdodDogYm9sZDsKICAgIH0KCiAgICB0ciB0aCB7CiAgICAgICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMXB4OwogICAgICAgIGJvcmRlci1ib3R0b20tc3R5bGU6IHNvbGlkOwogICAgICAgIHRleHQtYWxpZ246IGxlZnQ7CiAgICB9CgogICAgdHIgdGgsIHRyIHRkIHsKICAgICAgICBwYWRkaW5nOiAxMHB4IDIwcHg7CiAgICAgICAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQ7CiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYmEoMjA1LCAyMDUsIDIwNSwgMC4zNSk7CiAgICB9CgogICAgdGJvZHkgdHI6bGFzdC1jaGlsZCB0ZHsKICAgICAgICBib3JkZXItYm90dG9tOiAwOwogICAgfQoKICAgIHRyIHRoOmxhc3QtY2hpbGQsIHRyIHRkOmxhc3QtY2hpbGQgewogICAgICAgIGJvcmRlci1yaWdodDogMDsKICAgIH0KCiAgICB0YWJsZSB0Ym9keSA+IHRyOm50aC1jaGlsZChvZGQpID4gdGQsIHRhYmxlIHRib2R5ID4gdHI6bnRoLWNoaWxkKG9kZCkgPiB0aCB7CiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMzUsIDIzNSwgMjM1LCAwLjIpOwogICAgfQoKCgoKICAgIGNvZGV7CiAgICAgICAgYmFja2dyb3VuZDogcmdiYSgyMzUsIDIzNSwgMjM1LCAwLjM1KTsKICAgICAgICBjb2xvcjogIzc4RTI5MTsKICAgICAgICBwYWRkaW5nOiAwIDVweDsKICAgICAgICBtYXJnaW46IDAgMnB4OwogICAgfQoKICAgIHByZXsKICAgICAgICBtYXJnaW4tdG9wOiAxLjJlbTsKICAgICAgICBtYXJnaW4tYm90dG9tOiAxLjJlbTsKICAgICAgICBwYWRkaW5nOiAxNXB4IDEwcHg7CiAgICAgICAgZGlzcGxheTogYmxvY2s7CiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgyMDUsIDIwNSwgMjA1LCAwLjM1KTsKICAgICAgICAvKmJhY2tncm91bmQ6IHJnYmEoMjM1LCAyMzUsIDIzNSwgMC4zNSk7Ki8KICAgICAgICBmb250LXNpemU6IDkwJTsKICAgICAgICBsaW5lLWhlaWdodDoyLjQ7CiAgICAgICAgd2hpdGUtc3BhY2U6IHByZS13cmFwOwogICAgICAgIG92ZXJmbG93LXk6IGhpZGRlbjsKICAgICAgICBvdmVyZmxvdy14OiBhdXRvOwogICAgICAgIHdvcmQtd3JhcDogbm9ybWFsOwogICAgfQogICAgCiAgICAuY29kZWhpbGl0ZSBwcmV7CiAgICAgICAgd2hpdGUtc3BhY2U6IHByZTsKICAgIH0KCiAgICAuaGlnaGxpZ2h0dGFibGUgdGR7CiAgICAgICAgLypiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIzNSwgMjM1LCAyMzUsIDAuMzUpICFpbXBvcnRhbnQ7Ki8KICAgIH0KCiAgICAud2l0aF9saW5lcyBwcmV7CiAgICAgICAgYm9yZGVyOm5vbmU7CiAgICAgICAgbWFyZ2luLXRvcDogMC4yZW07CiAgICAgICAgbWFyZ2luLWJvdHRvbTogMC4yZW07CiAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7CiAgICB9CgogICAgLmlzX2NvZGVfZmlsZSBwcmV7CiAgICAgICAgYm9yZGVyOiBub25lOwogICAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50OwogICAgfQoKICAgIC5jb2RlaGlsaXRlIHByZXsKICAgICAgICAvKndvcmQtd3JhcDogbm9ybWFsOyovCiAgICAgICAgZm9udC1zaXplOiAxM3B4OwogICAgfQoKICAgIHByZSBjb2RlewogICAgICAgIGJvcmRlcjpub25lOwogICAgICAgIGJhY2tncm91bmQ6IG5vbmU7CiAgICAgICAgcGFkZGluZzogMDsKICAgICAgICBtYXJnaW46IDA7CiAgICB9CgogICAgcHJlIHB7CiAgICAgICAgbWFyZ2luOiAwOwogICAgICAgIHBhZGRpbmc6IDA7CiAgICB9CgogICAgLmNvZGVoaWxpdGUgdGgsIC5jb2RlaGlsaXRlIHRkewogICAgICAgIGxpbmUtaGVpZ2h0OiAxLjhlbTsKICAgIH0KCgogICAgYXsKICAgICAgICBjb2xvcjogIzc3Qjg3RjsKICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7CiAgICAgICAgLy9ib3JkZXItYm90dG9tOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7CiAgICB9CgogICAgYTpob3ZlcnsKICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTsKICAgICAgICAvL2JvcmRlci1ib3R0b206IDFweCBzb2xpZCAjNzdCODdGOwogICAgfQoKICAgIHN0cm9uZyB7CiAgICAgICAgY29sb3I6ICNGRkZGRkY7CiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7CiAgICB9CgoKICAgIC8qIGZvciBtYXJrZG93biAqLwoKICAgIC5saW5lbm9zIHByZXsKCQliYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDsKCQlib3JkZXI6IG5vbmU7Cgl9CgoJLmxpbmVub3N7CgkgICAgcGFkZGluZzogMCA1cHggMCA1cHg7CgkgICAgd2lkdGg6IDAuMDAxJTsKCX0KCgkuaGlnaGxpZ2h0dGFibGUgIC5saW5lbm9zIHByZXsKCSAgICBwYWRkaW5nOiA1cHggMTBweDsKCX0KCQoJLmhpZ2hsaWdodHRhYmxlICAuY29kZSBwcmV7CgkgICAgcGFkZGluZzogMDsKCX0KCiAgICAudG9jewogICAgICAgIGJhY2tncm91bmQ6IE5vbmU7CiAgICAgICAgYm9yZGVyLXJhZGl1czogNXB4OwogICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIE5vbmU7CiAgICAgICAgbWFyZ2luOiAyN3B4IDAgNDdweCAwOwogICAgICAgIHBhZGRpbmc6IDEwcHggMDsKICAgIH0KCiAgICAudG9jIHVsewogICAgICAgIC8vcGFkZGluZzogNXB4IDQycHg7CiAgICB9CgogICAgLnRvYyB1bCBsaXsKICAgICAgICBwYWRkaW5nOiAwOwogICAgICAgIG1hcmdpbjogMDsKICAgIH0KICAgIC50b2MgYXsKICAgICAgICBjb2xvcjogI0E1QjBDMDsKICAgIH0KCgoKICAgIC50b2RvX2l0ZW17CiAgICAgICAgbGlzdC1zdHlsZTogbm9uZTsKICAgICAgICBtYXJnaW4tbGVmdDogLTEuNWVtCiAgICB9CiAgICAudG9kb19pdGVtIC50b2RvX2l0ZW0gewogICAgICAgIG1hcmdpbi1sZWZ0OiBhdXRvOwogICAgfQoKICAgIC50b2RvX2RvbmVfaXRlbXsKICAgICAgICBjb2xvcjogIzU1NTU1NTsKICAgIH0KCiAgICAudG9kb191bmRvbmVfaXRlbXsKICAgICAgICBjb2xvcjogI0RERERERDsKICAgIH0KCgogICAgdWwgbGkudG9kb19pdGVtewoJbGlzdC1zdHlsZS10eXBlOiBub25lOwogICAgfQoKICAgIHVsIGxpLnRvZG9faXRlbTpiZWZvcmV7CiAgICAgICAgY29udGVudDogJ+KYkCc7CiAgICAgICAgLypwYWRkaW5nLXJpZ2h0OiAwLjJlbTsqLwogICAgICAgIGZvbnQtZmFtaWx5OiBhcmlhbDsKICAgIH0KCiAgICB1bCBsaS50b2RvX2RvbmVfaXRlbTpiZWZvcmV7CiAgICAgICAgY29udGVudDogJ+KYkSc7CiAgICAgICAgLypwYWRkaW5nLXJpZ2h0OiAwLjJlbTsqLwogICAgICAgIGZvbnQtZmFtaWx5OiBhcmlhbDsKICAgIH0KCiAgICB1bCBsaS50b2RvX2l0ZW0gaW5wdXR7CiAgICAgICAgZGlzcGxheTpub25lCiAgICB9CgoKICAgIC8qcHlnbWVudHMqLwoKICAgIC5jb2RlaGlsaXRlewogICAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7CiAgICB9CgogICAgLyp0YWJsZS5oaWdobGlnaHR0YWJsZXsgYm9yZGVyOm5vbmU7IH0KICAgIC5oaWdobGlnaHR0YWJsZSB0ZHsgYm9yZGVyOiBub25lOyBwYWRkaW5nOiAwO30qLwoKICAgIC5mbG93LWdyYXBoaWMsIC5tZF9ibG9ja19zZWN0aW9uX2Zvcl9mbG93X2dyYXBoaWN7dGV4dC1hbGlnbjogY2VudGVyfQogICAgLmZsb3ctZ3JhcGhpYyB7IG92ZXJmbG93LXg6IGF1dG87fQogICAgLm1lcm1haWQsIC5tZF9ibG9ja19zZWN0aW9uX2Zvcl9tZXJtYWlke3RleHQtYWxpZ246IGNlbnRlcn0KICAgIAogICAgLmZsb3ctZ3JhcGhpYywgLm1lcm1haWR7CiAgICAgICAgYmFja2dyb3VuZDogI2ZmZmZmZjsKICAgIH0KCgogICAgdGFibGUsIHRyLCB0ZCwgdGgsIHRib2R5LCB0aGVhZCwgdGZvb3QsIC5tZF9lY2hhcnRzLCBibG9ja3F1b3RlIC5tZF9saW5lewogICAgICAgIHBhZ2UtYnJlYWstaW5zaWRlOiBhdm9pZCAhaW1wb3J0YW50OwogICAgfQoKICAgIC5mb290bm90ZXMgLm1kX2xpbmV7CiAgICAgICAgZGlzcGxheTogaW5saW5lICFpbXBvcnRhbnQ7CiAgICB9CgoKICAgIC5pbWdfcnRfOTB7CiAgICAgICAgdHJhbnNmb3JtOnJvdGF0ZSg5MGRlZyk7CiAgICAgICAgLW1zLXRyYW5zZm9ybTpyb3RhdGUoOTBkZWcpOwogICAgICAgIC1tb3otdHJhbnNmb3JtOnJvdGF0ZSg5MGRlZyk7CiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDkwZGVnKTsKICAgICAgICAtby10cmFuc2Zvcm06cm90YXRlKDkwZGVnKTsKICAgIH0KICAgIC5pbWdfcnRfMTgwewogICAgICAgIHRyYW5zZm9ybTpyb3RhdGUoMTgwZGVnKTsKICAgICAgICAtbXMtdHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpOwogICAgICAgIC1tb3otdHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpOwogICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpOwogICAgICAgIC1vLXRyYW5zZm9ybTpyb3RhdGUoMTgwZGVnKTsKICAgIH0KICAgIC5pbWdfcnRfMjcwewogICAgICAgIHRyYW5zZm9ybTpyb3RhdGUoMjcwZGVnKTsKICAgICAgICAtbXMtdHJhbnNmb3JtOnJvdGF0ZSgyNzBkZWcpOwogICAgICAgIC1tb3otdHJhbnNmb3JtOnJvdGF0ZSgyNzBkZWcpOwogICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgyNzBkZWcpOwogICAgICAgIC1vLXRyYW5zZm9ybTpyb3RhdGUoMjcwZGVnKTsKICAgIH0KCiAgICAubWRfaGFzX2Jsb2NrX2JlbG93ewogICAgICAgIG1hcmdpbi1ib3R0b206IDAuMWVtICFpbXBvcnRhbnQ7CiAgICB9CiAgICAubWRfaGFzX2Jsb2NrX2JlbG93X2ltZ3sKICAgICAgICBtYXJnaW4tYm90dG9tOiAtMC42ZW0gIWltcG9ydGFudDsKICAgIH0KCgogICAgLmNvZGVoaWxpdGUgLmVycnsKICAgICAgICBib3JkZXI6IG5vbmUgIWltcG9ydGFudDsKICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50OwogICAgfQoKCgogICAgICAgIHNwYW4ubWRfbGluZXttYXJnaW4tYm90dG9tOjAuNWVtOyBkaXNwbGF5OmJsb2NrOyBsaW5lLWhlaWdodDoyLjF9CiAgICAgICAgLm1kX2xpbmUgYnJ7IGRpc3BsYXk6IG5vbmU7fQogICAgICAgIC5jb2RlaGlsaXRlIC5obGwgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmZmNjIH0KLmNvZGVoaWxpdGUgIHsgYmFja2dyb3VuZDogI2ZmZmZmZjsgfQouY29kZWhpbGl0ZSAuYyB7IGNvbG9yOiAjMTc3NTAwIH0gLyogQ29tbWVudCAqLwouY29kZWhpbGl0ZSAuZXJyIHsgY29sb3I6ICMwMDAwMDAgfSAvKiBFcnJvciAqLwouY29kZWhpbGl0ZSAuayB7IGNvbG9yOiAjQTkwRDkxIH0gLyogS2V5d29yZCAqLwouY29kZWhpbGl0ZSAubCB7IGNvbG9yOiAjMUMwMUNFIH0gLyogTGl0ZXJhbCAqLwouY29kZWhpbGl0ZSAubiB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZSAqLwouY29kZWhpbGl0ZSAubyB7IGNvbG9yOiAjMDAwMDAwIH0gLyogT3BlcmF0b3IgKi8KLmNvZGVoaWxpdGUgLmNoIHsgY29sb3I6ICMxNzc1MDAgfSAvKiBDb21tZW50Lkhhc2hiYW5nICovCi5jb2RlaGlsaXRlIC5jbSB7IGNvbG9yOiAjMTc3NTAwIH0gLyogQ29tbWVudC5NdWx0aWxpbmUgKi8KLmNvZGVoaWxpdGUgLmNwIHsgY29sb3I6ICM2MzM4MjAgfSAvKiBDb21tZW50LlByZXByb2MgKi8KLmNvZGVoaWxpdGUgLmNwZiB7IGNvbG9yOiAjMTc3NTAwIH0gLyogQ29tbWVudC5QcmVwcm9jRmlsZSAqLwouY29kZWhpbGl0ZSAuYzEgeyBjb2xvcjogIzE3NzUwMCB9IC8qIENvbW1lbnQuU2luZ2xlICovCi5jb2RlaGlsaXRlIC5jcyB7IGNvbG9yOiAjMTc3NTAwIH0gLyogQ29tbWVudC5TcGVjaWFsICovCi5jb2RlaGlsaXRlIC5rYyB7IGNvbG9yOiAjQTkwRDkxIH0gLyogS2V5d29yZC5Db25zdGFudCAqLwouY29kZWhpbGl0ZSAua2QgeyBjb2xvcjogI0E5MEQ5MSB9IC8qIEtleXdvcmQuRGVjbGFyYXRpb24gKi8KLmNvZGVoaWxpdGUgLmtuIHsgY29sb3I6ICNBOTBEOTEgfSAvKiBLZXl3b3JkLk5hbWVzcGFjZSAqLwouY29kZWhpbGl0ZSAua3AgeyBjb2xvcjogI0E5MEQ5MSB9IC8qIEtleXdvcmQuUHNldWRvICovCi5jb2RlaGlsaXRlIC5rciB7IGNvbG9yOiAjQTkwRDkxIH0gLyogS2V5d29yZC5SZXNlcnZlZCAqLwouY29kZWhpbGl0ZSAua3QgeyBjb2xvcjogI0E5MEQ5MSB9IC8qIEtleXdvcmQuVHlwZSAqLwouY29kZWhpbGl0ZSAubGQgeyBjb2xvcjogIzFDMDFDRSB9IC8qIExpdGVyYWwuRGF0ZSAqLwouY29kZWhpbGl0ZSAubSB7IGNvbG9yOiAjMUMwMUNFIH0gLyogTGl0ZXJhbC5OdW1iZXIgKi8KLmNvZGVoaWxpdGUgLnMgeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nICovCi5jb2RlaGlsaXRlIC5uYSB7IGNvbG9yOiAjODM2QzI4IH0gLyogTmFtZS5BdHRyaWJ1dGUgKi8KLmNvZGVoaWxpdGUgLm5iIHsgY29sb3I6ICNBOTBEOTEgfSAvKiBOYW1lLkJ1aWx0aW4gKi8KLmNvZGVoaWxpdGUgLm5jIHsgY29sb3I6ICMzRjZFNzUgfSAvKiBOYW1lLkNsYXNzICovCi5jb2RlaGlsaXRlIC5ubyB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZS5Db25zdGFudCAqLwouY29kZWhpbGl0ZSAubmQgeyBjb2xvcjogIzAwMDAwMCB9IC8qIE5hbWUuRGVjb3JhdG9yICovCi5jb2RlaGlsaXRlIC5uaSB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZS5FbnRpdHkgKi8KLmNvZGVoaWxpdGUgLm5lIHsgY29sb3I6ICMwMDAwMDAgfSAvKiBOYW1lLkV4Y2VwdGlvbiAqLwouY29kZWhpbGl0ZSAubmYgeyBjb2xvcjogIzAwMDAwMCB9IC8qIE5hbWUuRnVuY3Rpb24gKi8KLmNvZGVoaWxpdGUgLm5sIHsgY29sb3I6ICMwMDAwMDAgfSAvKiBOYW1lLkxhYmVsICovCi5jb2RlaGlsaXRlIC5ubiB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZS5OYW1lc3BhY2UgKi8KLmNvZGVoaWxpdGUgLm54IHsgY29sb3I6ICMwMDAwMDAgfSAvKiBOYW1lLk90aGVyICovCi5jb2RlaGlsaXRlIC5weSB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZS5Qcm9wZXJ0eSAqLwouY29kZWhpbGl0ZSAubnQgeyBjb2xvcjogIzAwMDAwMCB9IC8qIE5hbWUuVGFnICovCi5jb2RlaGlsaXRlIC5udiB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZS5WYXJpYWJsZSAqLwouY29kZWhpbGl0ZSAub3cgeyBjb2xvcjogIzAwMDAwMCB9IC8qIE9wZXJhdG9yLldvcmQgKi8KLmNvZGVoaWxpdGUgLm1iIHsgY29sb3I6ICMxQzAxQ0UgfSAvKiBMaXRlcmFsLk51bWJlci5CaW4gKi8KLmNvZGVoaWxpdGUgLm1mIHsgY29sb3I6ICMxQzAxQ0UgfSAvKiBMaXRlcmFsLk51bWJlci5GbG9hdCAqLwouY29kZWhpbGl0ZSAubWggeyBjb2xvcjogIzFDMDFDRSB9IC8qIExpdGVyYWwuTnVtYmVyLkhleCAqLwouY29kZWhpbGl0ZSAubWkgeyBjb2xvcjogIzFDMDFDRSB9IC8qIExpdGVyYWwuTnVtYmVyLkludGVnZXIgKi8KLmNvZGVoaWxpdGUgLm1vIHsgY29sb3I6ICMxQzAxQ0UgfSAvKiBMaXRlcmFsLk51bWJlci5PY3QgKi8KLmNvZGVoaWxpdGUgLnNhIHsgY29sb3I6ICNDNDFBMTYgfSAvKiBMaXRlcmFsLlN0cmluZy5BZmZpeCAqLwouY29kZWhpbGl0ZSAuc2IgeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLkJhY2t0aWNrICovCi5jb2RlaGlsaXRlIC5zYyB7IGNvbG9yOiAjMjMwMENFIH0gLyogTGl0ZXJhbC5TdHJpbmcuQ2hhciAqLwouY29kZWhpbGl0ZSAuZGwgeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLkRlbGltaXRlciAqLwouY29kZWhpbGl0ZSAuc2QgeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLkRvYyAqLwouY29kZWhpbGl0ZSAuczIgeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLkRvdWJsZSAqLwouY29kZWhpbGl0ZSAuc2UgeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLkVzY2FwZSAqLwouY29kZWhpbGl0ZSAuc2ggeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLkhlcmVkb2MgKi8KLmNvZGVoaWxpdGUgLnNpIHsgY29sb3I6ICNDNDFBMTYgfSAvKiBMaXRlcmFsLlN0cmluZy5JbnRlcnBvbCAqLwouY29kZWhpbGl0ZSAuc3ggeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLk90aGVyICovCi5jb2RlaGlsaXRlIC5zciB7IGNvbG9yOiAjQzQxQTE2IH0gLyogTGl0ZXJhbC5TdHJpbmcuUmVnZXggKi8KLmNvZGVoaWxpdGUgLnMxIHsgY29sb3I6ICNDNDFBMTYgfSAvKiBMaXRlcmFsLlN0cmluZy5TaW5nbGUgKi8KLmNvZGVoaWxpdGUgLnNzIHsgY29sb3I6ICNDNDFBMTYgfSAvKiBMaXRlcmFsLlN0cmluZy5TeW1ib2wgKi8KLmNvZGVoaWxpdGUgLmJwIHsgY29sb3I6ICM1QjI2OUEgfSAvKiBOYW1lLkJ1aWx0aW4uUHNldWRvICovCi5jb2RlaGlsaXRlIC5mbSB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZS5GdW5jdGlvbi5NYWdpYyAqLwouY29kZWhpbGl0ZSAudmMgeyBjb2xvcjogIzAwMDAwMCB9IC8qIE5hbWUuVmFyaWFibGUuQ2xhc3MgKi8KLmNvZGVoaWxpdGUgLnZnIHsgY29sb3I6ICMwMDAwMDAgfSAvKiBOYW1lLlZhcmlhYmxlLkdsb2JhbCAqLwouY29kZWhpbGl0ZSAudmkgeyBjb2xvcjogIzAwMDAwMCB9IC8qIE5hbWUuVmFyaWFibGUuSW5zdGFuY2UgKi8KLmNvZGVoaWxpdGUgLnZtIHsgY29sb3I6ICMwMDAwMDAgfSAvKiBOYW1lLlZhcmlhYmxlLk1hZ2ljICovCi5jb2RlaGlsaXRlIC5pbCB7IGNvbG9yOiAjMUMwMUNFIH0gLyogTGl0ZXJhbC5OdW1iZXIuSW50ZWdlci5Mb25nICovCiAgICAvKiBwYWdlX2NzcyAqLwoKICAgIAogICAgaHRtbHsKICAgICAgICBiYWNrZ3JvdW5kOiAjMTAxNjFBOwogICAgfQogICAgYm9keXsKICAgICAgICB3aWR0aDogOTAlOwogICAgICAgIG1heC13aWR0aDogOTYwcHg7CiAgICAgICAgYmFja2dyb3VuZDogIzE3MUQyMTsKICAgICAgICBtYXJnaW46IDNlbSBhdXRvIDA7CiAgICAgICAgcGFkZGluZy10b3A6IDJlbTsKICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjMTAxNjFBOwogICAgICAgIGJvcmRlci13aWR0aDogMCAxcHg7CiAgICB9CgogICAgLnBvc3R7CiAgICAgICAgcGFkZGluZzogNSUgMTAlOwogICAgICAgIG1hcmdpbi10b3A6IDA7CiAgICAgICAgbWFyZ2luLWJvdHRvbTogMDsKICAgIH0KICAgIAoKICAgIC50aXRsZV9jb250YWluZXJ7CiAgICAgICAgbWFyZ2luOiAtMmVtIDAgMy41ZW07CiAgICAgICAgcGFkZGluZy1ib3R0b206IDJlbTsKICAgICAgICBib3JkZXItYm90dG9tOiAzcHggZG91YmxlICMxMDE2MUE7CiAgICB9CiAgICAudGl0bGVfY29udGFpbmVyIGgxewogICAgICAgIG1hcmdpbi10b3A6IDEuMmVtOwogICAgICAgIG1hcmdpbi1ib3R0b206IDAuNmVtOwogICAgICAgIGxpbmUtaGVpZ2h0OiAxLjM1OwogICAgICAgIGZvbnQtc2l6ZTogMi4yNWVtOwogICAgfQogICAgLnRpdGxlX2NvbnRhaW5lciBoMnsKICAgICAgICBjb2xvcjogIzlBOUE5QTsKICAgICAgICBmb250LXNpemU6IDFlbTsKICAgICAgICBmb250LXdlaWdodDogbm9ybWFsOwogICAgICAgIHBhZGRpbmctYm90dG9tOiAyZW07CiAgICAgICAgbGluZS1oZWlnaHQ6IDEuMzU7CiAgICAgICAgbWFyZ2luLWJvdHRvbTogLTJlbTsKICAgIH0KCiAgICBAbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDc2MHB4KXsKICAgICAgICBodG1sewogICAgICAgICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDsKICAgICAgICB9CiAgICAgICAgYm9keXsKICAgICAgICAgICAgbWFyZ2luOiAwOwogICAgICAgIH0KICAgICAgICAucG9zdHsKICAgICAgICAgICAgcGFkZGluZzogMDsKICAgICAgICB9CiAgICB9CiAgICAvKiBwYWdlX2NzcyAqLwoKICAgIA==">
    <!--header_scripts-->
</head>
<body>
    <div class="post">
        <div class="post_body">
            
            <h1 id="toc_0" class="h16 md_first_h"><span class="span_for_h">不透明类型</span></h1>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">具有不透明返回类型的函数或方法会隐藏返回值的类型信息。函数不再提供具体的类型作为返回类型，而是根据它支持的协议来描述返回值。在处理模块和调用代码之间的关系时，隐藏类型信息非常有用，因为返回的底层数据类型仍然可以保持私有。而且不同于返回协议类型，不透明类型能保证类型一致性 —— 编译器能获取到类型信息，同时模块使用者却不能获取到。</span>
</p>

<h2 id="toc_1" class="h16"><span class="span_for_h">不透明类型解决的问题 {#the-problem-that-opaque-types-solve}</span></h2>

<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">举个例子，假设你正在写一个模块，用来绘制 ASCII 符号构成的几何图形。它的基本特征是有一个 <code>draw()</code> 方法，会返回一个代表最终几何图形的字符串，你可以用包含这个方法的 <code>Shape</code> 协议来描述：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">protocol</span> <span class="nc">Shape</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">draw</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">String</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="nc">Triangle</span><span class="p">:</span> <span class="n">Shape</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">size</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">func</span> <span class="nf">draw</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nv">result</span> <span class="p">=</span> <span class="p">[</span><span class="nb">String</span><span class="p">]()</span>
        <span class="k">for</span> <span class="n">length</span> <span class="k">in</span> <span class="mf">1.</span><span class="p">..</span><span class="n">size</span> <span class="p">{</span>
            <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">String</span><span class="p">(</span><span class="n">repeating</span><span class="p">:</span> <span class="s">&quot;*&quot;</span><span class="p">,</span> <span class="bp">count</span><span class="p">:</span> <span class="n">length</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">.</span><span class="n">joined</span><span class="p">(</span><span class="n">separator</span><span class="p">:</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">smallTriangle</span> <span class="p">=</span> <span class="n">Triangle</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="n">smallTriangle</span><span class="p">.</span><span class="n">draw</span><span class="p">())</span>
<span class="c1">// *</span>
<span class="c1">// **</span>
<span class="c1">// ***</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">你可以利用泛型来实现垂直翻转之类的操作，就像下面这样。然而，这种方式有一个很大的局限：翻转操作的结果会暴露我们用于构造结果的泛型类型：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">FlippedShape</span><span class="p">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Shape</span><span class="p">&gt;:</span> <span class="n">Shape</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">shape</span><span class="p">:</span> <span class="n">T</span>
    <span class="kd">func</span> <span class="nf">draw</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">lines</span> <span class="p">=</span> <span class="n">shape</span><span class="p">.</span><span class="n">draw</span><span class="p">().</span><span class="bp">split</span><span class="p">(</span><span class="n">separator</span><span class="p">:</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lines</span><span class="p">.</span><span class="n">reversed</span><span class="p">().</span><span class="n">joined</span><span class="p">(</span><span class="n">separator</span><span class="p">:</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">flippedTriangle</span> <span class="p">=</span> <span class="n">FlippedShape</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">smallTriangle</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="n">flippedTriangle</span><span class="p">.</span><span class="n">draw</span><span class="p">())</span>
<span class="c1">// ***</span>
<span class="c1">// **</span>
<span class="c1">// *</span>
</pre></div>

<!--block_code_end-->
<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">如下方代码所示，用同样的方式定义了一个 <code>JoinedShape&lt;T: Shape, U: Shape&gt;</code> 结构体，能将几何图形垂直拼接起来。如果拼接一个翻转三角形和一个普通三角形，它就会得到类似于 <code>JoinedShape&lt;FlippedShape&lt;Triangle&gt;, Triangle&gt;</code> 这样的类型。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">JoinedShape</span><span class="p">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">U</span><span class="p">:</span> <span class="n">Shape</span><span class="p">&gt;:</span> <span class="n">Shape</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">top</span><span class="p">:</span> <span class="n">T</span>
    <span class="kd">var</span> <span class="nv">bottom</span><span class="p">:</span> <span class="n">U</span>
    <span class="kd">func</span> <span class="nf">draw</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">top</span><span class="p">.</span><span class="n">draw</span><span class="p">()</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">+</span> <span class="n">bottom</span><span class="p">.</span><span class="n">draw</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">joinedTriangles</span> <span class="p">=</span> <span class="n">JoinedShape</span><span class="p">(</span><span class="n">top</span><span class="p">:</span> <span class="n">smallTriangle</span><span class="p">,</span> <span class="n">bottom</span><span class="p">:</span> <span class="n">flippedTriangle</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="n">joinedTriangles</span><span class="p">.</span><span class="n">draw</span><span class="p">())</span>
<span class="c1">// *</span>
<span class="c1">// **</span>
<span class="c1">// ***</span>
<span class="c1">// ***</span>
<span class="c1">// **</span>
<span class="c1">// *</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">暴露构造所用的具体类型会造成类型信息的泄露，因为 ASCII 几何图形模块的部分公开接口必须声明完整的返回类型，而实际上这些类型信息并不应该被公开声明。输出同一种几何图形，模块内部可能有多种实现方式，而外部使用时，应该与内部各种变换顺序的实现逻辑无关。诸如 <code>JoinedShape</code> 和 <code>FlippedShape</code> 这样包装后的类型，模块使用者并不关心，它们也不应该可见。模块的公开接口应该由拼接、翻转等基础操作组成，这些操作也应该返回独立的 <code>Shape</code> 类型的值。</span>
</p>

<h2 id="toc_2" class="h16"><span class="span_for_h">返回不透明类型 {#returning-an-opaque-type}</span></h2>

<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">你可以认为不透明类型和泛型相反。泛型允许调用一个方法时，为这个方法的形参和返回值指定一个与实现无关的类型。举个例子，下面这个函数的返回值类型就由它的调用者决定：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">max</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="kc">_</span> <span class="n">y</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">T</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="nb">Comparable</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end"><code>x</code> 和 <code>y</code> 的值由调用 <code>max(_:_:)</code> 的代码决定，而它们的类型决定了 <code>T</code> 的具体类型。调用代码可以使用任何遵循了 <code>Comparable</code> 协议的类型，函数内部也要以一种通用的方式来写代码，才能应对调用者传入的各种类型。<code>max(_:_:)</code> 的实现就只使用了所有遵循 <code>Comparable</code>  协议的类型共有的特性。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">而在返回不透明类型的函数中，上述角色发生了互换。不透明类型允许函数实现时，选择一个与调用代码无关的返回类型。比如，下面的例子返回了一个梯形，却没直接输出梯形的底层类型：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">Square</span><span class="p">:</span> <span class="n">Shape</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">size</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">func</span> <span class="nf">draw</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">line</span> <span class="p">=</span> <span class="nb">String</span><span class="p">(</span><span class="n">repeating</span><span class="p">:</span> <span class="s">&quot;*&quot;</span><span class="p">,</span> <span class="bp">count</span><span class="p">:</span> <span class="n">size</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nv">result</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">&lt;</span><span class="nb">String</span><span class="p">&gt;(</span><span class="n">repeating</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span> <span class="bp">count</span><span class="p">:</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">.</span><span class="n">joined</span><span class="p">(</span><span class="n">separator</span><span class="p">:</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">makeTrapezoid</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">some</span> <span class="n">Shape</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">top</span> <span class="p">=</span> <span class="n">Triangle</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">middle</span> <span class="p">=</span> <span class="n">Square</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">bottom</span> <span class="p">=</span> <span class="n">FlippedShape</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">top</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">trapezoid</span> <span class="p">=</span> <span class="n">JoinedShape</span><span class="p">(</span>
        <span class="n">top</span><span class="p">:</span> <span class="n">top</span><span class="p">,</span>
        <span class="n">bottom</span><span class="p">:</span> <span class="n">JoinedShape</span><span class="p">(</span><span class="n">top</span><span class="p">:</span> <span class="n">middle</span><span class="p">,</span> <span class="n">bottom</span><span class="p">:</span> <span class="n">bottom</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">trapezoid</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">trapezoid</span> <span class="p">=</span> <span class="n">makeTrapezoid</span><span class="p">()</span>
<span class="bp">print</span><span class="p">(</span><span class="n">trapezoid</span><span class="p">.</span><span class="n">draw</span><span class="p">())</span>
<span class="c1">// *</span>
<span class="c1">// **</span>
<span class="c1">// **</span>
<span class="c1">// **</span>
<span class="c1">// **</span>
<span class="c1">// *</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">这个例子中，<code>makeTrapezoid()</code> 函数将返回值类型定义为 <code>some Shape</code>；因此，该函数返回遵循 <code>Shape</code> 协议的给定类型，而不需指定任何具体类型。这样写 <code>makeTrapezoid()</code> 函数可以表明它公共接口的基本性质 —— 返回的是一个几何图形 —— 而不是部分的公共接口生成的特殊类型。上述实现过程中使用了两个三角形和一个正方形，还可以用其他多种方式重写画梯形的函数，都不必改变返回类型。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">这个例子凸显了不透明返回类型和泛型的相反之处。<code>makeTrapezoid()</code> 中代码可以返回任意它需要的类型，只要这个类型是遵循 <code>Shape</code> 协议的，就像调用泛型函数时可以使用任何需要的类型一样。这个函数的调用代码需要采用通用的方式，就像泛型函数的实现代码一样，这样才能让 <code>makeTrapezoid()</code> 返回的任何 <code>Shape</code> 类型的值都能被正常使用。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">你也可以将不透明返回类型和泛型结合起来，下面的两个泛型函数也都返回了遵循 <code>Shape</code> 协议的不透明类型。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">flip</span><span class="p">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Shape</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">shape</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">some</span> <span class="n">Shape</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">FlippedShape</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">shape</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">join</span><span class="p">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">U</span><span class="p">:</span> <span class="n">Shape</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">top</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="kc">_</span> <span class="n">bottom</span><span class="p">:</span> <span class="n">U</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">some</span> <span class="n">Shape</span> <span class="p">{</span>
    <span class="n">JoinedShape</span><span class="p">(</span><span class="n">top</span><span class="p">:</span> <span class="n">top</span><span class="p">,</span> <span class="n">bottom</span><span class="p">:</span> <span class="n">bottom</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">opaqueJoinedTriangles</span> <span class="p">=</span> <span class="bp">join</span><span class="p">(</span><span class="n">smallTriangle</span><span class="p">,</span> <span class="n">flip</span><span class="p">(</span><span class="n">smallTriangle</span><span class="p">))</span>
<span class="bp">print</span><span class="p">(</span><span class="n">opaqueJoinedTriangles</span><span class="p">.</span><span class="n">draw</span><span class="p">())</span>
<span class="c1">// *</span>
<span class="c1">// **</span>
<span class="c1">// ***</span>
<span class="c1">// ***</span>
<span class="c1">// **</span>
<span class="c1">// *</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">这个例子中 <code>opaqueJoinedTriangles</code> 的值和前文 <a class="md_compiled" href="#the-problem-that-opaque-types-solve">不透明类型解决的问题</a> 中关于泛型的那个例子中的 <code>joinedTriangles</code> 完全一样。不过和前文不一样的是，<code>flip(-:)</code> 和 <code>join(-:-:)</code> 将对泛型参数的操作后的返回结果包装成了不透明类型，这样保证了在结果中泛型参数类型不可见。两个函数都是泛型函数，因为他们都依赖于泛型参数，而泛型参数又将 <code>FlippedShape</code> 和 <code>JoinedShape</code> 所需要的类型信息传递给它们。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">如果函数中有多个地方返回了不透明类型，那么所有可能的返回值都必须是同一类型。即使对于泛型函数，不透明返回类型可以使用泛型参数，但仍需保证返回类型唯一。比如，下面就是一个<em class="md_patched_em">非法</em>示例 —— 包含针对 <code>Square</code> 类型进行特殊处理的翻转函数。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">invalidFlip</span><span class="p">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Shape</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">shape</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">some</span> <span class="n">Shape</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">shape</span> <span class="k">is</span> <span class="n">Square</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">shape</span> <span class="c1">// 错误：返回类型不一致</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">FlippedShape</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">shape</span><span class="p">)</span> <span class="c1">// 错误：返回类型不一致</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">如果你调用这个函数时传入一个 <code>Square</code> 类型，那么它会返回 <code>Square</code> 类型；否则，它会返回一个 <code>FlippedShape</code> 类型。这违反了返回值类型唯一的要求，所以 <code>invalidFlip(_:)</code> 不正确。修正 <code>invalidFlip(_:)</code> 的方法之一就是将针对 <code>Square</code> 的特殊处理移入到 <code>FlippedShape</code> 的实现中去，这样就能保证这个函数始终返回 <code>FlippedShape</code>：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">FlippedShape</span><span class="p">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Shape</span><span class="p">&gt;:</span> <span class="n">Shape</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">shape</span><span class="p">:</span> <span class="n">T</span>
    <span class="kd">func</span> <span class="nf">draw</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="k">is</span> <span class="n">Square</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">shape</span><span class="p">.</span><span class="n">draw</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="kd">let</span> <span class="nv">lines</span> <span class="p">=</span> <span class="n">shape</span><span class="p">.</span><span class="n">draw</span><span class="p">().</span><span class="bp">split</span><span class="p">(</span><span class="n">separator</span><span class="p">:</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lines</span><span class="p">.</span><span class="n">reversed</span><span class="p">().</span><span class="n">joined</span><span class="p">(</span><span class="n">separator</span><span class="p">:</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">返回类型始终唯一的要求，并不会影响在返回的不透明类型中使用泛型。比如下面的函数，就是在返回的底层类型中使用了泛型参数：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="p">`</span><span class="k">repeat</span><span class="p">`&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Shape</span><span class="p">&gt;(</span><span class="n">shape</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="bp">count</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">some</span> <span class="n">Collection</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Array</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">repeating</span><span class="p">:</span> <span class="n">shape</span><span class="p">,</span> <span class="bp">count</span><span class="p">:</span> <span class="bp">count</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">这种情况下，返回的底层类型会根据 <code>T</code> 的不同而发生变化：但无论什么形状被传入，<code>repeat(shape:count:)</code> 都会创建并返回一个元素为相应形状的数组。尽管如此，返回值始终还是同样的底层类型 <code>[T]</code>， 所以这符合不透明返回类型始终唯一的要求。</span>
</p>

<h2 id="toc_3" class="h16"><span class="span_for_h">不透明类型和协议类型的区别 {#differences-between-opaque-types-and-protocol-types}</span></h2>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">虽然使用不透明类型作为函数返回值，看起来和返回协议类型非常相似，但这两者有一个主要区别，就在于是否需要保证类型一致性。一个不透明类型只能对应一个具体的类型，即便函数调用者并不能知道是哪一种类型；协议类型可以同时对应多个类型，只要它们都遵循同一协议。总的来说，协议类型更具灵活性，底层类型可以存储更多样的值，而不透明类型对这些底层类型有更强的限定。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">比如，这是 <code>flip(_:)</code> 方法不采用不透明类型，而采用返回协议类型的版本：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">protoFlip</span><span class="p">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Shape</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">shape</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Shape</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">FlippedShape</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">shape</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">这个版本的 <code>protoFlip(_:)</code> 和 <code>flip(_:)</code> 有相同的函数体，并且它也始终返回唯一类型。但不同于 <code>flip(_:)</code>，<code>protoFlip(_:)</code> 返回值其实不需要始终返回唯一类型 —— 返回类型只需要遵循 <code>Shape</code> 协议即可。换句话说，<code>protoFlip(_:)</code> 比起 <code>flip(_:)</code> 对 API 调用者的约束更加松散。它保留了返回多种不同类型的灵活性：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">protoFlip</span><span class="p">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Shape</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">shape</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Shape</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">shape</span> <span class="k">is</span> <span class="n">Square</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">shape</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">FlippedShape</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">shape</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">修改后的代码根据代表形状的参数的不同，可能返回 <code>Square</code> 实例或者 <code>FlippedShape</code> 实例，所以同样的函数可能返回完全不同的两个类型。当翻转相同形状的多个实例时，此函数的其他有效版本也可能返回完全不同类型的结果。<code>protoFlip(_:)</code> 返回类型的不确定性，意味着很多依赖返回类型信息的操作也无法执行了。举个例子，这个函数的返回结果就不能用 == 运算符进行比较了。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">let</span> <span class="nv">protoFlippedTriangle</span> <span class="p">=</span> <span class="n">protoFlip</span><span class="p">(</span><span class="n">smallTriangle</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">sameThing</span> <span class="p">=</span> <span class="n">protoFlip</span><span class="p">(</span><span class="n">smallTriangle</span><span class="p">)</span>
<span class="n">protoFlippedTriangle</span> <span class="p">==</span> <span class="n">sameThing</span>  <span class="c1">// 错误</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">上面的例子中，最后一行的错误来源于多个原因。最直接的问题在于，<code>Shape</code> 协议中并没有包含对 == 运算符的声明。如果你尝试加上这个声明，那么你会遇到新的问题，就是 == 运算符需要知道左右两侧参数的类型。这类运算符通常会使用 <code>Self</code> 类型作为参数，用来匹配符合协议的具体类型，但是由于将协议当成类型使用时会发生类型擦除，所以并不能给协议加上对 <code>Self</code> 的实现要求。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">将协议类型作为函数的返回类型能更加灵活，函数只要返回遵循协议的类型即可。然而，更具灵活性导致牺牲了对返回值执行某些操作的能力。上面的例子就说明了为什么不能使用 == 运算符 —— 它依赖于具体的类型信息，而这正是使用协议类型所无法提供的。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">这种方法的另一个问题在于，变换形状的操作不能嵌套。翻转三角形的结果是一个 <code>Shape</code> 类型的值，而 <code>protoFlip(_:)</code> 方法的则将遵循 <code>Shape</code> 协议的类型作为形参，然而协议类型的值并不遵循这个协议；<code>protoFlip(_:)</code> 的返回值也并不遵循 <code>Shape</code> 协议。这就是说 <code>protoFlip(protoFlip(smallTriange))</code> 这样的多重变换操作是非法的，因为经过翻转操作后的结果类型并不能作为 <code>protoFlip(_:)</code> 的形参。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">相比之下，不透明类型则保留了底层类型的唯一性。Swift 能够推断出关联类型，这个特点使得作为函数返回值，不透明类型比协议类型有更大的使用场景。比如，下面这个例子是 <a class="md_compiled" href="./22_Generics.md">泛型</a> 中讲到的 <code>Container</code> 协议：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">protocol</span> <span class="nc">Container</span> <span class="p">{</span>
    <span class="n">associatedtype</span> <span class="n">Item</span>
    <span class="kd">var</span> <span class="nv">count</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span> <span class="kr">get</span> <span class="p">}</span>
    <span class="kd">subscript</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Item</span> <span class="p">{</span> <span class="kr">get</span> <span class="p">}</span>
<span class="p">}</span>
<span class="kd">extension</span> <span class="nc">Array</span><span class="p">:</span> <span class="n">Container</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">你不能将 <code>Container</code> 作为方法的返回类型，因为此协议有一个关联类型。你也不能将它用于对泛型返回类型的约束，因为函数体之外并没有暴露足够多的信息来推断泛型类型。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="c1">// 错误：有关联类型的协议不能作为返回类型。</span>
<span class="kd">func</span> <span class="nf">makeProtocolContainer</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Container</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">item</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// 错误：没有足够多的信息来推断 C 的类型。</span>
<span class="kd">func</span> <span class="nf">makeProtocolContainer</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">:</span> <span class="n">Container</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">C</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">item</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">而使用不透明类型 <code>some Container</code> 作为返回类型，就能够明确地表达所需要的 API 契约 —— 函数会返回一个集合类型，但并不指明它的具体类型：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">makeOpaqueContainer</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">some</span> <span class="n">Container</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">item</span><span class="p">]</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">opaqueContainer</span> <span class="p">=</span> <span class="n">makeOpaqueContainer</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="mi">12</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">twelve</span> <span class="p">=</span> <span class="n">opaqueContainer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="bp">print</span><span class="p">(</span><span class="n">type</span><span class="p">(</span><span class="n">of</span><span class="p">:</span> <span class="n">twelve</span><span class="p">))</span>
<span class="c1">// 输出 &quot;Int&quot;</span>
</pre></div>

<!--block_code_end-->
<p class="md_block last_md_block_in_page">
    <span class="md_line md_line_start md_line_end"><code>twelve</code> 的类型可以被推断出为 <code>Int</code>， 这说明了类型推断适用于不透明类型。在 <code>makeOpaqueContainer(item:)</code> 的实现中，底层类型是不透明集合 <code>[T]</code>。在上述这种情况下，<code>T</code> 就是 <code>Int</code> 类型，所以返回值就是整数数组，而关联类型 <code>Item</code> 也被推断出为 <code>Int</code>。<code>Container</code> 协议中的 <code>subscipt</code> 方法会返回 <code>Item</code>，这也意味着 <code>twelve</code> 的类型也被能推断出为 <code>Int</code>。</span>
</p>
        </div>
    </div>
    <!--mathjax-->
    <!--mermaid-->
</body>
</html>