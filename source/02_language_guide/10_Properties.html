
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="renderer" content="webkit">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/>
    <meta content="yes" name="apple-mobile-web-app-capable"/>
    <meta content="black" name="apple-mobile-web-app-status-bar-style"/>
    <meta content="telephone=no" name="format-detection"/>
    <meta name="renderer" content="webkit"/>
    <title>属性</title>
    <link rel="stylesheet" href="data:text/css;base64,CiAgICBoMSwgaDIsIGgzLCBoNSwgaDYsICBpbWcsIHN2ZywgcHJlLCB0YWJsZSwgdHJ7cGFnZS1icmVhay1pbnNpZGU6IGF2b2lkfQoKICAgIAogICAgLnBvc3R7CiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjsKICAgIH0KICAgIGJvZHkgewogICAgICAgIGJhY2tncm91bmQ6ICMxNzFEMjE7CiAgICAgICAgZm9udC1zaXplOiAxNHB4OwogICAgICAgIGxpbmUtaGVpZ2h0OjIuNDsKICAgICAgICBmb250LWZhbWlseTogIkhlbHZldGljYSBOZXVlIiwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmOwogICAgICAgIGZvbnQtd2VpZ2h0OiBub3JtYWw7CiAgICAgICAgY29sb3I6ICNBNUIwQzA7CiAgICAgICAgcGFkZGluZzogMCAzOHB4OwogICAgICAgIG1heC13aWR0aDogODIwcHg7CiAgICAgICAgbWFyZ2luOiAwIGF1dG87CgogICAgICAgIHdvcmQtd3JhcDpicmVhay13b3JkOwogICAgICAgIHdvcmQtYnJlYWs6IG5vcm1hbDsKICAgICAgICBvdmVyZmxvdy13cmFwOmJyZWFrLXdvcmQ7CiAgICAgICAgdGV4dC1hbGlnbjoganVzdGlmeTsKCgogICAgICAgIG92ZXJmbG93LXg6IGhpZGRlbjsKICAgICAgICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVMZWdpYmlsaXR5OwogICAgICAgIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogbm9uZTsKICAgIH0KCiAgICBicnsKICAgICAgICBsaW5lLWhlaWdodDogMi40OwogICAgfQoKCgogICAgQG1lZGlhIChtYXgtd2lkdGg6IDYwMHB4KSB7CiAgICAgICAgYm9keXsKICAgICAgICAgICAgcGFkZGluZzogMCAzMHB4OwogICAgICAgIH0KICAgIH0KCiAgICBAbWVkaWEgKG1heC13aWR0aDogNDgwcHgpIHsKICAgICAgICBib2R5ewogICAgICAgICAgICBwYWRkaW5nOiAwIDIwcHg7CiAgICAgICAgfQogICAgfQoKICAgIC5naXN0ewogICAgICAgIHdvcmQtYnJlYWs6IG5vcm1hbDsKICAgIH0KCiAgICAucG9zdHsKICAgICAgICBtYXJnaW4tdG9wOiAxMHB4OwogICAgICAgIG1hcmdpbi1ib3R0b206IDUwcHg7CiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlOwogICAgfQoKCgogICAgaW1newogICAgICAgIG1heC13aWR0aDogOTglOwogICAgICAgIG1hcmdpbjogMC44ZW0gYXV0byAwLjhlbSBhdXRvOwogICAgfQoKICAgIGgxIGltZywgaDIgaW1nLCBoMyBpbWcsIGg0IGltZywgaDUgaW1nLCBoNiBpbWd7CiAgICAgICAgbWFyZ2luOiBhdXRvOwogICAgfQoKICAgIC54Ml9pbWFnZXsKICAgICAgICB6b29tOiA1MCU7CiAgICB9CgogICAgLngzX2ltYWdlewogICAgICAgIHpvb206IDMzLjMzJTsKICAgIH0KCiAgICAueDRfaW1hZ2V7CiAgICAgICAgem9vbTogMjUlOwogICAgfQoKCiAgICBwIGltZ3sKICAgICAgICBtYXJnaW46IDAgYXV0bzsKICAgIH0KCiAgICBwewogICAgICAgIC8qb3ZlcmZsb3c6aGlkZGVuOyovCiAgICAgICAgbWFyZ2luOiAxLjBlbSAwIDEuOWVtIDA7CiAgICB9CgogICAgcC5tZF9ibG9ja19hc19vcGVuaW5newogICAgICAgIG1hcmdpbi1ib3R0b206IC0wLjVlbSAhaW1wb3J0YW50OwogICAgfQoKICAgIGxpIHB7CiAgICAgICAgbGluZS1oZWlnaHQ6IDIuMTY7CiAgICAgICAgbWFyZ2luOiAwOwogICAgfQoKICAgIC5wX3BhcnQgewogICAgICAgIG1hcmdpbjogMTBweCAwOwogICAgfQoKICAgIC5wX3BhcnQgcHsKICAgICAgICBtYXJnaW46IDAgMCAwLjZlbSAwOwogICAgfQoKICAgIC8qIHRleHQgaW5kZW50IGZvciBjaGluZXNlIHN0YXJ0cyovCiAgICAvKmgyLCBoMywgaDQsIGg1LCBoNiwgLnBfcGFydCBwLCAudG9kb19pdGVtLCBwewogICAgICAgIHRleHQtaW5kZW50OiAwcHg7CiAgICB9Ki8KICAgIHRhYmxlLCBwcmUsIHN2Z3sKICAgICAgICBtYXJnaW4tbGVmdDogMHB4OwogICAgICAgIG1hcmdpbi1yaWdodDogMHB4OwogICAgfQogICAgCiAgICBzcGFuIHN2Z3sKICAgICAgICBtYXJnaW4tbGVmdDogMDsKICAgICAgICBtYXJnaW4tcmlnaHQ6IDA7CiAgICB9CgogICAgLmxpbmVub2RpdiBwcmV7CiAgICAgICAgbWFyZ2luLWxlZnQ6IDA7CiAgICAgICAgbWFyZ2luLXJpZ2h0OiAwOwoKICAgIH0KICAgIAogICAgLmhpZ2hsaWdodCBwcmV7CiAgICAgICAgbWFyZ2luLWxlZnQ6IDA7CiAgICAgICAgbWFyZ2luLXJpZ2h0OiAwOwogICAgfQogICAgCiAgICAuaGlnaGxpZ2h0dGFibGUgLmNvZGUgeyBwb3NpdGlvbjogcmVsYXRpdmV9CiAgICAKICAgIC5oaWdobGlnaHR0YWJsZSBkaXYud2l0aF9saW5lc3sgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IHdpZHRoOiAxMDAlO30KICAgIAogICAgLmhpZ2hsaWdodHRhYmxlIGRpdi53aXRoX2xpbmVzIHByZXsKICAgICAgICBwYWRkaW5nLWxlZnQ6IDEwcHg7CiAgICB9CgoKCiAgICAvKiB0ZXh0IGluZGVudCBmb3IgY2hpbmVzZSBlbmRzKi8KCgogICAgYmxvY2txdW90ZSAucF9wYXJ0IHAsIGxpIC5wX3BhcnQgcHsKICAgICAgICB0ZXh0LWluZGVudDogMCAhaW1wb3J0YW50OwogICAgfQoKCiAgICBocnsKICAgICAgICBtYXJnaW46IDM4cHggMDsKICAgICAgICBib3JkZXI6IG5vbmU7CiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IGRhc2hlZCByZ2JhKDIwNSwgMjA1LCAyMDUsIDAuMzUpOwogICAgICAgIGNvbG9yOiByZ2JhKDIwNSwgMjA1LCAyMDUsIDAuMzUpOwogICAgICAgIGhlaWdodDogMXB4OwogICAgICAgIGxpbmUtaGVpZ2h0OjFweDsKICAgICAgICBmb250LXNpemU6MXB4OwogICAgICAgIG92ZXJmbG93LXk6IGhpZGRlbjsKICAgIH0KCgogICAgaDF7CiAgICAgICAgY29sb3I6ICNENUYwRjg7CiAgICAgICAgZm9udC1zaXplOiAxLjdlbTsKICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0OwogICAgICAgIG1hcmdpbjogMDsKICAgICAgICBwYWRkaW5nOiAwOwogICAgICAgIGxpbmUtaGVpZ2h0OiAxLjdlbTsKICAgICAgICBtYXJnaW4tdG9wOiAwLjhlbTsKICAgICAgICBtYXJnaW4tYm90dG9tOiAwLjZlbTsKICAgIH0KCiAgICBoMSwgaDIsIGgzLCBoNHsKICAgICAgICBjb2xvcjogI0Q1RjBGODsKICAgIH0KICAgIAogICAgaDF7Y29sb3I6I0Q1RjBGOH0KCgoKICAgIGgyLCBoM3sKICAgICAgICBsaW5lLWhlaWdodDogMS41ZW07CiAgICAgICAgbWFyZ2luLXRvcDogMS44ZW07CiAgICAgICAgbWFyZ2luLWJvdHRvbTogMC41ZW07CiAgICB9CgogICAgLmgxNi5tZF9maXJzdF9oLm1kX2ZpcnN0X3BhcnQgewogICAgICAgIG1hcmdpbi10b3A6IDVweDsKICAgIH0KICAgIAogICAgLnNwYW5fZm9yX2h7CiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7CiAgICB9CgoKICAgIGgyIHsKICAgICAgICBmb250LXNpemU6IDEuNWVtOwogICAgfQoKICAgIGgzIHsKICAgICAgICBmb250LXNpemU6IDEuMjVlbQogICAgfQoKICAgIGg0IHsKICAgICAgICBmb250LXNpemU6IDEuMTVlbTsKICAgIH0KCiAgICBoNSB7CiAgICAgICAgZm9udC1zaXplOiAxLjFlbTsKICAgIH0KCiAgICBoNiB7Zm9udC1zaXplOiAxZW19CgoKICAgIGgxLCBoMiwgaDMsIGg0LCBoNSwgaDZ7CiAgICAgICAgZm9udC1mYW1pbHk6ICJQaW5nRmFuZyBTQyI7CiAgICB9CgoKICAgIG9sIHsKICAgICAgICBtYXJnaW46IDA7CiAgICB9CgogICAgdWx7CiAgICAgICAgcGFkZGluZzogNXB4IDM4cHg7CiAgICAgICAgbWFyZ2luOiAwOwogICAgfQoKICAgIHVsIGxpLCBsaXsKICAgICAgICBwYWRkaW5nOiAwOwogICAgICAgIG1hcmdpbjogMDsKICAgIH0KCiAgICB1bCBwLCBvbCBwewogICAgICAgIG92ZXJmbG93OiB2aXNpYmxlOwogICAgfQoKCiAgICBibG9ja3F1b3RlIHsKICAgICAgICAtbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7CiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDsKICAgICAgICBtYXJnaW46IDEuNmVtIDA7CiAgICAgICAgcGFkZGluZzogMCAwIDAgMS4yZW07CiAgICAgICAgYm9yZGVyLWxlZnQ6IDRweCBzb2xpZCAjMkE4MUM1OwogICAgICAgIGNvbG9yOiAjOUE5QTlBOwogICAgICAgIG1pbi1oZWlnaHQ6MjBweDsKICAgIH0KCgogICAgYmxvY2txdW90ZSBwIHsKICAgICAgICBtYXJnaW46IDAuOGVtIDA7CiAgICB9CgogICAgYmxvY2txdW90ZSBzcGFuLm1kX2xpbmUgewogICAgICAgIG1hcmdpbi1ib3R0b206IDAuMjVlbTsKICAgICAgICBtYXJnaW4tdG9wOiAwLjI1ZW07CiAgICB9CgogICAgYmxvY2txdW90ZSB1bHsKICAgICAgICBwYWRkaW5nOiAwIDE1cHg7CiAgICB9CgogICAgYmxvY2txdW90ZSBzbWFsbCB7CiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrOwogICAgICAgIG1hcmdpbjogMC44ZW0gMCAwLjhlbSAxLjVlbTsKICAgICAgICBmb250LXNpemU6IDAuOWVtOwogICAgICAgIGNvbG9yOiAjY2NjOwogICAgfQoKCgoKCgogICAgdGFibGUgewogICAgICAgIGxpbmUtaGVpZ2h0OiAxLjc7CiAgICAgICAgLW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94OwogICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7CiAgICAgICAgbWFyZ2luOiAxZW0gMDsKICAgICAgICB3aWR0aDogMTAwJTsKICAgICAgICBtYXgtd2lkdGg6IDEwMCU7CiAgICAgICAgYm9yZGVyLXdpZHRoOiAxcHg7CiAgICAgICAgYm9yZGVyLXN0eWxlOiBzb2xpZDsKICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsKICAgICAgICBib3JkZXItc3BhY2luZzogMDsKICAgICAgICB3b3JkLWJyZWFrOiBub3JtYWw7CiAgICB9CiAgICAKICAgIC8qIGZvciB3ZWNoYXQgb25seSBzdGFydHMgKi8KICAgIHRhYmxlIHRyewogICAgICAgIGJvcmRlci1yaWdodC1zdHlsZTogc29saWQ7CiAgICAgICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAxcHg7CiAgICB9CiAgICAKICAgIHRhYmxlIHRib2R5ewogICAgICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDFweDsKICAgICAgICBib3JkZXItYm90dG9tLXN0eWxlOiBzb2xpZDsKICAgIH0KICAgIC8qIGZvciB3ZWNoYXQgb25seSBlbmRzICovCgoKICAgIHRhYmxlLCB0YWJsZSB0ciwgdGFibGUgdHIgdGQsIHRhYmxlIHRyIHRoLCB0YWJsZSB0Ym9keSB7CiAgICAgICAgYm9yZGVyLWNvbG9yOiByZ2JhKDIwNSwgMjA1LCAyMDUsIDAuMzUpOwogICAgfQoKICAgIHRhYmxlIHRoIHsKICAgICAgICBmb250LXdlaWdodDogYm9sZDsKICAgIH0KCiAgICB0ciB0aCB7CiAgICAgICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMXB4OwogICAgICAgIGJvcmRlci1ib3R0b20tc3R5bGU6IHNvbGlkOwogICAgICAgIHRleHQtYWxpZ246IGxlZnQ7CiAgICB9CgogICAgdHIgdGgsIHRyIHRkIHsKICAgICAgICBwYWRkaW5nOiAxMHB4IDIwcHg7CiAgICAgICAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQ7CiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYmEoMjA1LCAyMDUsIDIwNSwgMC4zNSk7CiAgICB9CgogICAgdGJvZHkgdHI6bGFzdC1jaGlsZCB0ZHsKICAgICAgICBib3JkZXItYm90dG9tOiAwOwogICAgfQoKICAgIHRyIHRoOmxhc3QtY2hpbGQsIHRyIHRkOmxhc3QtY2hpbGQgewogICAgICAgIGJvcmRlci1yaWdodDogMDsKICAgIH0KCiAgICB0YWJsZSB0Ym9keSA+IHRyOm50aC1jaGlsZChvZGQpID4gdGQsIHRhYmxlIHRib2R5ID4gdHI6bnRoLWNoaWxkKG9kZCkgPiB0aCB7CiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMzUsIDIzNSwgMjM1LCAwLjIpOwogICAgfQoKCgoKICAgIGNvZGV7CiAgICAgICAgYmFja2dyb3VuZDogcmdiYSgyMzUsIDIzNSwgMjM1LCAwLjM1KTsKICAgICAgICBjb2xvcjogIzc4RTI5MTsKICAgICAgICBwYWRkaW5nOiAwIDVweDsKICAgICAgICBtYXJnaW46IDAgMnB4OwogICAgfQoKICAgIHByZXsKICAgICAgICBtYXJnaW4tdG9wOiAxLjJlbTsKICAgICAgICBtYXJnaW4tYm90dG9tOiAxLjJlbTsKICAgICAgICBwYWRkaW5nOiAxNXB4IDEwcHg7CiAgICAgICAgZGlzcGxheTogYmxvY2s7CiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgyMDUsIDIwNSwgMjA1LCAwLjM1KTsKICAgICAgICAvKmJhY2tncm91bmQ6IHJnYmEoMjM1LCAyMzUsIDIzNSwgMC4zNSk7Ki8KICAgICAgICBmb250LXNpemU6IDkwJTsKICAgICAgICBsaW5lLWhlaWdodDoyLjQ7CiAgICAgICAgd2hpdGUtc3BhY2U6IHByZS13cmFwOwogICAgICAgIG92ZXJmbG93LXk6IGhpZGRlbjsKICAgICAgICBvdmVyZmxvdy14OiBhdXRvOwogICAgICAgIHdvcmQtd3JhcDogbm9ybWFsOwogICAgfQogICAgCiAgICAuY29kZWhpbGl0ZSBwcmV7CiAgICAgICAgd2hpdGUtc3BhY2U6IHByZTsKICAgIH0KCiAgICAuaGlnaGxpZ2h0dGFibGUgdGR7CiAgICAgICAgLypiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIzNSwgMjM1LCAyMzUsIDAuMzUpICFpbXBvcnRhbnQ7Ki8KICAgIH0KCiAgICAud2l0aF9saW5lcyBwcmV7CiAgICAgICAgYm9yZGVyOm5vbmU7CiAgICAgICAgbWFyZ2luLXRvcDogMC4yZW07CiAgICAgICAgbWFyZ2luLWJvdHRvbTogMC4yZW07CiAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7CiAgICB9CgogICAgLmlzX2NvZGVfZmlsZSBwcmV7CiAgICAgICAgYm9yZGVyOiBub25lOwogICAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50OwogICAgfQoKICAgIC5jb2RlaGlsaXRlIHByZXsKICAgICAgICAvKndvcmQtd3JhcDogbm9ybWFsOyovCiAgICAgICAgZm9udC1zaXplOiAxM3B4OwogICAgfQoKICAgIHByZSBjb2RlewogICAgICAgIGJvcmRlcjpub25lOwogICAgICAgIGJhY2tncm91bmQ6IG5vbmU7CiAgICAgICAgcGFkZGluZzogMDsKICAgICAgICBtYXJnaW46IDA7CiAgICB9CgogICAgcHJlIHB7CiAgICAgICAgbWFyZ2luOiAwOwogICAgICAgIHBhZGRpbmc6IDA7CiAgICB9CgogICAgLmNvZGVoaWxpdGUgdGgsIC5jb2RlaGlsaXRlIHRkewogICAgICAgIGxpbmUtaGVpZ2h0OiAxLjhlbTsKICAgIH0KCgogICAgYXsKICAgICAgICBjb2xvcjogIzc3Qjg3RjsKICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7CiAgICAgICAgLy9ib3JkZXItYm90dG9tOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7CiAgICB9CgogICAgYTpob3ZlcnsKICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTsKICAgICAgICAvL2JvcmRlci1ib3R0b206IDFweCBzb2xpZCAjNzdCODdGOwogICAgfQoKICAgIHN0cm9uZyB7CiAgICAgICAgY29sb3I6ICNGRkZGRkY7CiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7CiAgICB9CgoKICAgIC8qIGZvciBtYXJrZG93biAqLwoKICAgIC5saW5lbm9zIHByZXsKCQliYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDsKCQlib3JkZXI6IG5vbmU7Cgl9CgoJLmxpbmVub3N7CgkgICAgcGFkZGluZzogMCA1cHggMCA1cHg7CgkgICAgd2lkdGg6IDAuMDAxJTsKCX0KCgkuaGlnaGxpZ2h0dGFibGUgIC5saW5lbm9zIHByZXsKCSAgICBwYWRkaW5nOiA1cHggMTBweDsKCX0KCQoJLmhpZ2hsaWdodHRhYmxlICAuY29kZSBwcmV7CgkgICAgcGFkZGluZzogMDsKCX0KCiAgICAudG9jewogICAgICAgIGJhY2tncm91bmQ6IE5vbmU7CiAgICAgICAgYm9yZGVyLXJhZGl1czogNXB4OwogICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIE5vbmU7CiAgICAgICAgbWFyZ2luOiAyN3B4IDAgNDdweCAwOwogICAgICAgIHBhZGRpbmc6IDEwcHggMDsKICAgIH0KCiAgICAudG9jIHVsewogICAgICAgIC8vcGFkZGluZzogNXB4IDQycHg7CiAgICB9CgogICAgLnRvYyB1bCBsaXsKICAgICAgICBwYWRkaW5nOiAwOwogICAgICAgIG1hcmdpbjogMDsKICAgIH0KICAgIC50b2MgYXsKICAgICAgICBjb2xvcjogI0E1QjBDMDsKICAgIH0KCgoKICAgIC50b2RvX2l0ZW17CiAgICAgICAgbGlzdC1zdHlsZTogbm9uZTsKICAgICAgICBtYXJnaW4tbGVmdDogLTEuNWVtCiAgICB9CiAgICAudG9kb19pdGVtIC50b2RvX2l0ZW0gewogICAgICAgIG1hcmdpbi1sZWZ0OiBhdXRvOwogICAgfQoKICAgIC50b2RvX2RvbmVfaXRlbXsKICAgICAgICBjb2xvcjogIzU1NTU1NTsKICAgIH0KCiAgICAudG9kb191bmRvbmVfaXRlbXsKICAgICAgICBjb2xvcjogI0RERERERDsKICAgIH0KCgogICAgdWwgbGkudG9kb19pdGVtewoJbGlzdC1zdHlsZS10eXBlOiBub25lOwogICAgfQoKICAgIHVsIGxpLnRvZG9faXRlbTpiZWZvcmV7CiAgICAgICAgY29udGVudDogJ+KYkCc7CiAgICAgICAgLypwYWRkaW5nLXJpZ2h0OiAwLjJlbTsqLwogICAgICAgIGZvbnQtZmFtaWx5OiBhcmlhbDsKICAgIH0KCiAgICB1bCBsaS50b2RvX2RvbmVfaXRlbTpiZWZvcmV7CiAgICAgICAgY29udGVudDogJ+KYkSc7CiAgICAgICAgLypwYWRkaW5nLXJpZ2h0OiAwLjJlbTsqLwogICAgICAgIGZvbnQtZmFtaWx5OiBhcmlhbDsKICAgIH0KCiAgICB1bCBsaS50b2RvX2l0ZW0gaW5wdXR7CiAgICAgICAgZGlzcGxheTpub25lCiAgICB9CgoKICAgIC8qcHlnbWVudHMqLwoKICAgIC5jb2RlaGlsaXRlewogICAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7CiAgICB9CgogICAgLyp0YWJsZS5oaWdobGlnaHR0YWJsZXsgYm9yZGVyOm5vbmU7IH0KICAgIC5oaWdobGlnaHR0YWJsZSB0ZHsgYm9yZGVyOiBub25lOyBwYWRkaW5nOiAwO30qLwoKICAgIC5mbG93LWdyYXBoaWMsIC5tZF9ibG9ja19zZWN0aW9uX2Zvcl9mbG93X2dyYXBoaWN7dGV4dC1hbGlnbjogY2VudGVyfQogICAgLmZsb3ctZ3JhcGhpYyB7IG92ZXJmbG93LXg6IGF1dG87fQogICAgLm1lcm1haWQsIC5tZF9ibG9ja19zZWN0aW9uX2Zvcl9tZXJtYWlke3RleHQtYWxpZ246IGNlbnRlcn0KICAgIAogICAgLmZsb3ctZ3JhcGhpYywgLm1lcm1haWR7CiAgICAgICAgYmFja2dyb3VuZDogI2ZmZmZmZjsKICAgIH0KCgogICAgdGFibGUsIHRyLCB0ZCwgdGgsIHRib2R5LCB0aGVhZCwgdGZvb3QsIC5tZF9lY2hhcnRzLCBibG9ja3F1b3RlIC5tZF9saW5lewogICAgICAgIHBhZ2UtYnJlYWstaW5zaWRlOiBhdm9pZCAhaW1wb3J0YW50OwogICAgfQoKICAgIC5mb290bm90ZXMgLm1kX2xpbmV7CiAgICAgICAgZGlzcGxheTogaW5saW5lICFpbXBvcnRhbnQ7CiAgICB9CgoKICAgIC5pbWdfcnRfOTB7CiAgICAgICAgdHJhbnNmb3JtOnJvdGF0ZSg5MGRlZyk7CiAgICAgICAgLW1zLXRyYW5zZm9ybTpyb3RhdGUoOTBkZWcpOwogICAgICAgIC1tb3otdHJhbnNmb3JtOnJvdGF0ZSg5MGRlZyk7CiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDkwZGVnKTsKICAgICAgICAtby10cmFuc2Zvcm06cm90YXRlKDkwZGVnKTsKICAgIH0KICAgIC5pbWdfcnRfMTgwewogICAgICAgIHRyYW5zZm9ybTpyb3RhdGUoMTgwZGVnKTsKICAgICAgICAtbXMtdHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpOwogICAgICAgIC1tb3otdHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpOwogICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpOwogICAgICAgIC1vLXRyYW5zZm9ybTpyb3RhdGUoMTgwZGVnKTsKICAgIH0KICAgIC5pbWdfcnRfMjcwewogICAgICAgIHRyYW5zZm9ybTpyb3RhdGUoMjcwZGVnKTsKICAgICAgICAtbXMtdHJhbnNmb3JtOnJvdGF0ZSgyNzBkZWcpOwogICAgICAgIC1tb3otdHJhbnNmb3JtOnJvdGF0ZSgyNzBkZWcpOwogICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgyNzBkZWcpOwogICAgICAgIC1vLXRyYW5zZm9ybTpyb3RhdGUoMjcwZGVnKTsKICAgIH0KCiAgICAubWRfaGFzX2Jsb2NrX2JlbG93ewogICAgICAgIG1hcmdpbi1ib3R0b206IDAuMWVtICFpbXBvcnRhbnQ7CiAgICB9CiAgICAubWRfaGFzX2Jsb2NrX2JlbG93X2ltZ3sKICAgICAgICBtYXJnaW4tYm90dG9tOiAtMC42ZW0gIWltcG9ydGFudDsKICAgIH0KCgogICAgLmNvZGVoaWxpdGUgLmVycnsKICAgICAgICBib3JkZXI6IG5vbmUgIWltcG9ydGFudDsKICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50OwogICAgfQoKCgogICAgICAgIHNwYW4ubWRfbGluZXttYXJnaW4tYm90dG9tOjAuNWVtOyBkaXNwbGF5OmJsb2NrOyBsaW5lLWhlaWdodDoyLjF9CiAgICAgICAgLm1kX2xpbmUgYnJ7IGRpc3BsYXk6IG5vbmU7fQogICAgICAgIC5jb2RlaGlsaXRlIC5obGwgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmZmNjIH0KLmNvZGVoaWxpdGUgIHsgYmFja2dyb3VuZDogI2ZmZmZmZjsgfQouY29kZWhpbGl0ZSAuYyB7IGNvbG9yOiAjMTc3NTAwIH0gLyogQ29tbWVudCAqLwouY29kZWhpbGl0ZSAuZXJyIHsgY29sb3I6ICMwMDAwMDAgfSAvKiBFcnJvciAqLwouY29kZWhpbGl0ZSAuayB7IGNvbG9yOiAjQTkwRDkxIH0gLyogS2V5d29yZCAqLwouY29kZWhpbGl0ZSAubCB7IGNvbG9yOiAjMUMwMUNFIH0gLyogTGl0ZXJhbCAqLwouY29kZWhpbGl0ZSAubiB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZSAqLwouY29kZWhpbGl0ZSAubyB7IGNvbG9yOiAjMDAwMDAwIH0gLyogT3BlcmF0b3IgKi8KLmNvZGVoaWxpdGUgLmNoIHsgY29sb3I6ICMxNzc1MDAgfSAvKiBDb21tZW50Lkhhc2hiYW5nICovCi5jb2RlaGlsaXRlIC5jbSB7IGNvbG9yOiAjMTc3NTAwIH0gLyogQ29tbWVudC5NdWx0aWxpbmUgKi8KLmNvZGVoaWxpdGUgLmNwIHsgY29sb3I6ICM2MzM4MjAgfSAvKiBDb21tZW50LlByZXByb2MgKi8KLmNvZGVoaWxpdGUgLmNwZiB7IGNvbG9yOiAjMTc3NTAwIH0gLyogQ29tbWVudC5QcmVwcm9jRmlsZSAqLwouY29kZWhpbGl0ZSAuYzEgeyBjb2xvcjogIzE3NzUwMCB9IC8qIENvbW1lbnQuU2luZ2xlICovCi5jb2RlaGlsaXRlIC5jcyB7IGNvbG9yOiAjMTc3NTAwIH0gLyogQ29tbWVudC5TcGVjaWFsICovCi5jb2RlaGlsaXRlIC5rYyB7IGNvbG9yOiAjQTkwRDkxIH0gLyogS2V5d29yZC5Db25zdGFudCAqLwouY29kZWhpbGl0ZSAua2QgeyBjb2xvcjogI0E5MEQ5MSB9IC8qIEtleXdvcmQuRGVjbGFyYXRpb24gKi8KLmNvZGVoaWxpdGUgLmtuIHsgY29sb3I6ICNBOTBEOTEgfSAvKiBLZXl3b3JkLk5hbWVzcGFjZSAqLwouY29kZWhpbGl0ZSAua3AgeyBjb2xvcjogI0E5MEQ5MSB9IC8qIEtleXdvcmQuUHNldWRvICovCi5jb2RlaGlsaXRlIC5rciB7IGNvbG9yOiAjQTkwRDkxIH0gLyogS2V5d29yZC5SZXNlcnZlZCAqLwouY29kZWhpbGl0ZSAua3QgeyBjb2xvcjogI0E5MEQ5MSB9IC8qIEtleXdvcmQuVHlwZSAqLwouY29kZWhpbGl0ZSAubGQgeyBjb2xvcjogIzFDMDFDRSB9IC8qIExpdGVyYWwuRGF0ZSAqLwouY29kZWhpbGl0ZSAubSB7IGNvbG9yOiAjMUMwMUNFIH0gLyogTGl0ZXJhbC5OdW1iZXIgKi8KLmNvZGVoaWxpdGUgLnMgeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nICovCi5jb2RlaGlsaXRlIC5uYSB7IGNvbG9yOiAjODM2QzI4IH0gLyogTmFtZS5BdHRyaWJ1dGUgKi8KLmNvZGVoaWxpdGUgLm5iIHsgY29sb3I6ICNBOTBEOTEgfSAvKiBOYW1lLkJ1aWx0aW4gKi8KLmNvZGVoaWxpdGUgLm5jIHsgY29sb3I6ICMzRjZFNzUgfSAvKiBOYW1lLkNsYXNzICovCi5jb2RlaGlsaXRlIC5ubyB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZS5Db25zdGFudCAqLwouY29kZWhpbGl0ZSAubmQgeyBjb2xvcjogIzAwMDAwMCB9IC8qIE5hbWUuRGVjb3JhdG9yICovCi5jb2RlaGlsaXRlIC5uaSB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZS5FbnRpdHkgKi8KLmNvZGVoaWxpdGUgLm5lIHsgY29sb3I6ICMwMDAwMDAgfSAvKiBOYW1lLkV4Y2VwdGlvbiAqLwouY29kZWhpbGl0ZSAubmYgeyBjb2xvcjogIzAwMDAwMCB9IC8qIE5hbWUuRnVuY3Rpb24gKi8KLmNvZGVoaWxpdGUgLm5sIHsgY29sb3I6ICMwMDAwMDAgfSAvKiBOYW1lLkxhYmVsICovCi5jb2RlaGlsaXRlIC5ubiB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZS5OYW1lc3BhY2UgKi8KLmNvZGVoaWxpdGUgLm54IHsgY29sb3I6ICMwMDAwMDAgfSAvKiBOYW1lLk90aGVyICovCi5jb2RlaGlsaXRlIC5weSB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZS5Qcm9wZXJ0eSAqLwouY29kZWhpbGl0ZSAubnQgeyBjb2xvcjogIzAwMDAwMCB9IC8qIE5hbWUuVGFnICovCi5jb2RlaGlsaXRlIC5udiB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZS5WYXJpYWJsZSAqLwouY29kZWhpbGl0ZSAub3cgeyBjb2xvcjogIzAwMDAwMCB9IC8qIE9wZXJhdG9yLldvcmQgKi8KLmNvZGVoaWxpdGUgLm1iIHsgY29sb3I6ICMxQzAxQ0UgfSAvKiBMaXRlcmFsLk51bWJlci5CaW4gKi8KLmNvZGVoaWxpdGUgLm1mIHsgY29sb3I6ICMxQzAxQ0UgfSAvKiBMaXRlcmFsLk51bWJlci5GbG9hdCAqLwouY29kZWhpbGl0ZSAubWggeyBjb2xvcjogIzFDMDFDRSB9IC8qIExpdGVyYWwuTnVtYmVyLkhleCAqLwouY29kZWhpbGl0ZSAubWkgeyBjb2xvcjogIzFDMDFDRSB9IC8qIExpdGVyYWwuTnVtYmVyLkludGVnZXIgKi8KLmNvZGVoaWxpdGUgLm1vIHsgY29sb3I6ICMxQzAxQ0UgfSAvKiBMaXRlcmFsLk51bWJlci5PY3QgKi8KLmNvZGVoaWxpdGUgLnNhIHsgY29sb3I6ICNDNDFBMTYgfSAvKiBMaXRlcmFsLlN0cmluZy5BZmZpeCAqLwouY29kZWhpbGl0ZSAuc2IgeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLkJhY2t0aWNrICovCi5jb2RlaGlsaXRlIC5zYyB7IGNvbG9yOiAjMjMwMENFIH0gLyogTGl0ZXJhbC5TdHJpbmcuQ2hhciAqLwouY29kZWhpbGl0ZSAuZGwgeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLkRlbGltaXRlciAqLwouY29kZWhpbGl0ZSAuc2QgeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLkRvYyAqLwouY29kZWhpbGl0ZSAuczIgeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLkRvdWJsZSAqLwouY29kZWhpbGl0ZSAuc2UgeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLkVzY2FwZSAqLwouY29kZWhpbGl0ZSAuc2ggeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLkhlcmVkb2MgKi8KLmNvZGVoaWxpdGUgLnNpIHsgY29sb3I6ICNDNDFBMTYgfSAvKiBMaXRlcmFsLlN0cmluZy5JbnRlcnBvbCAqLwouY29kZWhpbGl0ZSAuc3ggeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLk90aGVyICovCi5jb2RlaGlsaXRlIC5zciB7IGNvbG9yOiAjQzQxQTE2IH0gLyogTGl0ZXJhbC5TdHJpbmcuUmVnZXggKi8KLmNvZGVoaWxpdGUgLnMxIHsgY29sb3I6ICNDNDFBMTYgfSAvKiBMaXRlcmFsLlN0cmluZy5TaW5nbGUgKi8KLmNvZGVoaWxpdGUgLnNzIHsgY29sb3I6ICNDNDFBMTYgfSAvKiBMaXRlcmFsLlN0cmluZy5TeW1ib2wgKi8KLmNvZGVoaWxpdGUgLmJwIHsgY29sb3I6ICM1QjI2OUEgfSAvKiBOYW1lLkJ1aWx0aW4uUHNldWRvICovCi5jb2RlaGlsaXRlIC5mbSB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZS5GdW5jdGlvbi5NYWdpYyAqLwouY29kZWhpbGl0ZSAudmMgeyBjb2xvcjogIzAwMDAwMCB9IC8qIE5hbWUuVmFyaWFibGUuQ2xhc3MgKi8KLmNvZGVoaWxpdGUgLnZnIHsgY29sb3I6ICMwMDAwMDAgfSAvKiBOYW1lLlZhcmlhYmxlLkdsb2JhbCAqLwouY29kZWhpbGl0ZSAudmkgeyBjb2xvcjogIzAwMDAwMCB9IC8qIE5hbWUuVmFyaWFibGUuSW5zdGFuY2UgKi8KLmNvZGVoaWxpdGUgLnZtIHsgY29sb3I6ICMwMDAwMDAgfSAvKiBOYW1lLlZhcmlhYmxlLk1hZ2ljICovCi5jb2RlaGlsaXRlIC5pbCB7IGNvbG9yOiAjMUMwMUNFIH0gLyogTGl0ZXJhbC5OdW1iZXIuSW50ZWdlci5Mb25nICovCiAgICAvKiBwYWdlX2NzcyAqLwoKICAgIAogICAgaHRtbHsKICAgICAgICBiYWNrZ3JvdW5kOiAjMTAxNjFBOwogICAgfQogICAgYm9keXsKICAgICAgICB3aWR0aDogOTAlOwogICAgICAgIG1heC13aWR0aDogOTYwcHg7CiAgICAgICAgYmFja2dyb3VuZDogIzE3MUQyMTsKICAgICAgICBtYXJnaW46IDNlbSBhdXRvIDA7CiAgICAgICAgcGFkZGluZy10b3A6IDJlbTsKICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjMTAxNjFBOwogICAgICAgIGJvcmRlci13aWR0aDogMCAxcHg7CiAgICB9CgogICAgLnBvc3R7CiAgICAgICAgcGFkZGluZzogNSUgMTAlOwogICAgICAgIG1hcmdpbi10b3A6IDA7CiAgICAgICAgbWFyZ2luLWJvdHRvbTogMDsKICAgIH0KICAgIAoKICAgIC50aXRsZV9jb250YWluZXJ7CiAgICAgICAgbWFyZ2luOiAtMmVtIDAgMy41ZW07CiAgICAgICAgcGFkZGluZy1ib3R0b206IDJlbTsKICAgICAgICBib3JkZXItYm90dG9tOiAzcHggZG91YmxlICMxMDE2MUE7CiAgICB9CiAgICAudGl0bGVfY29udGFpbmVyIGgxewogICAgICAgIG1hcmdpbi10b3A6IDEuMmVtOwogICAgICAgIG1hcmdpbi1ib3R0b206IDAuNmVtOwogICAgICAgIGxpbmUtaGVpZ2h0OiAxLjM1OwogICAgICAgIGZvbnQtc2l6ZTogMi4yNWVtOwogICAgfQogICAgLnRpdGxlX2NvbnRhaW5lciBoMnsKICAgICAgICBjb2xvcjogIzlBOUE5QTsKICAgICAgICBmb250LXNpemU6IDFlbTsKICAgICAgICBmb250LXdlaWdodDogbm9ybWFsOwogICAgICAgIHBhZGRpbmctYm90dG9tOiAyZW07CiAgICAgICAgbGluZS1oZWlnaHQ6IDEuMzU7CiAgICAgICAgbWFyZ2luLWJvdHRvbTogLTJlbTsKICAgIH0KCiAgICBAbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDc2MHB4KXsKICAgICAgICBodG1sewogICAgICAgICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDsKICAgICAgICB9CiAgICAgICAgYm9keXsKICAgICAgICAgICAgbWFyZ2luOiAwOwogICAgICAgIH0KICAgICAgICAucG9zdHsKICAgICAgICAgICAgcGFkZGluZzogMDsKICAgICAgICB9CiAgICB9CiAgICAvKiBwYWdlX2NzcyAqLwoKICAgIA==">
    <!--header_scripts-->
</head>
<body>
    <div class="post">
        <div class="post_body">
            
            <h1 id="toc_0" class="h16 md_first_h"><span class="span_for_h">属性</span></h1>

<p class="md_block">
    <span class="md_line md_line_start md_line_end"><em>属性</em>将值与特定的类、结构体或枚举关联。存储属性会将常量和变量存储为实例的一部分，而计算属性则是直接计算（而不是存储）值。计算属性可以用于类、结构体和枚举，而存储属性只能用于类和结构体。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">存储属性和计算属性通常与特定类型的实例关联。但是，属性也可以直接与类型本身关联，这种属性称为类型属性。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">另外，还可以定义属性观察器来监控属性值的变化，以此来触发自定义的操作。属性观察器可以添加到类本身定义的存储属性上，也可以添加到从父类继承的属性上。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">你也可以利用属性包装器来复用多个属性的 getter 和 setter 中的代码。</span>
</p>

<h2 id="toc_1" class="h16"><span class="span_for_h">存储属性 {#stored-properties}</span></h2>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">简单来说，一个存储属性就是存储在特定类或结构体实例里的一个常量或变量。存储属性可以是*变量存储属性*（用关键字 <code>var</code> 定义），也可以是*常量存储属性*（用关键字 <code>let</code> 定义）。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">可以在定义存储属性的时候指定默认值，请参考 <a class="md_compiled" href="./14_Initialization.md#default-initializers">默认构造器</a> 一节。也可以在构造过程中设置或修改存储属性的值，甚至修改常量存储属性的值，请参考 <a class="md_compiled" href="./14-Initialization.md#assigning-constant-properties-during-initialization">构造过程中常量属性的修改</a> 一节。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">下面的例子定义了一个名为 <code>FixedLengthRange</code> 的结构体，该结构体用于描述整数的区间，且这个范围值在被创建后不能被修改。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">FixedLengthRange</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">firstValue</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">let</span> <span class="nv">length</span><span class="p">:</span> <span class="nb">Int</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nv">rangeOfThreeItems</span> <span class="p">=</span> <span class="n">FixedLengthRange</span><span class="p">(</span><span class="n">firstValue</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">// 该区间表示整数 0，1，2</span>
<span class="n">rangeOfThreeItems</span><span class="p">.</span><span class="n">firstValue</span> <span class="p">=</span> <span class="mi">6</span>
<span class="c1">// 该区间现在表示整数 6，7，8</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end"><code>FixedLengthRange</code> 的实例包含一个名为 <code>firstValue</code> 的变量存储属性和一个名为 <code>length</code> 的常量存储属性。在上面的例子中，<code>length</code> 在创建实例的时候被初始化，且之后无法修改它的值，因为它是一个常量存储属性。</span>
</p>

<h3 id="toc_2" class="h16"><span class="span_for_h">常量结构体实例的存储属性 {#stored-properties-of-constant-structure-instances}</span></h3>

<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">如果创建了一个结构体实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使被声明为可变属性也不行:</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">let</span> <span class="nv">rangeOfFourItems</span> <span class="p">=</span> <span class="n">FixedLengthRange</span><span class="p">(</span><span class="n">firstValue</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">:</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1">// 该区间表示整数 0，1，2，3</span>
<span class="n">rangeOfFourItems</span><span class="p">.</span><span class="n">firstValue</span> <span class="p">=</span> <span class="mi">6</span>
<span class="c1">// 尽管 firstValue 是个可变属性，但这里还是会报错</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">因为 <code>rangeOfFourItems</code> 被声明成了常量（用 <code>let</code> 关键字），所以即使 <code>firstValue</code> 是一个可变属性，也无法再修改它了。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">这种行为是由于结构体属于<em class="md_patched_em">值类型</em>。当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">属于<em class="md_patched_em">引用类型</em>的类则不一样。把一个引用类型的实例赋给一个常量后，依然可以修改该实例的可变属性。</span>
</p>

<h3 id="toc_3" class="h16"><span class="span_for_h">延时加载存储属性 {#lazy-stored-properties}</span></h3>

<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end"><em>延时加载存储属性</em>是指当第一次被调用的时候才会计算其初始值的属性。在属性声明前使用 <code>lazy</code> 来标示一个延时加载存储属性。</span>
</p>


<blockquote class="blockquote_lines_3 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">注意<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line md_line_end">必须将延时加载属性声明成变量（使用 <code>var</code> 关键字），因为属性的初始值可能在实例构造完成之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延时加载。</span>
</p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">当属性的值依赖于一些外部因素且这些外部因素只有在构造过程结束之后才会知道的时候，延时加载属性就会很有用。或者当获得属性的值因为需要复杂或者大量的计算，而需要采用需要的时候再计算的方式，延时加载属性也会很有用。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">下面的例子使用了延时加载存储属性来避免复杂类中不必要的初始化工作。例子中定义了 <code>DataImporter</code> 和 <code>DataManager</code> 两个类，下面是部分代码：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">class</span> <span class="nc">DataImporter</span> <span class="p">{</span>
    <span class="cm">/*</span>
<span class="cm">    DataImporter 是一个负责将外部文件中的数据导入的类。</span>
<span class="cm">    这个类的初始化会消耗不少时间。</span>
<span class="cm">    */</span>
    <span class="kd">var</span> <span class="nv">fileName</span> <span class="p">=</span> <span class="s">&quot;data.txt&quot;</span>
    <span class="c1">// 这里会提供数据导入功能</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">DataManager</span> <span class="p">{</span>
    <span class="kr">lazy</span> <span class="kd">var</span> <span class="nv">importer</span> <span class="p">=</span> <span class="n">DataImporter</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nv">data</span> <span class="p">=</span> <span class="p">[</span><span class="nb">String</span><span class="p">]()</span>
    <span class="c1">// 这里会提供数据管理功能</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">manager</span> <span class="p">=</span> <span class="n">DataManager</span><span class="p">()</span>
<span class="n">manager</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Some data&quot;</span><span class="p">)</span>
<span class="n">manager</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Some more data&quot;</span><span class="p">)</span>
<span class="c1">// DataImporter 实例的 importer 属性还没有被创建</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end"><code>DataManager</code> 类包含一个名为 <code>data</code> 的存储属性，初始值是一个空的字符串数组。这里没有给出全部代码，只需知道 <code>DataManager</code> 类的目的是管理和提供对这个字符串数组的访问即可。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end"><code>DataManager</code> 的一个功能是从文件中导入数据。这个功能由 <code>DataImporter</code> 类提供，<code>DataImporter</code> 完成初始化需要消耗不少时间：因为它的实例在初始化时可能需要打开文件并读取文件中的内容到内存中。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end"><code>DataManager</code> 管理数据时也可能不从文件中导入数据。所以当 <code>DataManager</code> 的实例被创建时，没必要创建一个 <code>DataImporter</code> 的实例，更明智的做法是第一次用到 <code>DataImporter</code> 的时候才去创建它。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">由于使用了 <code>lazy</code>，<code>DataImporter</code> 的实例 <code>importer</code> 属性只有在第一次被访问的时候才被创建。比如访问它的属性 <code>fileName</code> 时：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="bp">print</span><span class="p">(</span><span class="n">manager</span><span class="p">.</span><span class="n">importer</span><span class="p">.</span><span class="n">fileName</span><span class="p">)</span>
<span class="c1">// DataImporter 实例的 importer 属性现在被创建了</span>
<span class="c1">// 输出“data.txt”</span>
</pre></div>

<!--block_code_end-->
<blockquote class="blockquote_lines_3 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">注意<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line md_line_end">如果一个被标记为 <code>lazy</code> 的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次。</span>
</p>

</blockquote>
<h3 id="toc_4" class="h16"><span class="span_for_h">存储属性和实例变量 {#stored-properties-and-instance-variables}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">如果您有过 Objective-C 经验，应该知道 Objective-C 为类实例存储值和引用提供两种方法。除了属性之外，还可以使用实例变量作为一个备份存储将变量值赋值给属性。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">Swift 编程语言中把这些理论统一用属性来实现。Swift 中的属性没有对应的实例变量，属性的备份存储也无法直接访问。这就避免了不同场景下访问方式的困扰，同时也将属性的定义简化成一个语句。属性的全部信息——包括命名、类型和内存管理特征——作为类型定义的一部分，都定义在一个地方。</span>
</p>

<h2 id="toc_5" class="h16"><span class="span_for_h">计算属性 {#computed-properties}</span></h2>

<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">除存储属性外，类、结构体和枚举可以定义<em class="md_patched_em">计算属性</em>。计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="p">=</span> <span class="mf">0.0</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="nc">Size</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">width</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">height</span> <span class="p">=</span> <span class="mf">0.0</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="nc">Rect</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">origin</span> <span class="p">=</span> <span class="n">Point</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nv">size</span> <span class="p">=</span> <span class="n">Size</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nv">center</span><span class="p">:</span> <span class="n">Point</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nv">centerX</span> <span class="p">=</span> <span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="kd">let</span> <span class="nv">centerY</span> <span class="p">=</span> <span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">centerX</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">centerY</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="kr">set</span><span class="p">(</span><span class="n">newCenter</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">newCenter</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">newCenter</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nv">square</span> <span class="p">=</span> <span class="n">Rect</span><span class="p">(</span><span class="n">origin</span><span class="p">:</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">),</span>
    <span class="n">size</span><span class="p">:</span> <span class="n">Size</span><span class="p">(</span><span class="n">width</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">))</span>
<span class="kd">let</span> <span class="nv">initialSquareCenter</span> <span class="p">=</span> <span class="n">square</span><span class="p">.</span><span class="n">center</span>
<span class="n">square</span><span class="p">.</span><span class="n">center</span> <span class="p">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">15.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">15.0</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;square.origin is now at (</span><span class="si">\(</span><span class="n">square</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span><span class="si">)</span><span class="s">, </span><span class="si">\(</span><span class="n">square</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span><span class="si">)</span><span class="s">)&quot;</span><span class="p">)</span>
<span class="c1">// 打印“square.origin is now at (10.0, 10.0)”</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_ul">
    <span class="md_line md_line_start md_line_end">这个例子定义了 3 个结构体来描述几何形状：</span>
</p>


<ul>
<li class="md_li"><span><code>Point</code> 封装了一个 <code>(x, y)</code> 的坐标

</span></li>
<li class="md_li"><span><code>Size</code> 封装了一个 <code>width</code> 和一个 <code>height</code></span></li>
<li class="md_li"><span><code>Rect</code> 表示一个有原点和尺寸的矩形

</span></li>
</ul>

<p class="md_block">
    <span class="md_line md_line_start md_line_end"><code>Rect</code> 也提供了一个名为 <code>center</code> 的计算属性。一个 <code>Rect</code> 的中心点可以从 <code>origin</code>（原点）和 <code>size</code>（大小）算出，所以不需要将中心点以 <code>Point</code> 类型的值来保存。<code>Rect</code> 的计算属性 <code>center</code> 提供了自定义的 getter 和 setter 来获取和设置矩形的中心点，就像它有一个存储属性一样。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">上述例子中创建了一个名为 <code>square</code> 的 <code>Rect</code> 实例，初始值原点是 <code>(0, 0)</code>，宽度高度都是 <code>10</code>。如下图中蓝色正方形所示。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end"><code>square</code> 的 <code>center</code> 属性可以通过点运算符（<code>square.center</code>）来访问，这会调用该属性的 getter 来获取它的值。跟直接返回已经存在的值不同，getter 实际上通过计算然后返回一个新的 <code>Point</code> 来表示 <code>square</code> 的中心点。如代码所示，它正确返回了中心点 <code>(5, 5)</code>。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end"><code>center</code> 属性之后被设置了一个新的值 <code>(15, 15)</code>，表示向右上方移动正方形到如下图橙色正方形所示的位置。设置属性 <code>center</code> 的值会调用它的 setter 来修改属性 <code>origin</code> 的 <code>x</code> 和 <code>y</code> 的值，从而实现移动正方形到新的位置。</span>
</p>

<p class="md_compiled md_paragraph_html"><img src="https://docs.swift.org/swift-book/_images/computedProperties_2x.png" alt="Computed Properties sample" width="388" height="387" /></p><h3 id="toc_6" class="h16"><span class="span_for_h">简化 Setter 声明 {#shorthand-setter-declaration}</span></h3>

<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称 <code>newValue</code>。下面是使用了简化 setter 声明的 <code>Rect</code> 结构体代码：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">AlternativeRect</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">origin</span> <span class="p">=</span> <span class="n">Point</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nv">size</span> <span class="p">=</span> <span class="n">Size</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nv">center</span><span class="p">:</span> <span class="n">Point</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nv">centerX</span> <span class="p">=</span> <span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="kd">let</span> <span class="nv">centerY</span> <span class="p">=</span> <span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">centerX</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">centerY</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="kr">set</span> <span class="p">{</span>
            <span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">newValue</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">newValue</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end--><h3 id="toc_7" class="h16"><span class="span_for_h">简化 Getter 声明 {#shorthand-getter-declaration}</span></h3>

<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">如果整个 getter 是单一表达式，getter 会隐式地返回这个表达式结果。下面是另一个版本的 <code>Rect</code> 结构体，用到了简化的 getter 和 setter 声明：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">CompactRect</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">origin</span> <span class="p">=</span> <span class="n">Point</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nv">size</span> <span class="p">=</span> <span class="n">Size</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nv">center</span><span class="p">:</span> <span class="n">Point</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span>
            <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
                  <span class="n">y</span><span class="p">:</span> <span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="kr">set</span> <span class="p">{</span>
            <span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">newValue</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">newValue</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">在 getter 中忽略 <code>return</code> 与在函数中忽略 <code>return</code> 的规则相同，请参考 <a class="md_compiled" href="./06_Functions.md/#functions-with-an-implicit-return">隐式返回的函数</a>。</span>
</p>

<h3 id="toc_8" class="h16"><span class="span_for_h">只读计算属性 {#readonly-computed-properties}</span></h3>

<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">只有 getter 没有 setter 的计算属性叫<em class="md_patched_em">只读计算属性</em>。只读计算属性总是返回一个值，可以通过点运算符访问，但不能设置新的值。</span>
</p>


<blockquote class="blockquote_lines_3 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">注意<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line md_line_end">必须使用 <code>var</code> 关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。<code>let</code> 关键字只用来声明常量属性，表示初始化后再也无法修改的值。</span>
</p>

</blockquote>

<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">只读计算属性的声明可以去掉 <code>get</code> 关键字和花括号：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">Cuboid</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">width</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">height</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">depth</span> <span class="p">=</span> <span class="mf">0.0</span>
    <span class="kd">var</span> <span class="nv">volume</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">*</span> <span class="n">depth</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">fourByFiveByTwo</span> <span class="p">=</span> <span class="n">Cuboid</span><span class="p">(</span><span class="n">width</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span> <span class="n">depth</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;the volume of fourByFiveByTwo is </span><span class="si">\(</span><span class="n">fourByFiveByTwo</span><span class="p">.</span><span class="n">volume</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">// 打印“the volume of fourByFiveByTwo is 40.0”</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">这个例子定义了一个名为 <code>Cuboid</code> 的结构体，表示三维空间的立方体，包含 <code>width</code>、<code>height</code> 和 <code>depth</code> 属性。结构体还有一个名为 <code>volume</code> 的只读计算属性用来返回立方体的体积。为 <code>volume</code> 提供 setter 毫无意义，因为无法确定如何修改 <code>width</code>、<code>height</code> 和 <code>depth</code> 三者的值来匹配新的 <code>volume</code>。然而，<code>Cuboid</code> 提供一个只读计算属性来让外部用户直接获取体积是很有用的。</span>
</p>

<h2 id="toc_9" class="h16"><span class="span_for_h">属性观察器 {#property-observers}</span></h2>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，即使新值和当前值相同的时候也不例外。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">你可以为除了延时加载存储属性之外的其他存储属性添加属性观察器，你也可以在子类中通过重写属性的方式为继承的属性（包括存储属性和计算属性）添加属性观察器。你不必为非重写的计算属性添加属性观察器，因为你可以直接通过它的 setter 监控和响应值的变化。属性重写请参考 <a class="md_compiled" href="./13_Inheritance.md#overriding">重写</a>。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_ul">
    <span class="md_line md_line_start md_line_end">可以为属性添加其中一个或两个观察器：</span>
</p>


<ul>
<li class="md_li"><span><code>willSet</code> 在新的值被设置之前调用

</span></li>
<li class="md_li"><span><code>didSet</code> 在新的值被设置之后调用

</span></li>
</ul>

<p class="md_block">
    <span class="md_line md_line_start md_line_end"><code>willSet</code> 观察器会将新的属性值作为常量参数传入，在 <code>willSet</code> 的实现代码中可以为这个参数指定一个名称，如果不指定则参数仍然可用，这时使用默认名称 <code>newValue</code> 表示。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">同样，<code>didSet</code> 观察器会将旧的属性值作为参数传入，可以为该参数指定一个名称或者使用默认参数名 <code>oldValue</code>。如果在 <code>didSet</code> 方法中再次对该属性赋值，那么新值会覆盖旧的值。</span>
</p>


<blockquote class="blockquote_lines_5 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">注意<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line">在父类初始化方法调用之后，在子类构造器中给父类的属性赋值时，会调用父类属性的 <code>willSet</code> 和 <code>didSet</code> 观察器。而在父类初始化方法调用之前，给子类的属性赋值时不会调用子类属性的观察器。<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line md_line_end">有关构造器代理的更多信息，请参考 <a class="md_compiled" href="./14_Initialization.md#initializer-delegation-for-value-types">值类型的构造器代理</a> 和 <a class="md_compiled" href="./14-Initialization.md#initializer-delegation-for-class-types">类的构造器代理</a>。</span>
</p>

</blockquote>

<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">下面是一个 <code>willSet</code> 和 <code>didSet</code> 实际运用的例子，其中定义了一个名为 <code>StepCounter</code> 的类，用来统计一个人步行时的总步数。这个类可以跟计步器或其他日常锻炼的统计装置的输入数据配合使用。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">class</span> <span class="nc">StepCounter</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">totalSteps</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="kr">willSet</span><span class="p">(</span><span class="n">newTotalSteps</span><span class="p">)</span> <span class="p">{</span>
            <span class="bp">print</span><span class="p">(</span><span class="s">&quot;将 totalSteps 的值设置为 </span><span class="si">\(</span><span class="n">newTotalSteps</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="kr">didSet</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">totalSteps</span> <span class="o">&gt;</span> <span class="n">oldValue</span>  <span class="p">{</span>
                <span class="bp">print</span><span class="p">(</span><span class="s">&quot;增加了 </span><span class="si">\(</span><span class="n">totalSteps</span> <span class="o">-</span> <span class="n">oldValue</span><span class="si">)</span><span class="s"> 步&quot;</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">stepCounter</span> <span class="p">=</span> <span class="n">StepCounter</span><span class="p">()</span>
<span class="n">stepCounter</span><span class="p">.</span><span class="n">totalSteps</span> <span class="p">=</span> <span class="mi">200</span>
<span class="c1">// 将 totalSteps 的值设置为 200</span>
<span class="c1">// 增加了 200 步</span>
<span class="n">stepCounter</span><span class="p">.</span><span class="n">totalSteps</span> <span class="p">=</span> <span class="mi">360</span>
<span class="c1">// 将 totalSteps 的值设置为 360</span>
<span class="c1">// 增加了 160 步</span>
<span class="n">stepCounter</span><span class="p">.</span><span class="n">totalSteps</span> <span class="p">=</span> <span class="mi">896</span>
<span class="c1">// 将 totalSteps 的值设置为 896</span>
<span class="c1">// 增加了 536 步</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end"><code>StepCounter</code> 类定义了一个叫 <code>totalSteps</code> 的 <code>Int</code> 类型的属性。它是一个存储属性，包含 <code>willSet</code> 和 <code>didSet</code> 观察器。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">当 <code>totalSteps</code> 被设置新值的时候，它的 <code>willSet</code> 和 <code>didSet</code> 观察器都会被调用，即使新值和当前值完全相同时也会被调用。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">例子中的 <code>willSet</code> 观察器将表示新值的参数自定义为 <code>newTotalSteps</code>，这个观察器只是简单的将新的值输出。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end"><code>didSet</code> 观察器在 <code>totalSteps</code> 的值改变后被调用，它把新值和旧值进行对比，如果总步数增加了，就输出一个消息表示增加了多少步。<code>didSet</code> 没有为旧值提供自定义名称，所以默认值 <code>oldValue</code> 表示旧值的参数名。</span>
</p>


<blockquote class="blockquote_lines_3 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">注意<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line md_line_end">如果将带有观察器的属性通过 in-out 方式传入函数，<code>willSet</code> 和 <code>didSet</code> 也会调用。这是因为 in-out 参数采用了拷入拷出内存模式：即在函数内部使用的是参数的 copy，函数结束后，又对参数重新赋值。关于 in-out 参数详细的介绍，请参考 <a class="md_compiled" href="../03_language_reference/05_Declarations.html#in-out-parameters">输入输出参数</a>。</span>
</p>

</blockquote>
<h2 id="toc_10" class="h16"><span class="span_for_h">属性包装器 {#property-wrappers}</span></h2>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">属性包装器在管理属性如何存储和定义属性的代码之间添加了一个分隔层。举例来说，如果你的属性需要线程安全性检查或者需要在数据库中存储它们的基本数据，那么必须给每个属性添加同样的逻辑代码。当使用属性包装器时，你只需在定义属性包装器时编写一次管理代码，然后应用到多个属性上来进行复用。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">定义一个属性包装器，你需要创建一个定义 <code>wrappedValue</code> 属性的结构体、枚举或者类。在下面的代码中，<code>TwelveOrLess</code> 结构体确保它包装的值始终是小于等于 12 的数字。如果要求它存储一个更大的数字，它则会存储 12 这个数字。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="p">@</span><span class="n">propertyWrapper</span>
<span class="kd">struct</span> <span class="nc">TwelveOrLess</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="kd">var</span> <span class="nv">number</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="kd">var</span> <span class="nv">wrappedValue</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">number</span> <span class="p">}</span>
        <span class="kr">set</span> <span class="p">{</span> <span class="n">number</span> <span class="p">=</span> <span class="bp">min</span><span class="p">(</span><span class="n">newValue</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">这个 setter 确保新值小于 12，而且返回被存储的值。</span>
</p>


<blockquote class="blockquote_lines_3 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">注意<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line md_line_end">上面例子以 <code>private</code> 的方式声明 <code>number</code> 变量，这使得 <code>number</code> 仅在 <code>TwelveOrLess</code> 的实现中使用。写在其他地方的代码通过使用 <code>wrappedValue</code> 的 getter 和 setter 来获取这个值，但不能直接使用 <code>number</code>。有关 <code>private</code> 的更多信息，请参考 <a class="md_compiled" href="./25_Access_Control.md">访问控制</a></span>
</p>

</blockquote>

<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">通过在属性之前写上包装器名称作为特性的方式，你可以把一个包装器应用到一个属性上去。这里有个存储小矩形的结构体。通过 <code>TwelveOrLess</code> 属性包装器实现类似（挺随意的）对“小”的定义。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">SmallRectangle</span> <span class="p">{</span>
    <span class="p">@</span><span class="n">TwelveOrLess</span> <span class="kd">var</span> <span class="nv">height</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="p">@</span><span class="n">TwelveOrLess</span> <span class="kd">var</span> <span class="nv">width</span><span class="p">:</span> <span class="nb">Int</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">rectangle</span> <span class="p">=</span> <span class="n">SmallRectangle</span><span class="p">()</span>
<span class="bp">print</span><span class="p">(</span><span class="n">rectangle</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
<span class="c1">// 打印 &quot;0&quot;</span>

<span class="n">rectangle</span><span class="p">.</span><span class="n">height</span> <span class="p">=</span> <span class="mi">10</span>
<span class="bp">print</span><span class="p">(</span><span class="n">rectangle</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
<span class="c1">// 打印 &quot;10&quot;</span>

<span class="n">rectangle</span><span class="p">.</span><span class="n">height</span> <span class="p">=</span> <span class="mi">24</span>
<span class="bp">print</span><span class="p">(</span><span class="n">rectangle</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
<span class="c1">// 打印 &quot;12&quot;</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end"><code>height</code> 和 <code>width</code> 属性从 <code>TwelveOrLess</code> 的定义中获取它们的初始值。该定义把 <code>TwelveOrLess.number</code> 设置为 0。把数字 10 存进 <code>rectangle.height</code> 中的操作能成功，是因为数字 10 很小。尝试存储 24 的操作实际上存储的值为 12，这是因为对于这个属性的 setter 的规则来说，24 太大了。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">当你把一个包装器应用到一个属性上时，编译器将合成提供包装器存储空间和通过包装器访问属性的代码。（属性包装器只负责存储被包装值，所以没有合成这些代码。）不利用这个特性语法的情况下，你可以写出使用属性包装器行为的代码。举例来说，这是先前代码清单中的 <code>SmallRectangle</code> 的另一个版本。这个版本将其属性明确地包装在 <code>TwelveOrLess</code> 结构体中，而不是把 <code>@TwelveOrLess</code> 作为特性写下来：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">SmallRectangle</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="kd">var</span> <span class="nv">_height</span> <span class="p">=</span> <span class="n">TwelveOrLess</span><span class="p">()</span>
    <span class="kd">private</span> <span class="kd">var</span> <span class="nv">_width</span> <span class="p">=</span> <span class="n">TwelveOrLess</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nv">height</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_height</span><span class="p">.</span><span class="n">wrappedValue</span> <span class="p">}</span>
        <span class="kr">set</span> <span class="p">{</span> <span class="n">_height</span><span class="p">.</span><span class="n">wrappedValue</span> <span class="p">=</span> <span class="n">newValue</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nv">width</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_width</span><span class="p">.</span><span class="n">wrappedValue</span> <span class="p">}</span>
        <span class="kr">set</span> <span class="p">{</span> <span class="n">_width</span><span class="p">.</span><span class="n">wrappedValue</span> <span class="p">=</span> <span class="n">newValue</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end"><code>_height</code> 和 <code>_width</code> 属性存着这个属性包装器的一个实例，即 <code>TwelveOrLess</code>。<code>height</code> 和 <code>width</code> 的 getter 和 setter 把对 <code>wrappedValue</code> 属性的访问包装起来。</span>
</p>

<h3 id="toc_11" class="h16"><span class="span_for_h">设置被包装属性的初始值 {#setting-initial-values-for-wrapped-properties}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">上面例子中的代码通过在 <code>TwelveOrLess</code> 的定义中赋予 <code>number</code> 一个初始值来设置被包装属性的初始值。使用这个属性包装器的代码没法为被 <code>TwelveOrLess</code> 包装的属性指定其他初始值。举例来说，<code>SmallRectangle</code> 的定义没法给 <code>height</code> 或者 <code>width</code> 一个初始值。为了支持设定一个初始值或者其他自定义操作，属性包装器需要添加一个构造器。这是 <code>TwelveOrLess</code> 的扩展版本，称为 <code>SmallNumber</code>。<code>SmallNumber</code> 定义了能设置被包装值和最大值的构造器：</span>
</p>

<span class="md_repeated_n md_repeated_n_1"></span><div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="p">@</span><span class="n">propertyWrapper</span>
<span class="kd">struct</span> <span class="nc">SmallNumber</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="kd">var</span> <span class="nv">maximum</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">private</span> <span class="kd">var</span> <span class="nv">number</span><span class="p">:</span> <span class="nb">Int</span>

    <span class="kd">var</span> <span class="nv">wrappedValue</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">number</span> <span class="p">}</span>
        <span class="kr">set</span> <span class="p">{</span> <span class="n">number</span> <span class="p">=</span> <span class="bp">min</span><span class="p">(</span><span class="n">newValue</span><span class="p">,</span> <span class="n">maximum</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">maximum</span> <span class="p">=</span> <span class="mi">12</span>
        <span class="n">number</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">wrappedValue</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">maximum</span> <span class="p">=</span> <span class="mi">12</span>
        <span class="n">number</span> <span class="p">=</span> <span class="bp">min</span><span class="p">(</span><span class="n">wrappedValue</span><span class="p">,</span> <span class="n">maximum</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">wrappedValue</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">maximum</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">maximum</span> <span class="p">=</span> <span class="n">maximum</span>
        <span class="n">number</span> <span class="p">=</span> <span class="bp">min</span><span class="p">(</span><span class="n">wrappedValue</span><span class="p">,</span> <span class="n">maximum</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end"><code>SmallNumber</code> 的定义包括三个构造器——<code>init()</code>、<code>init(wrappedValue:)</code> 和 <code>init(wrappedValue:maximum:)</code>——下面的示例使用这三个构造器来设置被包装值和最大值。有关构造过程和构造器语法的更多信息，请参考 <a class="md_compiled" href="./14_Initialization.md">构造过程</a>。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">当你把包装器应用于属性且没有设定初始值时，Swift 使用 <code>init()</code> 构造器来设置包装器。举个例子：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">ZeroRectangle</span> <span class="p">{</span>
    <span class="p">@</span><span class="n">SmallNumber</span> <span class="kd">var</span> <span class="nv">height</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="p">@</span><span class="n">SmallNumber</span> <span class="kd">var</span> <span class="nv">width</span><span class="p">:</span> <span class="nb">Int</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">zeroRectangle</span> <span class="p">=</span> <span class="n">ZeroRectangle</span><span class="p">()</span>
<span class="bp">print</span><span class="p">(</span><span class="n">zeroRectangle</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">zeroRectangle</span><span class="p">.</span><span class="n">width</span><span class="p">)</span>
<span class="c1">// 打印 &quot;0 0&quot;</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">调用 <code>SmallNumber()</code> 来创建包装 <code>height</code> 和 <code>width</code> 的 <code>SmallNumber</code> 的实例。构造器内部的代码使用默认值 0 和 12 设置初始的被包装值和初始的最大值。像之前使用在 <code>SmallRectangle</code> 中使用 <code>TwelveOrLess</code> 的例子，这个属性包装器仍然提供所有的初始值。与这个例子不同的是，<code>SmallNumber</code> 也支持把编写这些初始值作为声明属性的一部分。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">当你为属性指定初始值时，Swift 使用 <code>init(wrappedValue:)</code> 构造器来设置包装器。举个例子：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">UnitRectangle</span> <span class="p">{</span>
    <span class="p">@</span><span class="n">SmallNumber</span> <span class="kd">var</span> <span class="nv">height</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="p">@</span><span class="n">SmallNumber</span> <span class="kd">var</span> <span class="nv">width</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">unitRectangle</span> <span class="p">=</span> <span class="n">UnitRectangle</span><span class="p">()</span>
<span class="bp">print</span><span class="p">(</span><span class="n">unitRectangle</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">unitRectangle</span><span class="p">.</span><span class="n">width</span><span class="p">)</span>
<span class="c1">// 打印 &quot;1 1&quot;</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">当你对一个被包装的属性写下 <code>= 1</code> 时，这被转换为调用 <code>init(wrappedValue:)</code> 构造器。调用 <code>SmallNumber(wrappedValue: 1)</code>来创建包装 <code>height</code> 和 <code>width</code> 的 <code>SmallNumber</code> 的实例。构造器使用此处指定的被包装值，且使用的默认最大值为 12。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">当你在自定义特性后面把实参写在括号里时，Swift 使用接受这些实参的构造器来设置包装器。举例来说，如果你提供初始值和最大值，Swift 使用 <code>init(wrappedValue:maximum:)</code> 构造器:</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">NarrowRectangle</span> <span class="p">{</span>
    <span class="p">@</span><span class="n">SmallNumber</span><span class="p">(</span><span class="n">wrappedValue</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">maximum</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span> <span class="kd">var</span> <span class="nv">height</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="p">@</span><span class="n">SmallNumber</span><span class="p">(</span><span class="n">wrappedValue</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">maximum</span><span class="p">:</span> <span class="mi">4</span><span class="p">)</span> <span class="kd">var</span> <span class="nv">width</span><span class="p">:</span> <span class="nb">Int</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">narrowRectangle</span> <span class="p">=</span> <span class="n">NarrowRectangle</span><span class="p">()</span>
<span class="bp">print</span><span class="p">(</span><span class="n">narrowRectangle</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">narrowRectangle</span><span class="p">.</span><span class="n">width</span><span class="p">)</span>
<span class="c1">// 打印 &quot;2 3&quot;</span>

<span class="n">narrowRectangle</span><span class="p">.</span><span class="n">height</span> <span class="p">=</span> <span class="mi">100</span>
<span class="n">narrowRectangle</span><span class="p">.</span><span class="n">width</span> <span class="p">=</span> <span class="mi">100</span>
<span class="bp">print</span><span class="p">(</span><span class="n">narrowRectangle</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">narrowRectangle</span><span class="p">.</span><span class="n">width</span><span class="p">)</span>
<span class="c1">// 打印 &quot;5 4&quot;</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">调用 <code>SmallNumber(wrappedValue: 2, maximum: 5)</code> 来创建包装 <code>height</code> 的 <code>SmallNumber</code> 的一个实例。调用 <code>SmallNumber(wrappedValue: 3, maximum: 4)</code> 来创建包装 <code>width</code> 的 <code>SmallNumber</code> 的一个实例。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">通过将实参包含到属性包装器中，你可以设置包装器的初始状态，或者在创建包装器时传递其他的选项。这种语法是使用属性包装器最通用的方法。你可以为这个属性提供任何所需的实参，且它们将被传递给构造器。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">当包含属性包装器实参时，你也可以使用赋值来指定初始值。Swift 将赋值视为 <code>wrappedValue</code> 参数，且使用接受被包含的实参的构造器。举个例子：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">MixedRectangle</span> <span class="p">{</span>
    <span class="p">@</span><span class="n">SmallNumber</span> <span class="kd">var</span> <span class="nv">height</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="p">@</span><span class="n">SmallNumber</span><span class="p">(</span><span class="n">maximum</span><span class="p">:</span> <span class="mi">9</span><span class="p">)</span> <span class="kd">var</span> <span class="nv">width</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">2</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">mixedRectangle</span> <span class="p">=</span> <span class="n">MixedRectangle</span><span class="p">()</span>
<span class="bp">print</span><span class="p">(</span><span class="n">mixedRectangle</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
<span class="c1">// 打印 &quot;1&quot;</span>

<span class="n">mixedRectangle</span><span class="p">.</span><span class="n">height</span> <span class="p">=</span> <span class="mi">20</span>
<span class="bp">print</span><span class="p">(</span><span class="n">mixedRectangle</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
<span class="c1">// 打印 &quot;12&quot;</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">调用 <code>SmallNumber(wrappedValue: 1)</code> 来创建包装 <code>height</code> 的 <code>SmallNumber</code> 的一个实例，这个实例使用默认最大值 12。调用 <code>SmallNumber(wrappedValue: 2, maximum: 9)</code> 来创建包装 <code>width</code> 的 <code>SmallNumber</code> 的一个实例。</span>
</p>

<h3 id="toc_12" class="h16"><span class="span_for_h">从属性包装器中呈现一个值 {#projecting-a-value-from-a-property-wrapper}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">除了被包装值，属性包装器可以通过定义被呈现值暴露出其他功能。举个例子，管理对数据库的访问的属性包装器可以在它的被呈现值上暴露出 <code>flushDatabaseConnection()</code> 方法。除了以货币符号（$）开头，被呈现值的名称和被包装值是一样的。因为你的代码不能够定义以 $ 开头的属性，所以被呈现值永远不会与你定义的属性有冲突。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">在之前 <code>SmallNumber</code> 的例子中，如果你尝试把这个属性设置为一个很大的数值，属性包装器会在存储这个数值之前调整这个数值。以下的代码把被呈现值添加到 <code>SmallNumber</code> 结构体中来追踪在存储新值之前属性包装器是否为这个属性调整了新值。</span>
</p>

<span class="md_repeated_n md_repeated_n_1"></span><div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="p">@</span><span class="n">propertyWrapper</span>
<span class="kd">struct</span> <span class="nc">SmallNumber</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="kd">var</span> <span class="nv">number</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="kd">var</span> <span class="nv">projectedValue</span> <span class="p">=</span> <span class="kc">false</span>
    <span class="kd">var</span> <span class="nv">wrappedValue</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">number</span> <span class="p">}</span>
        <span class="kr">set</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">newValue</span> <span class="o">&gt;</span> <span class="mi">12</span> <span class="p">{</span>
                <span class="n">number</span> <span class="p">=</span> <span class="mi">12</span>
                <span class="n">projectedValue</span> <span class="p">=</span> <span class="kc">true</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">number</span> <span class="p">=</span> <span class="n">newValue</span>
                <span class="n">projectedValue</span> <span class="p">=</span> <span class="kc">false</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="nc">SomeStructure</span> <span class="p">{</span>
    <span class="p">@</span><span class="n">SmallNumber</span> <span class="kd">var</span> <span class="nv">someNumber</span><span class="p">:</span> <span class="nb">Int</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nv">someStructure</span> <span class="p">=</span> <span class="n">SomeStructure</span><span class="p">()</span>

<span class="n">someStructure</span><span class="p">.</span><span class="n">someNumber</span> <span class="p">=</span> <span class="mi">4</span>
<span class="bp">print</span><span class="p">(</span><span class="n">someStructure</span><span class="p">.</span><span class="err">$</span><span class="n">someNumber</span><span class="p">)</span>
<span class="c1">// 打印 &quot;false&quot;</span>

<span class="n">someStructure</span><span class="p">.</span><span class="n">someNumber</span> <span class="p">=</span> <span class="mi">55</span>
<span class="bp">print</span><span class="p">(</span><span class="n">someStructure</span><span class="p">.</span><span class="err">$</span><span class="n">someNumber</span><span class="p">)</span>
<span class="c1">// 打印 &quot;true&quot;</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">写下 <code>s.$someNumber</code> 即可访问包装器的被呈现值。在存储一个比较小的数值时，如 4 ，<code>s.$someNumber</code> 的值为 <code>false</code>。但是，在尝试存储一个较大的数值时，如 55 ，被呈现值变为 <code>true</code>。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">属性包装器可以返回任何类型的值作为它的被呈现值。在这个例子里，属性包装器要暴露的信息是：那个数值是否被调整过，所以它暴露出布尔型值来作为它的被呈现值。需要暴露出更多信息的包装器可以返回其他数据类型的实例，或者可以返回自身来暴露出包装器的实例，并把其作为它的被呈现值。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">当从类型的一部分代码中访问被呈现值，例如属性 getter 或实例方法，你可以在属性名称之前省略 <code>self.</code>，就像访问其他属性一样。以下示例中的代码用 <code>$height</code> 和 <code>$width</code> 引用包装器 <code>height</code> 和 <code>width</code> 的被呈现值：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">enum</span> <span class="nc">Size</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">small</span><span class="p">,</span> <span class="n">large</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="nc">SizedRectangle</span> <span class="p">{</span>
    <span class="p">@</span><span class="n">SmallNumber</span> <span class="kd">var</span> <span class="nv">height</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="p">@</span><span class="n">SmallNumber</span> <span class="kd">var</span> <span class="nv">width</span><span class="p">:</span> <span class="nb">Int</span>

    <span class="kr">mutating</span> <span class="kd">func</span> <span class="nf">resize</span><span class="p">(</span><span class="n">to</span> <span class="n">size</span><span class="p">:</span> <span class="n">Size</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="n">size</span> <span class="p">{</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">small</span><span class="p">:</span>
            <span class="n">height</span> <span class="p">=</span> <span class="mi">10</span>
            <span class="n">width</span> <span class="p">=</span> <span class="mi">20</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">large</span><span class="p">:</span>
            <span class="n">height</span> <span class="p">=</span> <span class="mi">100</span>
            <span class="n">width</span> <span class="p">=</span> <span class="mi">100</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="err">$</span><span class="n">height</span> <span class="o">||</span> <span class="err">$</span><span class="n">width</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">因为属性包装器语法只是具有 getter 和 setter 的属性的语法糖，所以访问 <code>height</code> 和 <code>width</code> 的行为与访问任何其他属性的行为相同。举个例子，<code>resize(to:)</code> 中的代码使用它们的属性包装器来访问 <code>height</code> 和 <code>width</code>。如果调用 <code>resize(to: .large)</code>，<code>.large</code> 的 switch case 分支语句把矩形的高度和宽度设置为 100。属性包装器防止这些属性的值大于 12，且把被呈现值设置成为 <code>true</code> 来记下它调整过这些值的事实。在 <code>resize(to:)</code> 的最后，返回语句检查 <code>$height</code> 和 <code>$width</code> 来确认是否属性包装器调整过 <code>height</code> 或 <code>width</code>。</span>
</p>

<h2 id="toc_13" class="h16"><span class="span_for_h">全局变量和局部变量 {#global-and-local-variables}</span></h2>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">计算属性和观察属性所描述的功能也可以用于<em class="md_patched_em">全局变量</em>和<em class="md_patched_em">局部变量</em>。全局变量是在函数、方法、闭包或任何类型之外定义的变量。局部变量是在函数、方法或闭包内部定义的变量。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">前面章节提到的全局或局部变量都属于<em class="md_patched_em">存储型变量</em>，跟存储属性类似，它为特定类型的值提供存储空间，并允许读取和写入。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">另外，在全局或局部范围都可以定义<em class="md_patched_em">计算型变量</em>和为存储型变量定义观察器。计算型变量跟计算属性一样，返回一个计算结果而不是存储值，声明格式也完全一样。</span>
</p>


<blockquote class="blockquote_lines_5 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">注意<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line">全局的常量或变量都是延迟计算的，跟 <a class="md_compiled" href="#lazy-stored-properties">延时加载存储属性</a> 相似，不同的地方在于，全局的常量或变量不需要标记 <code>lazy</code> 修饰符。<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line md_line_end">局部范围的常量和变量从不延迟计算。</span>
</p>

</blockquote>
<h2 id="toc_14" class="h16"><span class="span_for_h">类型属性 {#type-properties}</span></h2>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">实例属性属于一个特定类型的实例，每创建一个实例，实例都拥有属于自己的一套属性值，实例之间的属性相互独立。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">你也可以为类型本身定义属性，无论创建了多少个该类型的实例，这些属性都只有唯一一份。这种属性就是<em class="md_patched_em">类型属性</em>。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">类型属性用于定义某个类型所有实例共享的数据，比如<em class="md_patched_em">所有</em>实例都能用的一个常量（就像 C 语言中的静态常量），或者所有实例都能访问的一个变量（就像 C 语言中的静态变量）。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">存储型类型属性可以是变量或常量，计算型类型属性跟实例的计算型属性一样只能定义成变量属性。</span>
</p>


<blockquote class="blockquote_lines_5 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">注意<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line">跟实例的存储型属性不同，必须给存储型类型属性指定默认值，因为类型本身没有构造器，也就无法在初始化过程中使用构造器给类型属性赋值。<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line md_line_end">存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用 <code>lazy</code> 修饰符。</span>
</p>

</blockquote>
<h3 id="toc_15" class="h16"><span class="span_for_h">类型属性语法 {#type-property-syntax}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">在 C 或 Objective-C 中，与某个类型关联的静态常量和静态变量，是作为 <em>global</em>（全局）静态变量定义的。但是在 Swift 中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，因此它的作用范围也就在类型支持的范围内。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">使用关键字 <code>static</code> 来定义类型属性。在为类定义计算型类型属性时，可以改用关键字 <code>class</code> 来支持子类对父类的实现进行重写。下面的例子演示了存储型和计算型类型属性的语法：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">SomeStructure</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">storedTypeProperty</span> <span class="p">=</span> <span class="s">&quot;Some value.&quot;</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">computedTypeProperty</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">enum</span> <span class="nc">SomeEnumeration</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">storedTypeProperty</span> <span class="p">=</span> <span class="s">&quot;Some value.&quot;</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">computedTypeProperty</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">6</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="nc">SomeClass</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">storedTypeProperty</span> <span class="p">=</span> <span class="s">&quot;Some value.&quot;</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">computedTypeProperty</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">27</span>
    <span class="p">}</span>
    <span class="kd">class</span> <span class="nc">var</span> <span class="n">overrideableComputedTypeProperty</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">107</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<blockquote class="blockquote_lines_3 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">注意<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line md_line_end">例子中的计算型类型属性是只读的，但也可以定义可读可写的计算型类型属性，跟计算型实例属性的语法相同。</span>
</p>

</blockquote>
<h3 id="toc_16" class="h16"><span class="span_for_h">获取和设置类型属性的值 {#querying-and-setting-type-properties}</span></h3>

<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">跟实例属性一样，类型属性也是通过点运算符来访问。但是，类型属性是通过<em class="md_patched_em">类型</em>本身来访问，而不是通过实例。比如：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="bp">print</span><span class="p">(</span><span class="n">SomeStructure</span><span class="p">.</span><span class="n">storedTypeProperty</span><span class="p">)</span>
<span class="c1">// 打印“Some value.”</span>
<span class="n">SomeStructure</span><span class="p">.</span><span class="n">storedTypeProperty</span> <span class="p">=</span> <span class="s">&quot;Another value.&quot;</span>
<span class="bp">print</span><span class="p">(</span><span class="n">SomeStructure</span><span class="p">.</span><span class="n">storedTypeProperty</span><span class="p">)</span>
<span class="c1">// 打印“Another value.”</span>
<span class="bp">print</span><span class="p">(</span><span class="n">SomeEnumeration</span><span class="p">.</span><span class="n">computedTypeProperty</span><span class="p">)</span>
<span class="c1">// 打印“6”</span>
<span class="bp">print</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">.</span><span class="n">computedTypeProperty</span><span class="p">)</span>
<span class="c1">// 打印“27”</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">下面的例子定义了一个结构体，使用两个存储型类型属性来表示两个声道的音量，每个声道具有 <code>0</code> 到 <code>10</code> 之间的整数音量。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">下图展示了如何把两个声道结合来模拟立体声的音量。当声道的音量是 <code>0</code>，没有一个灯会亮；当声道的音量是 <code>10</code>，所有灯点亮。本图中，左声道的音量是 <code>9</code>，右声道的音量是 <code>7</code>：</span>
</p>

<p class="md_compiled md_paragraph_html"><img src="https://docs.swift.org/swift-book/_images/staticPropertiesVUMeter_2x.png" alt="Static Properties VUMeter" width="243" height="357" /></p>
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">上面所描述的声道模型使用 <code>AudioChannel</code> 结构体的实例来表示：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">AudioChannel</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">let</span> <span class="nv">thresholdLevel</span> <span class="p">=</span> <span class="mi">10</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">maxInputLevelForAllChannels</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="kd">var</span> <span class="nv">currentLevel</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="kr">didSet</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">currentLevel</span> <span class="o">&gt;</span> <span class="n">AudioChannel</span><span class="p">.</span><span class="n">thresholdLevel</span> <span class="p">{</span>
                <span class="c1">// 将当前音量限制在阈值之内</span>
                <span class="n">currentLevel</span> <span class="p">=</span> <span class="n">AudioChannel</span><span class="p">.</span><span class="n">thresholdLevel</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">currentLevel</span> <span class="o">&gt;</span> <span class="n">AudioChannel</span><span class="p">.</span><span class="n">maxInputLevelForAllChannels</span> <span class="p">{</span>
                <span class="c1">// 存储当前音量作为新的最大输入音量</span>
                <span class="n">AudioChannel</span><span class="p">.</span><span class="n">maxInputLevelForAllChannels</span> <span class="p">=</span> <span class="n">currentLevel</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end"><code>AudioChannel</code> 结构定义了 2 个存储型类型属性来实现上述功能。第一个是 <code>thresholdLevel</code>，表示音量的最大上限阈值，它是一个值为 <code>10</code> 的常量，对所有实例都可见，如果音量高于 <code>10</code>，则取最大上限值 <code>10</code>（见后面描述）。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">第二个类型属性是变量存储型属性 <code>maxInputLevelForAllChannels</code>，它用来表示所有 <code>AudioChannel</code> 实例的最大输入音量，初始值是 <code>0</code>。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end"><code>AudioChannel</code> 也定义了一个名为 <code>currentLevel</code> 的存储型实例属性，表示当前声道现在的音量，取值为 <code>0</code> 到 <code>10</code>。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_ul">
    <span class="md_line md_line_start md_line_end">属性 <code>currentLevel</code> 包含 <code>didSet</code> 属性观察器来检查每次设置后的属性值，它做如下两个检查：</span>
</p>


<ul>
<li class="md_li"><span>如果 <code>currentLevel</code> 的新值大于允许的阈值 <code>thresholdLevel</code>，属性观察器将 <code>currentLevel</code> 的值限定为阈值 <code>thresholdLevel</code>。

</span></li>
<li class="md_li"><span>如果修正后的 <code>currentLevel</code> 值大于静态类型属性 <code>maxInputLevelForAllChannels</code> 的值，属性观察器就将新值保存在 <code>maxInputLevelForAllChannels</code> 中。

</span></li>
</ul>

<blockquote class="blockquote_lines_3 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">注意<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line md_line_end">在第一个检查过程中，<code>didSet</code> 属性观察器将 <code>currentLevel</code> 设置成了不同的值，但这不会造成属性观察器被再次调用。</span>
</p>

</blockquote>

<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">可以使用结构体 <code>AudioChannel</code> 创建两个声道 <code>leftChannel</code> 和 <code>rightChannel</code>，用以表示立体声系统的音量：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">var</span> <span class="nv">leftChannel</span> <span class="p">=</span> <span class="n">AudioChannel</span><span class="p">()</span>
<span class="kd">var</span> <span class="nv">rightChannel</span> <span class="p">=</span> <span class="n">AudioChannel</span><span class="p">()</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">如果将左声道的 <code>currentLevel</code> 设置成 <code>7</code>，类型属性 <code>maxInputLevelForAllChannels</code> 也会更新成 <code>7</code>：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="n">leftChannel</span><span class="p">.</span><span class="n">currentLevel</span> <span class="p">=</span> <span class="mi">7</span>
<span class="bp">print</span><span class="p">(</span><span class="n">leftChannel</span><span class="p">.</span><span class="n">currentLevel</span><span class="p">)</span>
<span class="c1">// 输出“7”</span>
<span class="bp">print</span><span class="p">(</span><span class="n">AudioChannel</span><span class="p">.</span><span class="n">maxInputLevelForAllChannels</span><span class="p">)</span>
<span class="c1">// 输出“7”</span>
</pre></div>

<!--block_code_end-->
<p class="md_block last_md_block_in_page">
    <span class="md_line md_line_start md_line_end">如果试图将右声道的 <code>currentLevel</code> 设置成 <code>11</code>，它会被修正到最大值 <code>10</code>，同时 <code>maxInputLevelForAllChannels</code> 的值也会更新到 <code>10</code>：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="n">rightChannel</span><span class="p">.</span><span class="n">currentLevel</span> <span class="p">=</span> <span class="mi">11</span>
<span class="bp">print</span><span class="p">(</span><span class="n">rightChannel</span><span class="p">.</span><span class="n">currentLevel</span><span class="p">)</span>
<span class="c1">// 输出“10”</span>
<span class="bp">print</span><span class="p">(</span><span class="n">AudioChannel</span><span class="p">.</span><span class="n">maxInputLevelForAllChannels</span><span class="p">)</span>
<span class="c1">// 输出“10”</span>
</pre></div>

<!--block_code_end-->
        </div>
    </div>
    
        <script type= "text/javascript">
            window.MathJax = {
              tex: {
                inlineMath: [ ['$','$']],
                displayMath: [ ['$$','$$'] ]
              },
              svg: {fontCache: 'none'},
              startup: {
                    ready: () => {
                      MathJax.startup.defaultReady();
                      MathJax.startup.promise.then(() => {
                        if (typeof(send_to_app_client)!='undefined'){send_to_app_client({'action': 'start_to_export_pdf'})}
                      });
                    }
                  },
              options: {
                renderActions: {
                  addMenu: [0]
                }
              }
            };
        </script>
        <script src="https://markeditor-files.oss-cn-hangzhou.aliyuncs.com/fb_static/lib/markdown/MathJax/tex-svg.js" type= "text/javascript"></script>
        
        
    <!--mermaid-->
</body>
</html>