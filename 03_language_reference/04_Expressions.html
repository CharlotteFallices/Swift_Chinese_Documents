
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="renderer" content="webkit">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/>
    <meta content="yes" name="apple-mobile-web-app-capable"/>
    <meta content="black" name="apple-mobile-web-app-status-bar-style"/>
    <meta content="telephone=no" name="format-detection"/>
    <meta name="renderer" content="webkit"/>
    <title>表达式（Expressions）</title>
    <link rel="stylesheet" href="data:text/css;base64,CiAgICBoMSwgaDIsIGgzLCBoNSwgaDYsICBpbWcsIHN2ZywgcHJlLCB0YWJsZSwgdHJ7cGFnZS1icmVhay1pbnNpZGU6IGF2b2lkfQoKICAgIAogICAgLnBvc3R7CiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjsKICAgIH0KICAgIGJvZHkgewogICAgICAgIGJhY2tncm91bmQ6ICMxNzFEMjE7CiAgICAgICAgZm9udC1zaXplOiAxNHB4OwogICAgICAgIGxpbmUtaGVpZ2h0OjIuNDsKICAgICAgICBmb250LWZhbWlseTogIkhlbHZldGljYSBOZXVlIiwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmOwogICAgICAgIGZvbnQtd2VpZ2h0OiBub3JtYWw7CiAgICAgICAgY29sb3I6ICNBNUIwQzA7CiAgICAgICAgcGFkZGluZzogMCAzOHB4OwogICAgICAgIG1heC13aWR0aDogODIwcHg7CiAgICAgICAgbWFyZ2luOiAwIGF1dG87CgogICAgICAgIHdvcmQtd3JhcDpicmVhay13b3JkOwogICAgICAgIHdvcmQtYnJlYWs6IG5vcm1hbDsKICAgICAgICBvdmVyZmxvdy13cmFwOmJyZWFrLXdvcmQ7CiAgICAgICAgdGV4dC1hbGlnbjoganVzdGlmeTsKCgogICAgICAgIG92ZXJmbG93LXg6IGhpZGRlbjsKICAgICAgICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVMZWdpYmlsaXR5OwogICAgICAgIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogbm9uZTsKICAgIH0KCiAgICBicnsKICAgICAgICBsaW5lLWhlaWdodDogMi40OwogICAgfQoKCgogICAgQG1lZGlhIChtYXgtd2lkdGg6IDYwMHB4KSB7CiAgICAgICAgYm9keXsKICAgICAgICAgICAgcGFkZGluZzogMCAzMHB4OwogICAgICAgIH0KICAgIH0KCiAgICBAbWVkaWEgKG1heC13aWR0aDogNDgwcHgpIHsKICAgICAgICBib2R5ewogICAgICAgICAgICBwYWRkaW5nOiAwIDIwcHg7CiAgICAgICAgfQogICAgfQoKICAgIC5naXN0ewogICAgICAgIHdvcmQtYnJlYWs6IG5vcm1hbDsKICAgIH0KCiAgICAucG9zdHsKICAgICAgICBtYXJnaW4tdG9wOiAxMHB4OwogICAgICAgIG1hcmdpbi1ib3R0b206IDUwcHg7CiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlOwogICAgfQoKCgogICAgaW1newogICAgICAgIG1heC13aWR0aDogOTglOwogICAgICAgIG1hcmdpbjogMC44ZW0gYXV0byAwLjhlbSBhdXRvOwogICAgfQoKICAgIGgxIGltZywgaDIgaW1nLCBoMyBpbWcsIGg0IGltZywgaDUgaW1nLCBoNiBpbWd7CiAgICAgICAgbWFyZ2luOiBhdXRvOwogICAgfQoKICAgIC54Ml9pbWFnZXsKICAgICAgICB6b29tOiA1MCU7CiAgICB9CgogICAgLngzX2ltYWdlewogICAgICAgIHpvb206IDMzLjMzJTsKICAgIH0KCiAgICAueDRfaW1hZ2V7CiAgICAgICAgem9vbTogMjUlOwogICAgfQoKCiAgICBwIGltZ3sKICAgICAgICBtYXJnaW46IDAgYXV0bzsKICAgIH0KCiAgICBwewogICAgICAgIC8qb3ZlcmZsb3c6aGlkZGVuOyovCiAgICAgICAgbWFyZ2luOiAxLjBlbSAwIDEuOWVtIDA7CiAgICB9CgogICAgcC5tZF9ibG9ja19hc19vcGVuaW5newogICAgICAgIG1hcmdpbi1ib3R0b206IC0wLjVlbSAhaW1wb3J0YW50OwogICAgfQoKICAgIGxpIHB7CiAgICAgICAgbGluZS1oZWlnaHQ6IDIuMTY7CiAgICAgICAgbWFyZ2luOiAwOwogICAgfQoKICAgIC5wX3BhcnQgewogICAgICAgIG1hcmdpbjogMTBweCAwOwogICAgfQoKICAgIC5wX3BhcnQgcHsKICAgICAgICBtYXJnaW46IDAgMCAwLjZlbSAwOwogICAgfQoKICAgIC8qIHRleHQgaW5kZW50IGZvciBjaGluZXNlIHN0YXJ0cyovCiAgICAvKmgyLCBoMywgaDQsIGg1LCBoNiwgLnBfcGFydCBwLCAudG9kb19pdGVtLCBwewogICAgICAgIHRleHQtaW5kZW50OiAwcHg7CiAgICB9Ki8KICAgIHRhYmxlLCBwcmUsIHN2Z3sKICAgICAgICBtYXJnaW4tbGVmdDogMHB4OwogICAgICAgIG1hcmdpbi1yaWdodDogMHB4OwogICAgfQogICAgCiAgICBzcGFuIHN2Z3sKICAgICAgICBtYXJnaW4tbGVmdDogMDsKICAgICAgICBtYXJnaW4tcmlnaHQ6IDA7CiAgICB9CgogICAgLmxpbmVub2RpdiBwcmV7CiAgICAgICAgbWFyZ2luLWxlZnQ6IDA7CiAgICAgICAgbWFyZ2luLXJpZ2h0OiAwOwoKICAgIH0KICAgIAogICAgLmhpZ2hsaWdodCBwcmV7CiAgICAgICAgbWFyZ2luLWxlZnQ6IDA7CiAgICAgICAgbWFyZ2luLXJpZ2h0OiAwOwogICAgfQogICAgCiAgICAuaGlnaGxpZ2h0dGFibGUgLmNvZGUgeyBwb3NpdGlvbjogcmVsYXRpdmV9CiAgICAKICAgIC5oaWdobGlnaHR0YWJsZSBkaXYud2l0aF9saW5lc3sgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IHdpZHRoOiAxMDAlO30KICAgIAogICAgLmhpZ2hsaWdodHRhYmxlIGRpdi53aXRoX2xpbmVzIHByZXsKICAgICAgICBwYWRkaW5nLWxlZnQ6IDEwcHg7CiAgICB9CgoKCiAgICAvKiB0ZXh0IGluZGVudCBmb3IgY2hpbmVzZSBlbmRzKi8KCgogICAgYmxvY2txdW90ZSAucF9wYXJ0IHAsIGxpIC5wX3BhcnQgcHsKICAgICAgICB0ZXh0LWluZGVudDogMCAhaW1wb3J0YW50OwogICAgfQoKCiAgICBocnsKICAgICAgICBtYXJnaW46IDM4cHggMDsKICAgICAgICBib3JkZXI6IG5vbmU7CiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IGRhc2hlZCByZ2JhKDIwNSwgMjA1LCAyMDUsIDAuMzUpOwogICAgICAgIGNvbG9yOiByZ2JhKDIwNSwgMjA1LCAyMDUsIDAuMzUpOwogICAgICAgIGhlaWdodDogMXB4OwogICAgICAgIGxpbmUtaGVpZ2h0OjFweDsKICAgICAgICBmb250LXNpemU6MXB4OwogICAgICAgIG92ZXJmbG93LXk6IGhpZGRlbjsKICAgIH0KCgogICAgaDF7CiAgICAgICAgY29sb3I6ICNENUYwRjg7CiAgICAgICAgZm9udC1zaXplOiAxLjdlbTsKICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0OwogICAgICAgIG1hcmdpbjogMDsKICAgICAgICBwYWRkaW5nOiAwOwogICAgICAgIGxpbmUtaGVpZ2h0OiAxLjdlbTsKICAgICAgICBtYXJnaW4tdG9wOiAwLjhlbTsKICAgICAgICBtYXJnaW4tYm90dG9tOiAwLjZlbTsKICAgIH0KCiAgICBoMSwgaDIsIGgzLCBoNHsKICAgICAgICBjb2xvcjogI0Q1RjBGODsKICAgIH0KICAgIAogICAgaDF7Y29sb3I6I0Q1RjBGOH0KCgoKICAgIGgyLCBoM3sKICAgICAgICBsaW5lLWhlaWdodDogMS41ZW07CiAgICAgICAgbWFyZ2luLXRvcDogMS44ZW07CiAgICAgICAgbWFyZ2luLWJvdHRvbTogMC41ZW07CiAgICB9CgogICAgLmgxNi5tZF9maXJzdF9oLm1kX2ZpcnN0X3BhcnQgewogICAgICAgIG1hcmdpbi10b3A6IDVweDsKICAgIH0KICAgIAogICAgLnNwYW5fZm9yX2h7CiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7CiAgICB9CgoKICAgIGgyIHsKICAgICAgICBmb250LXNpemU6IDEuNWVtOwogICAgfQoKICAgIGgzIHsKICAgICAgICBmb250LXNpemU6IDEuMjVlbQogICAgfQoKICAgIGg0IHsKICAgICAgICBmb250LXNpemU6IDEuMTVlbTsKICAgIH0KCiAgICBoNSB7CiAgICAgICAgZm9udC1zaXplOiAxLjFlbTsKICAgIH0KCiAgICBoNiB7Zm9udC1zaXplOiAxZW19CgoKICAgIGgxLCBoMiwgaDMsIGg0LCBoNSwgaDZ7CiAgICAgICAgZm9udC1mYW1pbHk6ICJQaW5nRmFuZyBTQyI7CiAgICB9CgoKICAgIG9sIHsKICAgICAgICBtYXJnaW46IDA7CiAgICB9CgogICAgdWx7CiAgICAgICAgcGFkZGluZzogNXB4IDM4cHg7CiAgICAgICAgbWFyZ2luOiAwOwogICAgfQoKICAgIHVsIGxpLCBsaXsKICAgICAgICBwYWRkaW5nOiAwOwogICAgICAgIG1hcmdpbjogMDsKICAgIH0KCiAgICB1bCBwLCBvbCBwewogICAgICAgIG92ZXJmbG93OiB2aXNpYmxlOwogICAgfQoKCiAgICBibG9ja3F1b3RlIHsKICAgICAgICAtbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7CiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDsKICAgICAgICBtYXJnaW46IDEuNmVtIDA7CiAgICAgICAgcGFkZGluZzogMCAwIDAgMS4yZW07CiAgICAgICAgYm9yZGVyLWxlZnQ6IDRweCBzb2xpZCAjMkE4MUM1OwogICAgICAgIGNvbG9yOiAjOUE5QTlBOwogICAgICAgIG1pbi1oZWlnaHQ6MjBweDsKICAgIH0KCgogICAgYmxvY2txdW90ZSBwIHsKICAgICAgICBtYXJnaW46IDAuOGVtIDA7CiAgICB9CgogICAgYmxvY2txdW90ZSBzcGFuLm1kX2xpbmUgewogICAgICAgIG1hcmdpbi1ib3R0b206IDAuMjVlbTsKICAgICAgICBtYXJnaW4tdG9wOiAwLjI1ZW07CiAgICB9CgogICAgYmxvY2txdW90ZSB1bHsKICAgICAgICBwYWRkaW5nOiAwIDE1cHg7CiAgICB9CgogICAgYmxvY2txdW90ZSBzbWFsbCB7CiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrOwogICAgICAgIG1hcmdpbjogMC44ZW0gMCAwLjhlbSAxLjVlbTsKICAgICAgICBmb250LXNpemU6IDAuOWVtOwogICAgICAgIGNvbG9yOiAjY2NjOwogICAgfQoKCgoKCgogICAgdGFibGUgewogICAgICAgIGxpbmUtaGVpZ2h0OiAxLjc7CiAgICAgICAgLW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94OwogICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7CiAgICAgICAgbWFyZ2luOiAxZW0gMDsKICAgICAgICB3aWR0aDogMTAwJTsKICAgICAgICBtYXgtd2lkdGg6IDEwMCU7CiAgICAgICAgYm9yZGVyLXdpZHRoOiAxcHg7CiAgICAgICAgYm9yZGVyLXN0eWxlOiBzb2xpZDsKICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsKICAgICAgICBib3JkZXItc3BhY2luZzogMDsKICAgICAgICB3b3JkLWJyZWFrOiBub3JtYWw7CiAgICB9CiAgICAKICAgIC8qIGZvciB3ZWNoYXQgb25seSBzdGFydHMgKi8KICAgIHRhYmxlIHRyewogICAgICAgIGJvcmRlci1yaWdodC1zdHlsZTogc29saWQ7CiAgICAgICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAxcHg7CiAgICB9CiAgICAKICAgIHRhYmxlIHRib2R5ewogICAgICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDFweDsKICAgICAgICBib3JkZXItYm90dG9tLXN0eWxlOiBzb2xpZDsKICAgIH0KICAgIC8qIGZvciB3ZWNoYXQgb25seSBlbmRzICovCgoKICAgIHRhYmxlLCB0YWJsZSB0ciwgdGFibGUgdHIgdGQsIHRhYmxlIHRyIHRoLCB0YWJsZSB0Ym9keSB7CiAgICAgICAgYm9yZGVyLWNvbG9yOiByZ2JhKDIwNSwgMjA1LCAyMDUsIDAuMzUpOwogICAgfQoKICAgIHRhYmxlIHRoIHsKICAgICAgICBmb250LXdlaWdodDogYm9sZDsKICAgIH0KCiAgICB0ciB0aCB7CiAgICAgICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMXB4OwogICAgICAgIGJvcmRlci1ib3R0b20tc3R5bGU6IHNvbGlkOwogICAgICAgIHRleHQtYWxpZ246IGxlZnQ7CiAgICB9CgogICAgdHIgdGgsIHRyIHRkIHsKICAgICAgICBwYWRkaW5nOiAxMHB4IDIwcHg7CiAgICAgICAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQ7CiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYmEoMjA1LCAyMDUsIDIwNSwgMC4zNSk7CiAgICB9CgogICAgdGJvZHkgdHI6bGFzdC1jaGlsZCB0ZHsKICAgICAgICBib3JkZXItYm90dG9tOiAwOwogICAgfQoKICAgIHRyIHRoOmxhc3QtY2hpbGQsIHRyIHRkOmxhc3QtY2hpbGQgewogICAgICAgIGJvcmRlci1yaWdodDogMDsKICAgIH0KCiAgICB0YWJsZSB0Ym9keSA+IHRyOm50aC1jaGlsZChvZGQpID4gdGQsIHRhYmxlIHRib2R5ID4gdHI6bnRoLWNoaWxkKG9kZCkgPiB0aCB7CiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMzUsIDIzNSwgMjM1LCAwLjIpOwogICAgfQoKCgoKICAgIGNvZGV7CiAgICAgICAgYmFja2dyb3VuZDogcmdiYSgyMzUsIDIzNSwgMjM1LCAwLjM1KTsKICAgICAgICBjb2xvcjogIzc4RTI5MTsKICAgICAgICBwYWRkaW5nOiAwIDVweDsKICAgICAgICBtYXJnaW46IDAgMnB4OwogICAgfQoKICAgIHByZXsKICAgICAgICBtYXJnaW4tdG9wOiAxLjJlbTsKICAgICAgICBtYXJnaW4tYm90dG9tOiAxLjJlbTsKICAgICAgICBwYWRkaW5nOiAxNXB4IDEwcHg7CiAgICAgICAgZGlzcGxheTogYmxvY2s7CiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgyMDUsIDIwNSwgMjA1LCAwLjM1KTsKICAgICAgICAvKmJhY2tncm91bmQ6IHJnYmEoMjM1LCAyMzUsIDIzNSwgMC4zNSk7Ki8KICAgICAgICBmb250LXNpemU6IDkwJTsKICAgICAgICBsaW5lLWhlaWdodDoyLjQ7CiAgICAgICAgd2hpdGUtc3BhY2U6IHByZS13cmFwOwogICAgICAgIG92ZXJmbG93LXk6IGhpZGRlbjsKICAgICAgICBvdmVyZmxvdy14OiBhdXRvOwogICAgICAgIHdvcmQtd3JhcDogbm9ybWFsOwogICAgfQogICAgCiAgICAuY29kZWhpbGl0ZSBwcmV7CiAgICAgICAgd2hpdGUtc3BhY2U6IHByZTsKICAgIH0KCiAgICAuaGlnaGxpZ2h0dGFibGUgdGR7CiAgICAgICAgLypiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIzNSwgMjM1LCAyMzUsIDAuMzUpICFpbXBvcnRhbnQ7Ki8KICAgIH0KCiAgICAud2l0aF9saW5lcyBwcmV7CiAgICAgICAgYm9yZGVyOm5vbmU7CiAgICAgICAgbWFyZ2luLXRvcDogMC4yZW07CiAgICAgICAgbWFyZ2luLWJvdHRvbTogMC4yZW07CiAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7CiAgICB9CgogICAgLmlzX2NvZGVfZmlsZSBwcmV7CiAgICAgICAgYm9yZGVyOiBub25lOwogICAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50OwogICAgfQoKICAgIC5jb2RlaGlsaXRlIHByZXsKICAgICAgICAvKndvcmQtd3JhcDogbm9ybWFsOyovCiAgICAgICAgZm9udC1zaXplOiAxM3B4OwogICAgfQoKICAgIHByZSBjb2RlewogICAgICAgIGJvcmRlcjpub25lOwogICAgICAgIGJhY2tncm91bmQ6IG5vbmU7CiAgICAgICAgcGFkZGluZzogMDsKICAgICAgICBtYXJnaW46IDA7CiAgICB9CgogICAgcHJlIHB7CiAgICAgICAgbWFyZ2luOiAwOwogICAgICAgIHBhZGRpbmc6IDA7CiAgICB9CgogICAgLmNvZGVoaWxpdGUgdGgsIC5jb2RlaGlsaXRlIHRkewogICAgICAgIGxpbmUtaGVpZ2h0OiAxLjhlbTsKICAgIH0KCgogICAgYXsKICAgICAgICBjb2xvcjogIzc3Qjg3RjsKICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7CiAgICAgICAgLy9ib3JkZXItYm90dG9tOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7CiAgICB9CgogICAgYTpob3ZlcnsKICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTsKICAgICAgICAvL2JvcmRlci1ib3R0b206IDFweCBzb2xpZCAjNzdCODdGOwogICAgfQoKICAgIHN0cm9uZyB7CiAgICAgICAgY29sb3I6ICNGRkZGRkY7CiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7CiAgICB9CgoKICAgIC8qIGZvciBtYXJrZG93biAqLwoKICAgIC5saW5lbm9zIHByZXsKCQliYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDsKCQlib3JkZXI6IG5vbmU7Cgl9CgoJLmxpbmVub3N7CgkgICAgcGFkZGluZzogMCA1cHggMCA1cHg7CgkgICAgd2lkdGg6IDAuMDAxJTsKCX0KCgkuaGlnaGxpZ2h0dGFibGUgIC5saW5lbm9zIHByZXsKCSAgICBwYWRkaW5nOiA1cHggMTBweDsKCX0KCQoJLmhpZ2hsaWdodHRhYmxlICAuY29kZSBwcmV7CgkgICAgcGFkZGluZzogMDsKCX0KCiAgICAudG9jewogICAgICAgIGJhY2tncm91bmQ6IE5vbmU7CiAgICAgICAgYm9yZGVyLXJhZGl1czogNXB4OwogICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIE5vbmU7CiAgICAgICAgbWFyZ2luOiAyN3B4IDAgNDdweCAwOwogICAgICAgIHBhZGRpbmc6IDEwcHggMDsKICAgIH0KCiAgICAudG9jIHVsewogICAgICAgIC8vcGFkZGluZzogNXB4IDQycHg7CiAgICB9CgogICAgLnRvYyB1bCBsaXsKICAgICAgICBwYWRkaW5nOiAwOwogICAgICAgIG1hcmdpbjogMDsKICAgIH0KICAgIC50b2MgYXsKICAgICAgICBjb2xvcjogI0E1QjBDMDsKICAgIH0KCgoKICAgIC50b2RvX2l0ZW17CiAgICAgICAgbGlzdC1zdHlsZTogbm9uZTsKICAgICAgICBtYXJnaW4tbGVmdDogLTEuNWVtCiAgICB9CiAgICAudG9kb19pdGVtIC50b2RvX2l0ZW0gewogICAgICAgIG1hcmdpbi1sZWZ0OiBhdXRvOwogICAgfQoKICAgIC50b2RvX2RvbmVfaXRlbXsKICAgICAgICBjb2xvcjogIzU1NTU1NTsKICAgIH0KCiAgICAudG9kb191bmRvbmVfaXRlbXsKICAgICAgICBjb2xvcjogI0RERERERDsKICAgIH0KCgogICAgdWwgbGkudG9kb19pdGVtewoJbGlzdC1zdHlsZS10eXBlOiBub25lOwogICAgfQoKICAgIHVsIGxpLnRvZG9faXRlbTpiZWZvcmV7CiAgICAgICAgY29udGVudDogJ+KYkCc7CiAgICAgICAgLypwYWRkaW5nLXJpZ2h0OiAwLjJlbTsqLwogICAgICAgIGZvbnQtZmFtaWx5OiBhcmlhbDsKICAgIH0KCiAgICB1bCBsaS50b2RvX2RvbmVfaXRlbTpiZWZvcmV7CiAgICAgICAgY29udGVudDogJ+KYkSc7CiAgICAgICAgLypwYWRkaW5nLXJpZ2h0OiAwLjJlbTsqLwogICAgICAgIGZvbnQtZmFtaWx5OiBhcmlhbDsKICAgIH0KCiAgICB1bCBsaS50b2RvX2l0ZW0gaW5wdXR7CiAgICAgICAgZGlzcGxheTpub25lCiAgICB9CgoKICAgIC8qcHlnbWVudHMqLwoKICAgIC5jb2RlaGlsaXRlewogICAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7CiAgICB9CgogICAgLyp0YWJsZS5oaWdobGlnaHR0YWJsZXsgYm9yZGVyOm5vbmU7IH0KICAgIC5oaWdobGlnaHR0YWJsZSB0ZHsgYm9yZGVyOiBub25lOyBwYWRkaW5nOiAwO30qLwoKICAgIC5mbG93LWdyYXBoaWMsIC5tZF9ibG9ja19zZWN0aW9uX2Zvcl9mbG93X2dyYXBoaWN7dGV4dC1hbGlnbjogY2VudGVyfQogICAgLmZsb3ctZ3JhcGhpYyB7IG92ZXJmbG93LXg6IGF1dG87fQogICAgLm1lcm1haWQsIC5tZF9ibG9ja19zZWN0aW9uX2Zvcl9tZXJtYWlke3RleHQtYWxpZ246IGNlbnRlcn0KICAgIAogICAgLmZsb3ctZ3JhcGhpYywgLm1lcm1haWR7CiAgICAgICAgYmFja2dyb3VuZDogI2ZmZmZmZjsKICAgIH0KCgogICAgdGFibGUsIHRyLCB0ZCwgdGgsIHRib2R5LCB0aGVhZCwgdGZvb3QsIC5tZF9lY2hhcnRzLCBibG9ja3F1b3RlIC5tZF9saW5lewogICAgICAgIHBhZ2UtYnJlYWstaW5zaWRlOiBhdm9pZCAhaW1wb3J0YW50OwogICAgfQoKICAgIC5mb290bm90ZXMgLm1kX2xpbmV7CiAgICAgICAgZGlzcGxheTogaW5saW5lICFpbXBvcnRhbnQ7CiAgICB9CgoKICAgIC5pbWdfcnRfOTB7CiAgICAgICAgdHJhbnNmb3JtOnJvdGF0ZSg5MGRlZyk7CiAgICAgICAgLW1zLXRyYW5zZm9ybTpyb3RhdGUoOTBkZWcpOwogICAgICAgIC1tb3otdHJhbnNmb3JtOnJvdGF0ZSg5MGRlZyk7CiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDkwZGVnKTsKICAgICAgICAtby10cmFuc2Zvcm06cm90YXRlKDkwZGVnKTsKICAgIH0KICAgIC5pbWdfcnRfMTgwewogICAgICAgIHRyYW5zZm9ybTpyb3RhdGUoMTgwZGVnKTsKICAgICAgICAtbXMtdHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpOwogICAgICAgIC1tb3otdHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpOwogICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpOwogICAgICAgIC1vLXRyYW5zZm9ybTpyb3RhdGUoMTgwZGVnKTsKICAgIH0KICAgIC5pbWdfcnRfMjcwewogICAgICAgIHRyYW5zZm9ybTpyb3RhdGUoMjcwZGVnKTsKICAgICAgICAtbXMtdHJhbnNmb3JtOnJvdGF0ZSgyNzBkZWcpOwogICAgICAgIC1tb3otdHJhbnNmb3JtOnJvdGF0ZSgyNzBkZWcpOwogICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgyNzBkZWcpOwogICAgICAgIC1vLXRyYW5zZm9ybTpyb3RhdGUoMjcwZGVnKTsKICAgIH0KCiAgICAubWRfaGFzX2Jsb2NrX2JlbG93ewogICAgICAgIG1hcmdpbi1ib3R0b206IDAuMWVtICFpbXBvcnRhbnQ7CiAgICB9CiAgICAubWRfaGFzX2Jsb2NrX2JlbG93X2ltZ3sKICAgICAgICBtYXJnaW4tYm90dG9tOiAtMC42ZW0gIWltcG9ydGFudDsKICAgIH0KCgogICAgLmNvZGVoaWxpdGUgLmVycnsKICAgICAgICBib3JkZXI6IG5vbmUgIWltcG9ydGFudDsKICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50OwogICAgfQoKCgogICAgICAgIHNwYW4ubWRfbGluZXttYXJnaW4tYm90dG9tOjAuNWVtOyBkaXNwbGF5OmJsb2NrOyBsaW5lLWhlaWdodDoyLjF9CiAgICAgICAgLm1kX2xpbmUgYnJ7IGRpc3BsYXk6IG5vbmU7fQogICAgICAgIC5jb2RlaGlsaXRlIC5obGwgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmZmNjIH0KLmNvZGVoaWxpdGUgIHsgYmFja2dyb3VuZDogI2ZmZmZmZjsgfQouY29kZWhpbGl0ZSAuYyB7IGNvbG9yOiAjMTc3NTAwIH0gLyogQ29tbWVudCAqLwouY29kZWhpbGl0ZSAuZXJyIHsgY29sb3I6ICMwMDAwMDAgfSAvKiBFcnJvciAqLwouY29kZWhpbGl0ZSAuayB7IGNvbG9yOiAjQTkwRDkxIH0gLyogS2V5d29yZCAqLwouY29kZWhpbGl0ZSAubCB7IGNvbG9yOiAjMUMwMUNFIH0gLyogTGl0ZXJhbCAqLwouY29kZWhpbGl0ZSAubiB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZSAqLwouY29kZWhpbGl0ZSAubyB7IGNvbG9yOiAjMDAwMDAwIH0gLyogT3BlcmF0b3IgKi8KLmNvZGVoaWxpdGUgLmNoIHsgY29sb3I6ICMxNzc1MDAgfSAvKiBDb21tZW50Lkhhc2hiYW5nICovCi5jb2RlaGlsaXRlIC5jbSB7IGNvbG9yOiAjMTc3NTAwIH0gLyogQ29tbWVudC5NdWx0aWxpbmUgKi8KLmNvZGVoaWxpdGUgLmNwIHsgY29sb3I6ICM2MzM4MjAgfSAvKiBDb21tZW50LlByZXByb2MgKi8KLmNvZGVoaWxpdGUgLmNwZiB7IGNvbG9yOiAjMTc3NTAwIH0gLyogQ29tbWVudC5QcmVwcm9jRmlsZSAqLwouY29kZWhpbGl0ZSAuYzEgeyBjb2xvcjogIzE3NzUwMCB9IC8qIENvbW1lbnQuU2luZ2xlICovCi5jb2RlaGlsaXRlIC5jcyB7IGNvbG9yOiAjMTc3NTAwIH0gLyogQ29tbWVudC5TcGVjaWFsICovCi5jb2RlaGlsaXRlIC5rYyB7IGNvbG9yOiAjQTkwRDkxIH0gLyogS2V5d29yZC5Db25zdGFudCAqLwouY29kZWhpbGl0ZSAua2QgeyBjb2xvcjogI0E5MEQ5MSB9IC8qIEtleXdvcmQuRGVjbGFyYXRpb24gKi8KLmNvZGVoaWxpdGUgLmtuIHsgY29sb3I6ICNBOTBEOTEgfSAvKiBLZXl3b3JkLk5hbWVzcGFjZSAqLwouY29kZWhpbGl0ZSAua3AgeyBjb2xvcjogI0E5MEQ5MSB9IC8qIEtleXdvcmQuUHNldWRvICovCi5jb2RlaGlsaXRlIC5rciB7IGNvbG9yOiAjQTkwRDkxIH0gLyogS2V5d29yZC5SZXNlcnZlZCAqLwouY29kZWhpbGl0ZSAua3QgeyBjb2xvcjogI0E5MEQ5MSB9IC8qIEtleXdvcmQuVHlwZSAqLwouY29kZWhpbGl0ZSAubGQgeyBjb2xvcjogIzFDMDFDRSB9IC8qIExpdGVyYWwuRGF0ZSAqLwouY29kZWhpbGl0ZSAubSB7IGNvbG9yOiAjMUMwMUNFIH0gLyogTGl0ZXJhbC5OdW1iZXIgKi8KLmNvZGVoaWxpdGUgLnMgeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nICovCi5jb2RlaGlsaXRlIC5uYSB7IGNvbG9yOiAjODM2QzI4IH0gLyogTmFtZS5BdHRyaWJ1dGUgKi8KLmNvZGVoaWxpdGUgLm5iIHsgY29sb3I6ICNBOTBEOTEgfSAvKiBOYW1lLkJ1aWx0aW4gKi8KLmNvZGVoaWxpdGUgLm5jIHsgY29sb3I6ICMzRjZFNzUgfSAvKiBOYW1lLkNsYXNzICovCi5jb2RlaGlsaXRlIC5ubyB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZS5Db25zdGFudCAqLwouY29kZWhpbGl0ZSAubmQgeyBjb2xvcjogIzAwMDAwMCB9IC8qIE5hbWUuRGVjb3JhdG9yICovCi5jb2RlaGlsaXRlIC5uaSB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZS5FbnRpdHkgKi8KLmNvZGVoaWxpdGUgLm5lIHsgY29sb3I6ICMwMDAwMDAgfSAvKiBOYW1lLkV4Y2VwdGlvbiAqLwouY29kZWhpbGl0ZSAubmYgeyBjb2xvcjogIzAwMDAwMCB9IC8qIE5hbWUuRnVuY3Rpb24gKi8KLmNvZGVoaWxpdGUgLm5sIHsgY29sb3I6ICMwMDAwMDAgfSAvKiBOYW1lLkxhYmVsICovCi5jb2RlaGlsaXRlIC5ubiB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZS5OYW1lc3BhY2UgKi8KLmNvZGVoaWxpdGUgLm54IHsgY29sb3I6ICMwMDAwMDAgfSAvKiBOYW1lLk90aGVyICovCi5jb2RlaGlsaXRlIC5weSB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZS5Qcm9wZXJ0eSAqLwouY29kZWhpbGl0ZSAubnQgeyBjb2xvcjogIzAwMDAwMCB9IC8qIE5hbWUuVGFnICovCi5jb2RlaGlsaXRlIC5udiB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZS5WYXJpYWJsZSAqLwouY29kZWhpbGl0ZSAub3cgeyBjb2xvcjogIzAwMDAwMCB9IC8qIE9wZXJhdG9yLldvcmQgKi8KLmNvZGVoaWxpdGUgLm1iIHsgY29sb3I6ICMxQzAxQ0UgfSAvKiBMaXRlcmFsLk51bWJlci5CaW4gKi8KLmNvZGVoaWxpdGUgLm1mIHsgY29sb3I6ICMxQzAxQ0UgfSAvKiBMaXRlcmFsLk51bWJlci5GbG9hdCAqLwouY29kZWhpbGl0ZSAubWggeyBjb2xvcjogIzFDMDFDRSB9IC8qIExpdGVyYWwuTnVtYmVyLkhleCAqLwouY29kZWhpbGl0ZSAubWkgeyBjb2xvcjogIzFDMDFDRSB9IC8qIExpdGVyYWwuTnVtYmVyLkludGVnZXIgKi8KLmNvZGVoaWxpdGUgLm1vIHsgY29sb3I6ICMxQzAxQ0UgfSAvKiBMaXRlcmFsLk51bWJlci5PY3QgKi8KLmNvZGVoaWxpdGUgLnNhIHsgY29sb3I6ICNDNDFBMTYgfSAvKiBMaXRlcmFsLlN0cmluZy5BZmZpeCAqLwouY29kZWhpbGl0ZSAuc2IgeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLkJhY2t0aWNrICovCi5jb2RlaGlsaXRlIC5zYyB7IGNvbG9yOiAjMjMwMENFIH0gLyogTGl0ZXJhbC5TdHJpbmcuQ2hhciAqLwouY29kZWhpbGl0ZSAuZGwgeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLkRlbGltaXRlciAqLwouY29kZWhpbGl0ZSAuc2QgeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLkRvYyAqLwouY29kZWhpbGl0ZSAuczIgeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLkRvdWJsZSAqLwouY29kZWhpbGl0ZSAuc2UgeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLkVzY2FwZSAqLwouY29kZWhpbGl0ZSAuc2ggeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLkhlcmVkb2MgKi8KLmNvZGVoaWxpdGUgLnNpIHsgY29sb3I6ICNDNDFBMTYgfSAvKiBMaXRlcmFsLlN0cmluZy5JbnRlcnBvbCAqLwouY29kZWhpbGl0ZSAuc3ggeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLk90aGVyICovCi5jb2RlaGlsaXRlIC5zciB7IGNvbG9yOiAjQzQxQTE2IH0gLyogTGl0ZXJhbC5TdHJpbmcuUmVnZXggKi8KLmNvZGVoaWxpdGUgLnMxIHsgY29sb3I6ICNDNDFBMTYgfSAvKiBMaXRlcmFsLlN0cmluZy5TaW5nbGUgKi8KLmNvZGVoaWxpdGUgLnNzIHsgY29sb3I6ICNDNDFBMTYgfSAvKiBMaXRlcmFsLlN0cmluZy5TeW1ib2wgKi8KLmNvZGVoaWxpdGUgLmJwIHsgY29sb3I6ICM1QjI2OUEgfSAvKiBOYW1lLkJ1aWx0aW4uUHNldWRvICovCi5jb2RlaGlsaXRlIC5mbSB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZS5GdW5jdGlvbi5NYWdpYyAqLwouY29kZWhpbGl0ZSAudmMgeyBjb2xvcjogIzAwMDAwMCB9IC8qIE5hbWUuVmFyaWFibGUuQ2xhc3MgKi8KLmNvZGVoaWxpdGUgLnZnIHsgY29sb3I6ICMwMDAwMDAgfSAvKiBOYW1lLlZhcmlhYmxlLkdsb2JhbCAqLwouY29kZWhpbGl0ZSAudmkgeyBjb2xvcjogIzAwMDAwMCB9IC8qIE5hbWUuVmFyaWFibGUuSW5zdGFuY2UgKi8KLmNvZGVoaWxpdGUgLnZtIHsgY29sb3I6ICMwMDAwMDAgfSAvKiBOYW1lLlZhcmlhYmxlLk1hZ2ljICovCi5jb2RlaGlsaXRlIC5pbCB7IGNvbG9yOiAjMUMwMUNFIH0gLyogTGl0ZXJhbC5OdW1iZXIuSW50ZWdlci5Mb25nICovCiAgICAvKiBwYWdlX2NzcyAqLwoKICAgIAogICAgaHRtbHsKICAgICAgICBiYWNrZ3JvdW5kOiAjMTAxNjFBOwogICAgfQogICAgYm9keXsKICAgICAgICB3aWR0aDogOTAlOwogICAgICAgIG1heC13aWR0aDogOTYwcHg7CiAgICAgICAgYmFja2dyb3VuZDogIzE3MUQyMTsKICAgICAgICBtYXJnaW46IDNlbSBhdXRvIDA7CiAgICAgICAgcGFkZGluZy10b3A6IDJlbTsKICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjMTAxNjFBOwogICAgICAgIGJvcmRlci13aWR0aDogMCAxcHg7CiAgICB9CgogICAgLnBvc3R7CiAgICAgICAgcGFkZGluZzogNSUgMTAlOwogICAgICAgIG1hcmdpbi10b3A6IDA7CiAgICAgICAgbWFyZ2luLWJvdHRvbTogMDsKICAgIH0KICAgIAoKICAgIC50aXRsZV9jb250YWluZXJ7CiAgICAgICAgbWFyZ2luOiAtMmVtIDAgMy41ZW07CiAgICAgICAgcGFkZGluZy1ib3R0b206IDJlbTsKICAgICAgICBib3JkZXItYm90dG9tOiAzcHggZG91YmxlICMxMDE2MUE7CiAgICB9CiAgICAudGl0bGVfY29udGFpbmVyIGgxewogICAgICAgIG1hcmdpbi10b3A6IDEuMmVtOwogICAgICAgIG1hcmdpbi1ib3R0b206IDAuNmVtOwogICAgICAgIGxpbmUtaGVpZ2h0OiAxLjM1OwogICAgICAgIGZvbnQtc2l6ZTogMi4yNWVtOwogICAgfQogICAgLnRpdGxlX2NvbnRhaW5lciBoMnsKICAgICAgICBjb2xvcjogIzlBOUE5QTsKICAgICAgICBmb250LXNpemU6IDFlbTsKICAgICAgICBmb250LXdlaWdodDogbm9ybWFsOwogICAgICAgIHBhZGRpbmctYm90dG9tOiAyZW07CiAgICAgICAgbGluZS1oZWlnaHQ6IDEuMzU7CiAgICAgICAgbWFyZ2luLWJvdHRvbTogLTJlbTsKICAgIH0KCiAgICBAbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDc2MHB4KXsKICAgICAgICBodG1sewogICAgICAgICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDsKICAgICAgICB9CiAgICAgICAgYm9keXsKICAgICAgICAgICAgbWFyZ2luOiAwOwogICAgICAgIH0KICAgICAgICAucG9zdHsKICAgICAgICAgICAgcGFkZGluZzogMDsKICAgICAgICB9CiAgICB9CiAgICAvKiBwYWdlX2NzcyAqLwoKICAgIA==">
    <!--header_scripts-->
</head>
<body>
    <div class="post">
        <div class="post_body">
            
            <h1 id="toc_0" class="h16 md_first_h"><span class="span_for_h">表达式（Expressions）</span></h1>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">Swift 中存在四种表达式：前缀表达式，二元表达式，基本表达式和后缀表达式。表达式在返回一个值的同时还可以引发副作用。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">通过前缀表达式和二元表达式可以对简单表达式使用各种运算符。基本表达式从概念上讲是最简单的一种表达式，它是一种访问值的方式。后缀表达式则允许你建立复杂的表达式，例如函数调用和成员访问。每种表达式都在下面有详细论述。</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">表达式语法<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_1" class="h16"><span class="span_for_h">expression {#expression}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<em>表达式</em> → <a class="md_compiled" href="#try-operator">try 运算符</a><sub>可选</sub> <a class="md_compiled" href="#prefix-expression">前缀表达式</a> <a class="md_compiled" href="#binary-expressions">二元表达式列表</a><sub>可选</sub>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_2" class="h16"><span class="span_for_h">expression-list {#expression-list}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<em>表达式列表</em> → <a class="md_compiled" href="#expression">表达式</a> | <a class="md_compiled" href="#expression">表达式</a> <strong>,</strong> <a class="md_compiled" href="#expression-list">表达式列表</a>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h2 id="toc_3" class="h16"><span class="span_for_h">前缀表达式 {#prefix-expressions}</span></h2>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">前缀表达式由可选的前缀运算符和表达式组成。前缀运算符只接收一个参数，表达式则紧随其后。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">关于这些运算符的更多信息，请参阅 <a class="md_compiled" href="../02_language_guide/02_Basic_Operators.md">基本运算符</a> 和 <a class="md_compiled" href="../02_language_guide/27_Advanced_Operators.md">高级运算符</a>。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">关于 Swift 标准库提供的运算符的更多信息，请参阅 <a class="md_compiled" href="https://developer.apple.com/documentation/swift/operator_declarations"><em>Operators Declarations</em></a>。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">除了标准库运算符，你也可以对某个变量使用 <code>&amp;</code> 运算符，从而将其传递给函数的输入输出参数。更多信息，请参阅 <a class="md_compiled" href="../02_language_guide/06_Functions.md#in-out-parameters">输入输出参数</a>。</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start">前缀表达式语法<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_4" class="h16"><span class="span_for_h">prefix-expression {#prefix-expression}</span></h4>

<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
<em>前缀表达式</em> → <a class="md_compiled" href="./02_Lexical_Structure.md#prefix-operator">前缀运算符</a><sub>可选</sub> <a class="md_compiled" href="#postfix-expression">后缀表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<em>前缀表达式</em> → <a class="md_compiled" href="#in-out-expression">输入输出表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_5" class="h16"><span class="span_for_h">in-out-expression {#in-out-expression}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<em>输入输出表达式</em> → <strong>&amp;</strong> <a class="md_compiled" href="./02_Lexical_Structure.md#identifier">标识符</a>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h3 id="toc_6" class="h16"><span class="span_for_h">Try 运算符 {#try-operator}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">try 表达式由 <code>try</code> 运算符加上紧随其后的可抛出错误的表达式组成，形式如下：</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start">try <code>可抛出错误的表达式</code><br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">可选的 try 表达式由 <code>try?</code> 运算符加上紧随其后的可抛出错误的表达式组成，形式如下：</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">try? <code>可抛出错误的表达式</code><br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">如果可抛出错误的表达式没有抛出错误，整个表达式返回的可选值将包含可抛出错误的表达式的返回值，否则，该可选值为 <code>nil</code>。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">强制的 try 表达式由 <code>try!</code> 运算符加上紧随其后的可抛出错误的表达式组成，形式如下：</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">try! <code>可抛出错误的表达式</code><br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">如果可抛出错误的表达式抛出了错误，将会引发运行时错误。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">在二元运算符左侧的表达式被标记上 <code>try</code>、<code>try?</code> 或者 <code>try!</code> 时，这个运算符对整个二元表达式都产生作用。也就是说，你可以使用括号来明确运算符的作用范围。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="n">sum</span> <span class="p">=</span> <span class="k">try</span> <span class="n">someThrowingFunction</span><span class="p">()</span> <span class="o">+</span> <span class="n">anotherThrowingFunction</span><span class="p">()</span>   <span class="c1">// try 对两个函数调用都产生作用</span>
<span class="n">sum</span> <span class="p">=</span> <span class="k">try</span> <span class="p">(</span><span class="n">someThrowingFunction</span><span class="p">()</span> <span class="o">+</span> <span class="n">anotherThrowingFunction</span><span class="p">())</span> <span class="c1">// try 对两个函数调用都产生作用</span>
<span class="n">sum</span> <span class="p">=</span> <span class="p">(</span><span class="k">try</span> <span class="n">someThrowingFunction</span><span class="p">())</span> <span class="o">+</span> <span class="n">anotherThrowingFunction</span><span class="p">()</span> <span class="c1">// 错误：try 只对第一个函数调用产生作用</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end"><code>try</code> 表达式不能出现在二元运算符的的右侧，除非二元运算符是赋值运算符或者 <code>try</code> 表达式是被圆括号括起来的。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">关于 <code>try</code>、<code>try?</code> 和 <code>try!</code> 的更多信息，以及该如何使用的例子，请参阅 <a class="md_compiled" href="../02_language_guide/17_Error_Handling.md">错误处理</a>。</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start">Try 表达式语法<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_7" class="h16"><span class="span_for_h">try-operator {#try-operator}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<em>try 运算符</em> → <strong>try</strong> | <strong>try?</strong> | <strong>try!</strong>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h2 id="toc_8" class="h16"><span class="span_for_h">二元表达式 {#binary-expressions}</span></h2>

<p class="md_block">
    <span class="md_line md_line_start md_line_end"><em>二元表达式</em>由中缀运算符和左右参数表达式组成。形式如下：</span>
</p>


<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<code>左侧参数</code> <code>二元运算符</code> <code>右侧参数</code>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">关于这些运算符的更多信息，请参阅 <a class="md_compiled" href="../02_language_guide/02_Basic_Operators.md">基本运算符</a> 和 <a class="md_compiled" href="../02_language_guide/27_Advanced_Operators.md">高级运算符</a>。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">关于 Swift 标准库提供的运算符的更多信息，请参阅 <a class="md_compiled" href="https://developer.apple.com/documentation/swift/operator_declarations"><em>Swift Standard Library Operators Reference</em></a>。</span>
</p>


<blockquote class="blockquote_lines_4 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start">注意<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line">在解析时，一个二元表达式将作为一个扁平列表表示，然后根据运算符的优先级，再进一步进行组合。例如，<code>2 + 3 &#42; 5</code> 首先被看作具有五个元素的列表，即 <code>2</code>、<code>+</code>、<code>3</code>、<code>&#42;</code>、<code>5</code>，随后根据运算符优先级组合为 <code>(2 + (3 &#42; 5))</code>。<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_9" class="h16"><span class="span_for_h">binary-expression {#binary-expression}</span></h4>

<blockquote class="blockquote_lines_6 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">二元表达式语法<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<em>二元表达式</em> → <a class="md_compiled" href="./02_Lexical_Structure.md#binary-operator">二元运算符</a> <a class="md_compiled" href="#prefix-expression">前缀表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<em>二元表达式</em> → <a class="md_compiled" href="#assignment-operator">赋值运算符</a> <a class="md_compiled" href="#try-operator">try 运算符</a><sub>可选</sub> <a class="md_compiled" href="#prefix-expression">前缀表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<em>二元表达式</em> → <a class="md_compiled" href="#conditional-operator">条件运算符</a> <a class="md_compiled" href="#try-operator">try 运算符</a><sub>可选</sub> <a class="md_compiled" href="#prefix-expression">前缀表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<em>二元表达式</em> → <a class="md_compiled" href="#type-casting-operator">类型转换运算符</a>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_10" class="h16"><span class="span_for_h">binary-expressions {#binary-expressions}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<em>二元表达式列表</em> → <a class="md_compiled" href="#binary-expression">二元表达式</a> <a class="md_compiled" href="#binary-expressions">二元表达式列表</a><sub>可选</sub>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h3 id="toc_11" class="h16"><span class="span_for_h">赋值表达式 {#assignment-operator}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">赋值表达式会为某个给定的表达式赋值，形式如下；</span>
</p>


<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_code_block">
<code>表达式</code> = <code>值</code>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">右边的值会被赋值给左边的表达式。如果左边表达式是一个元组，那么右边必须是一个具有同样元素个数的元组。（嵌套元组也是允许的。）右边的值中的每一部分都会被赋值给左边的表达式中的相应部分。例如：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">_</span><span class="p">,</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span> <span class="p">=</span> <span class="p">(</span><span class="s">&quot;test&quot;</span><span class="p">,</span> <span class="mf">9.45</span><span class="p">,</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="c1">// a 为 &quot;test&quot;，b 为 12，c 为 3，9.45 会被忽略</span>
</pre></div>

<!--block_code_end-->
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">赋值运算符不返回任何值。</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start">赋值运算符语法<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_12" class="h16"><span class="span_for_h">assignment-operator {#assignment-operator}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<em>赋值运算符</em> → <strong>=</strong>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h3 id="toc_13" class="h16"><span class="span_for_h">三元条件运算符 {#ternary-conditional-operator}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end"><em>三元条件运算符</em>会根据条件来对两个给定表达式中的一个进行求值，形式如下：</span>
</p>


<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<code>条件</code> ? <code>表达式（条件为真则使用）</code> : <code>表达式（条件为假则使用）</code>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">如果条件为真，那么对第一个表达式进行求值并返回结果。否则，对第二个表达式进行求值并返回结果。未使用的表达式不会进行求值。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">关于使用三元条件运算符的例子，请参阅 <a class="md_compiled" href="../02_language_guide/02_Basic_Operators.md#ternary-conditional-operator">三元条件运算符</a>。</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start">三元条件运算符语法<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_14" class="h16"><span class="span_for_h">conditional-operator {#conditional-operator}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<em>三元条件运算符</em> → <strong>?</strong> <a class="md_compiled" href="#expression">表达式</a> <strong>:</strong>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h3 id="toc_15" class="h16"><span class="span_for_h">类型转换运算符 {#type-casting-operators}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">有 4 种类型转换运算符：<code>is</code>、<code>as</code>、<code>as?</code> 和 <code>as!</code>。它们有如下的形式：</span>
</p>


<blockquote class="blockquote_lines_4 blockquote_without_image">
<p class="md_block">
<code>表达式</code> is <code>类型</code>
    <span class="md_line">&nbsp;<br /></span>
<code>表达式</code> as <code>类型</code>
    <span class="md_line">&nbsp;<br /></span>
<code>表达式</code> as? <code>类型</code>
    <span class="md_line">&nbsp;<br /></span>
<code>表达式</code> as! <code>类型</code>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end"><code>is</code> 运算符在运行时检查表达式能否向下转化为指定的类型，如果可以则返回 <code>ture</code>，否则返回 <code>false</code>。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end"><code>as</code> 运算符在编译时执行向上转换和桥接。向上转换可将表达式转换成父类的实例而无需使用任何中间变量。以下表达式是等价的：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">f</span><span class="p">(</span><span class="n">any</span><span class="p">:</span> <span class="nb">Any</span><span class="p">)</span> <span class="p">{</span> <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Function for Any&quot;</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nf">f</span><span class="p">(</span><span class="n">int</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span> <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Function for Int&quot;</span><span class="p">)</span> <span class="p">}</span>
<span class="kd">let</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">10</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="c1">// 打印“Function for Int”</span>

<span class="kd">let</span> <span class="nv">y</span><span class="p">:</span> <span class="nb">Any</span> <span class="p">=</span> <span class="n">x</span>
<span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="c1">// 打印“Function for Any”</span>

<span class="n">f</span><span class="p">(</span><span class="n">x</span> <span class="k">as</span> <span class="nb">Any</span><span class="p">)</span>
<span class="c1">// 打印“Function for Any”</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">桥接可将 Swift 标准库中的类型（例如 <code>String</code>）作为一个与之相关的 Foundation 类型（例如 <code>NSString</code>）来使用，而不需要新建一个实例。关于桥接的更多信息，请参阅 <a class="md_compiled" href="https://developer.apple.com/documentation/swift/imported_c_and_objective_c_apis/working_with_foundation_types"><em>Working with Foundation Types</em></a>。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end"><code>as?</code> 运算符有条件地执行类型转换，返回目标类型的可选值。在运行时，如果转换成功，返回的可选值将包含转换后的值，否则返回 <code>nil</code>。如果在编译时就能确定转换一定会成功或是失败，则会导致编译报错。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end"><code>as!</code> 运算符执行强制类型转换，返回目标类型的非可选值。如果转换失败，则会导致运行时错误。表达式 <code>x as! T</code> 效果等同于 <code>(x as? T)!</code>。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">关于类型转换的更多内容和例子，请参阅 <a class="md_compiled" href="../02_language_guide/18_Type_Casting.md">类型转换</a>。</span>
</p>

<span class="md_repeated_n md_repeated_n_1"></span><h4 id="toc_16" class="h16"><span class="span_for_h">type-casting-operator {#type-casting-operator}</span></h4>

<blockquote class="blockquote_lines_6 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start">类型转换运算符语法<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<em>类型转换运算符</em> → <strong>is</strong> <a class="md_compiled" href="./03_Types.md#type">类型</a>
    <span class="md_line">&nbsp;<br /></span>
<em>类型转换运算符</em> → <strong>as</strong> <a class="md_compiled" href="./03_Types.md#type">类型</a>
    <span class="md_line">&nbsp;<br /></span>
<em>类型转换运算符</em> → <strong>as</strong> <strong>?</strong> <a class="md_compiled" href="./03_Types.md#type">类型</a>
    <span class="md_line">&nbsp;<br /></span>
<em>类型转换运算符</em> → <strong>as</strong> <strong>!</strong> <a class="md_compiled" href="./03_Types.md#type">类型</a>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h2 id="toc_17" class="h16"><span class="span_for_h">基本表达式 {#primary-expressions}</span></h2>

<p class="md_block">
    <span class="md_line md_line_start md_line_end"><em>基本表达式</em>是最基本的表达式。它们可以单独使用，也可以跟前缀表达式、二元表达式、后缀表达式组合使用。</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">基本表达式语法<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_18" class="h16"><span class="span_for_h">primary-expression {#primary-expression}</span></h4>

<blockquote class="blockquote_lines_10 blockquote_without_image">
<p class="md_block">
<em>基本表达式</em> → <a class="md_compiled" href="./02_Lexical_Structure.md#identifier">标识符</a> <a class="md_compiled" href="./09-Generic-Parameters-and-Arguments.md#generic-argument-clause">泛型实参子句</a><sub>可选</sub>
    <span class="md_line">&nbsp;<br /></span>
<em>基本表达式</em> → <a class="md_compiled" href="#literal-expression">字面量表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<em>基本表达式</em> → <a class="md_compiled" href="#self-expression">self 表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<em>基本表达式</em> → <a class="md_compiled" href="#superclass-expression">父类表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<em>基本表达式</em> → <a class="md_compiled" href="#closure-expression">闭包表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<em>基本表达式</em> → <a class="md_compiled" href="#parenthesized-expression">圆括号表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<em>基本表达式</em> → <a class="md_compiled" href="#implicit-member-expression">隐式成员表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<em>基本表达式</em> → <a class="md_compiled" href="#wildcard-expression">通配符表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<em>基本表达式</em> → <a class="md_compiled" href="#selector-expression">选择器表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<em>基本表达式</em> → <a class="md_compiled" href="#key-patch-string-expression">key-path字符串表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h3 id="toc_19" class="h16"><span class="span_for_h">字面量表达式 {#literal-expression}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end"><em>字面量表达式</em>可由普通字面量（例如字符串或者数字），字典或者数组字面量，或者下面列表中的特殊字面量组成：</span>
</p>


<table>
<thead>
<tr>
<th style="text-align: left">字面量</th>
<th style="text-align: left">类型</th>
<th style="text-align: left">值</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: left"><code>#file</code></td>
<td style="text-align: left"><code>String</code></td>
<td style="text-align: left">所在的文件名</td>
</tr>
<tr>
<td style="text-align: left"><code>#line</code></td>
<td style="text-align: left"><code>Int</code></td>
<td style="text-align: left">所在的行数</td>
</tr>
<tr>
<td style="text-align: left"><code>#column</code></td>
<td style="text-align: left"><code>Int</code></td>
<td style="text-align: left">所在的列数</td>
</tr>
<tr>
<td style="text-align: left"><code>#function</code></td>
<td style="text-align: left"><code>String</code></td>
<td style="text-align: left">所在的声明的名字</td>
</tr>
</tbody>
</table>
<span class="md_repeated_n md_repeated_n_1"></span>
<p class="md_block">
    <span class="md_line md_line_start md_line_end">对于 <code>#function</code>，在函数中会返回当前函数的名字，在方法中会返回当前方法的名字，在属性的存取器中会返回属性的名字，在特殊的成员如 <code>init</code> 或 <code>subscript</code> 中会返回这个关键字的名字，在某个文件中会返回当前模块的名字。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">当其作为函数或者方法的默认参数值时，该字面量的值取决于函数或方法的调用环境。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">logFunctionName</span><span class="p">(</span><span class="n">string</span><span class="p">:</span> <span class="nb">String</span> <span class="p">=</span> <span class="kc">#function</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">myFunction</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">logFunctionName</span><span class="p">()</span>
<span class="p">}</span>
<span class="n">myFunction</span><span class="p">()</span> <span class="c1">// 打印“myFunction()”</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">数组字面量是值的有序集合，形式如下：</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start">[<code>值 1</code>, <code>值 2</code>, <code>...</code>]<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">数组中的最后一个表达式可以紧跟一个逗号。数组字面量的类型是 <code>[T]</code>，这个 <code>T</code> 就是数组中元素的类型。如果数组中包含多种类型，<code>T</code> 则是跟这些类型最近的的公共父类型。空数组字面量由一组方括号定义，可用来创建特定类型的空数组。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">var</span> <span class="nv">emptyArray</span><span class="p">:</span> <span class="p">[</span><span class="nb">Double</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">字典字面量是一个包含无序键值对的集合，形式如下：</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start">[<code>键 1</code> : <code>值 1</code>, <code>键 2</code> : <code>值 2</code>, <code>...</code>]<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">字典中的最后一个表达式可以紧跟一个逗号。字典字面量的类型是 <code>[Key : Value]</code>，<code>Key</code> 表示键的类型，<code>Value</code> 表示值的类型。如果字典中包含多种类型，那么 <code>Key</code> 表示的类型则为所有键最接近的公共父类型，<code>Value</code> 与之相似。一个空的字典字面量由方括号中加一个冒号组成（<code>[:]</code>），从而与空数组字面量区分开，可以使用空字典字面量来创建特定类型的字典。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">var</span> <span class="nv">emptyDictionary</span><span class="p">:</span> <span class="p">[</span><span class="nb">String</span> <span class="p">:</span> <span class="nb">Double</span><span class="p">]</span> <span class="p">=</span> <span class="p">[:]</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">Xcode 使用 playground 字面量对程序编辑器中的颜色、文件或者图片创建可交互的展示。在 Xcode 之外的空白文本中，playground 字面量使用一种特殊的字面量语法来展示。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">更多关于在 Xcode 中使用 playground 字面量的信息，请参阅 <a class="md_compiled" href="https://help.apple.com/xcode/mac/current/#/dev4c60242fc">添加颜色、文件或图片字面量</a>。</span>
</p>


<blockquote class="blockquote_lines_3 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">字面量表达式语法<br /></span>
    <span class="md_line md_line_end">&nbsp;</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_20" class="h16"><span class="span_for_h">literal-expression {#literal-expression}</span></h4>

<blockquote class="blockquote_lines_5 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<em>字面量表达式</em> → <a class="md_compiled" href="./02_Lexical_Structure.md#literal">字面量</a>
    <span class="md_line">&nbsp;<br /></span>
<em>字面量表达式</em> → <a class="md_compiled" href="#array-literal">数组字面量</a> | <a class="md_compiled" href="#dictionary-literal">字典字面量</a> | <a class="md_compiled" href="#playground-literal">练习场字面量</a>
    <span class="md_line">&nbsp;<br /></span>
<em>字面量表达式</em> → <strong>#file</strong> | <strong>#line</strong> | <strong>#column</strong> | <strong>#function</strong>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>


<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_21" class="h16"><span class="span_for_h">array-literal {#array-literal}</span></h4>

<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<em>数组字面量</em> → [<a class="md_compiled" href="#array-literal-items">数组字面量项列表</a><sub>可选</sub> <strong>]</strong>
    <span class="md_line md_line_end">&nbsp;</span>
</p>

</blockquote>
<h4 id="toc_22" class="h16"><span class="span_for_h">array-literal-items {#array-literal-items}</span></h4>

<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<em>数组字面量项列表</em> → <a class="md_compiled" href="#array-literal-item">数组字面量项</a> <strong>,</strong><sub>可选</sub> | <a class="md_compiled" href="#array-literal-item">数组字面量项</a> <strong>,</strong> <a class="md_compiled" href="#array-literal-items">数组字面量项列表</a>
    <span class="md_line md_line_end">&nbsp;</span>
</p>

</blockquote>
<h4 id="toc_23" class="h16"><span class="span_for_h">array-literal-item {#array-literal-item}</span></h4>

<blockquote class="blockquote_lines_3 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<em>数组字面量项</em> → <a class="md_compiled" href="#expression">表达式</a>
    <span class="md_line md_line_end">&nbsp;</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_24" class="h16"><span class="span_for_h">dictionary-literal {#dictionary-literal}</span></h4>

<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<em>字典字面量</em> → [<a class="md_compiled" href="#dictionary-literal-items">字典字面量项列表</a> <strong>]</strong> | <strong>[</strong> <strong>:</strong> <strong>]</strong>
    <span class="md_line md_line_end">&nbsp;</span>
</p>

</blockquote>
<h4 id="toc_25" class="h16"><span class="span_for_h">dictionary-literal-items {#dictionary-literal-items}</span></h4>

<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<em>字典字面量项列表</em> → <a class="md_compiled" href="#dictionary-literal-item">字典字面量项</a> <strong>,</strong><sub>可选</sub> | <a class="md_compiled" href="#dictionary-literal-item">字典字面量项</a> <strong>,</strong> <a class="md_compiled" href="#dictionary-literal-items">字典字面量项列表</a>
    <span class="md_line md_line_end">&nbsp;</span>
</p>

</blockquote>
<h4 id="toc_26" class="h16"><span class="span_for_h">dictionary-literal-item {#dictionary-literal-item}</span></h4>

<blockquote class="blockquote_lines_3 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
    <span class="md_line"><em>字典字面量项</em> → <a class="md_compiled" href="#expression">表达式</a> <strong>:</strong> <a class="md_compiled" href="#expression">表达式</a>。<br /></span>
    <span class="md_line md_line_end">&nbsp;</span>
</p>

</blockquote>
<h4 id="toc_27" class="h16"><span class="span_for_h">playground-literal {#playground-literal}</span></h4>

<blockquote class="blockquote_lines_3 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<em>playground 字面量</em> → <strong>#colorLiteral ( red :  <a class="md_compiled" href="#expression">表达式</a> , green :<a class="md_compiled" href="#expression">表达式</a> <a class="md_compiled" href="#e[%2A%E8%A1%A8%E8%BE%BE%E5%BC%8F%2A]%28#expression%29%20xpression">表达式</a> ,  blue :<a class="md_compiled" href="#expression">表达式</a> , alpha : <a class="md_compiled" href="#expression">表达式</a> )</strong>
    <span class="md_line">&nbsp;<br /></span>
<em>playground 字面量</em> → <strong>#fileLiteral ( resourceName : <a class="md_compiled" href="#expression">表达式</a> )</strong>
    <span class="md_line md_line_end">&nbsp;</span>
</p>

<h4 id="toc_28" class="h16"><span class="span_for_h">playground 字面量* → <strong>#imageLiteral ( resourceName : <a class="md_compiled" href="#expression">表达式</a> )</strong>self-expression {#self-expression}</span></h4>
</blockquote>
<h3 id="toc_29" class="h16"><span class="span_for_h">Self 表达式</span></h3>

<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end"><code>self</code> 表达式是对当前类型或者当前实例的显式引用，它有如下形式：</span>
</p>


<blockquote class="blockquote_lines_10 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">self<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line">self.<code>成员名称</code><br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span style='font-family:下标索引'  class="md_line">self[<code>下标索引</code>]<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line">self(<code>构造器参数</code>)<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line">self.init(<code>构造器参数</code>)<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">如果在构造器、下标、实例方法中，<code>self</code> 引用的是当前类型的实例。在一个类型方法中，<code>self</code> 引用的是当前的类型。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">当访问成员时，<code>self</code> 可用来区分重名变量，例如函数的参数：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">class</span> <span class="nc">SomeClass</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">greeting</span><span class="p">:</span> <span class="nb">String</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">greeting</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">greeting</span> <span class="p">=</span> <span class="n">greeting</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">在 <code>mutating</code> 方法中，你可以对 <code>self</code> 重新赋值：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">Point</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="p">=</span> <span class="mf">0.0</span>
    <span class="kr">mutating</span> <span class="kd">func</span> <span class="nf">moveByX</span><span class="p">(</span><span class="n">deltaX</span><span class="p">:</span> <span class="nb">Double</span><span class="p">,</span> <span class="n">y</span> <span class="n">deltaY</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span> <span class="p">=</span> <span class="n">Point</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">deltaX</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span> <span class="o">+</span> <span class="n">deltaY</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">Self 表达式语法<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_30" class="h16"><span class="span_for_h">self-expression {#self-expression}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<em>self 表达式</em> → <strong>self</strong>  | <a class="md_compiled" href="#self-method-expression">self 方法表达式</a> ｜ <a class="md_compiled" href="#self-subscript-expression">self 下标表达式</a> | <a class="md_compiled" href="#self-initializer-expression">self 构造器表达式</a>
    <span class="md_line md_line_end">&nbsp;</span>
</p>

</blockquote>
<h4 id="toc_31" class="h16"><span class="span_for_h">self-method-expression {#self-method-expression}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
<em>self 方法表达式</em> → <strong>self</strong> <strong>.</strong> <a class="md_compiled" href="./02_Lexical_Structure.md#identifier">标识符</a>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_32" class="h16"><span class="span_for_h">self-subscript-expression {#self-subscript-expression}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<em>self 下标表达式</em> → <strong>self</strong> <strong>[</strong> <a class="md_compiled" href="#function-call-argument-list">函数调用参数表</a> <strong>]</strong>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_33" class="h16"><span class="span_for_h">self-initializer-expression {#self-initializer-expression}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<em>self 构造器表达式</em> → <strong>self</strong> <strong>.</strong> <strong>init</strong>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h3 id="toc_34" class="h16"><span class="span_for_h">父类表达式 {#superclass-expression}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end"><em>父类</em>表达式可以使我们在某个类中访问它的父类，它有如下形式：</span>
</p>


<blockquote class="blockquote_lines_6 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">super.<code>成员名称</code><br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span style='font-family:下标索引'  class="md_line">super[<code>下标索引</code>]<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line">super.init(<code>构造器参数</code>)<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">第一种形式用来访问父类的某个成员，第二种形式用来访问父类的下标，第三种形式用来访问父类的构造器。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">子类可以通过父类表达式在它们的成员、下标和构造器中使用父类中的实现。</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start">父类表达式语法<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_35" class="h16"><span class="span_for_h">superclass-expression {#superclass-expression}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<em>父类表达式</em> → <a class="md_compiled" href="#superclass-method-expression">父类方法表达式</a> | <a class="md_compiled" href="#superclass-subscript-expression">父类下标表达式</a> | <a class="md_compiled" href="#superclass-initializer-expression">父类构造器表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_36" class="h16"><span class="span_for_h">superclass-method-expression {#superclass-method-expression}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<em>父类方法表达式</em> → <strong>super</strong> <strong>.</strong> <a class="md_compiled" href="./02_Lexical_Structure.md#identifier">标识符</a>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_37" class="h16"><span class="span_for_h">superclass-subscript-expression {#superclass-subscript-expression}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<em>父类下标表达式</em> → <strong>super</strong> [<a class="md_compiled" href="#function-call-argument-list">函数调用参数表</a> <strong>]</strong>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_38" class="h16"><span class="span_for_h">superclass-initializer-expression {#superclass-initializer-expression}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<em>父类构造器表达式</em> → <strong>super</strong> <strong>.</strong> <strong>init</strong>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h3 id="toc_39" class="h16"><span class="span_for_h">闭包表达式 {#closure-expression}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end"><em>闭包表达式</em>会创建一个闭包，在其他语言中也叫 <em>lambda</em> 或<em class="md_patched_em">匿名</em>函数。跟函数一样，闭包包含了待执行的代码，不同的是闭包还会捕获所在环境中的常量和变量。它的形式如下：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="p">{</span> <span class="p">(</span><span class="n">parameters</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="k">return</span> <span class="n">type</span> <span class="k">in</span>
    <span class="n">statements</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">闭包的参数声明形式跟函数一样，请参阅 <a class="md_compiled" href="./06_Declarations.md#function-declaration">函数声明</a>。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_ul">
    <span class="md_line md_line_start md_line_end">闭包还有几种特殊的形式，能让闭包使用起来更加简洁：</span>
</p>


<ul>
<li class="md_li"><span>闭包可以省略它的参数和返回值的类型。如果省略了参数名和所有的类型，也要省略 <code>in</code> 关键字。如果被省略的类型无法被编译器推断，那么就会导致编译错误。

</span></li>
<li class="md_li"><span>闭包可以省略参数名，参数会被隐式命名为 <code>$</code> 加上其索引位置，例如 <code>$0</code>、<code>$1</code>、<code>$2</code> 分别表示第一个、第二个、第三个参数，以此类推。

</span></li>
<li class="md_li"><span>如果闭包中只包含一个表达式，那么该表达式的结果就会被视为闭包的返回值。表达式结果的类型也会被推断为闭包的返回类型。

</span></li>
</ul>

<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">下面几个闭包表达式是等价的：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="n">myFunction</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="k">in</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="p">}</span>

<span class="n">myFunction</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">in</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="p">}</span>

<span class="n">myFunction</span> <span class="p">{</span> <span class="k">return</span> <span class="nv">$0</span> <span class="o">+</span> <span class="nv">$1</span> <span class="p">}</span>

<span class="n">myFunction</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">+</span> <span class="nv">$1</span> <span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">关于如何将闭包作为参数来传递的内容，请参阅 <a class="md_compiled" href="#function-call-expression">函数调用表达式</a>。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">使用闭包表达式时，可以不必将其存储在一个变量或常量中，例如作为函数调用的一部分来立即使用一个闭包。在上面的例子中，传入 <code>myFunction</code> 的闭包表达式就是这种立即使用类型的闭包。因此，一个闭包是否逃逸与其使用时的上下文相关。一个会被立即调用或者作为函数的非逃逸参数传递的闭包表达式是非逃逸的，否则，这个闭包表达式是逃逸的。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">关于逃逸闭包的内容，请参阅 <a class="md_compiled" href="./02_language_guide/07_Closures.md#escaping-closures">逃逸闭包</a>。</span>
</p>

<h2 id="toc_40" class="h16"><span class="span_for_h">捕获列表 {#capture-lists}</span></h2>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">默认情况下，闭包会捕获附近作用域中的常量和变量，并使用强引用指向它们。你可以通过一个<em class="md_patched_em">捕获列表</em>来显式指定它的捕获行为。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">捕获列表在参数列表之前，由中括号括起来，里面是由逗号分隔的一系列表达式。一旦使用了捕获列表，就必须使用 <code>in</code> 关键字，即使省略了参数名、参数类型和返回类型。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">捕获列表中的项会在闭包创建时被初始化。每一项都会用闭包附近作用域中的同名常量或者变量的值初始化。例如下面的代码示例中，捕获列表包含 <code>a</code> 而不包含 <code>b</code>，这将导致这两个变量具有不同的行为。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">var</span> <span class="nv">a</span> <span class="p">=</span> <span class="mi">0</span>
<span class="kd">var</span> <span class="nv">b</span> <span class="p">=</span> <span class="mi">0</span>
<span class="kd">let</span> <span class="nv">closure</span> <span class="p">=</span> <span class="p">{</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">in</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">a</span> <span class="p">=</span> <span class="mi">10</span>
<span class="n">b</span> <span class="p">=</span> <span class="mi">10</span>
<span class="n">closure</span><span class="p">()</span>
<span class="c1">// 打印“0 10”</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">在示例中，变量 <code>b</code> 只有一个，然而，变量 <code>a</code> 有两个，一个在闭包外，一个在闭包内。闭包内的变量 <code>a</code> 会在闭包创建时用闭包外的变量 <code>a</code> 的值来初始化，除此之外它们并无其他联系。这意味着在闭包创建后，改变某个 <code>a</code> 的值都不会对另一个 <code>a</code> 的值造成任何影响。与此相反，闭包内外都是同一个变量 <code>b</code>，因此在闭包外改变其值，闭包内的值也会受影响。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">如果闭包捕获的值具有引用语义则有所不同。例如，下面示例中，有两个变量 <code>x</code>，一个在闭包外，一个在闭包内，由于它们的值是引用语义，虽然这是两个不同的变量，它们却都引用着同一实例。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">class</span> <span class="nc">SimpleClass</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">value</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="n">SimpleClass</span><span class="p">()</span>
<span class="kd">var</span> <span class="nv">y</span> <span class="p">=</span> <span class="n">SimpleClass</span><span class="p">()</span>
<span class="kd">let</span> <span class="nv">closure</span> <span class="p">=</span> <span class="p">{</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">in</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">y</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">x</span><span class="p">.</span><span class="n">value</span> <span class="p">=</span> <span class="mi">10</span>
<span class="n">y</span><span class="p">.</span><span class="n">value</span> <span class="p">=</span> <span class="mi">10</span>
<span class="n">closure</span><span class="p">()</span>
<span class="c1">// 打印“10 10”</span>
</pre></div>

<!--block_code_end-->
<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">如果捕获列表中的值是类类型，你可以使用 <code>weak</code> 或者 <code>unowned</code> 来修饰它，闭包会分别用弱引用和无主引用来捕获该值。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="n">myFunction</span> <span class="p">{</span> <span class="bp">print</span><span class="p">(</span><span class="kc">self</span><span class="p">.</span><span class="n">title</span><span class="p">)</span> <span class="p">}</span>                    <span class="c1">// 隐式强引用捕获</span>
<span class="n">myFunction</span> <span class="p">{</span> <span class="p">[</span><span class="kc">self</span><span class="p">]</span> <span class="k">in</span> <span class="bp">print</span><span class="p">(</span><span class="kc">self</span><span class="p">.</span><span class="n">title</span><span class="p">)</span> <span class="p">}</span>             <span class="c1">// 显式强引用捕获</span>
<span class="n">myFunction</span> <span class="p">{</span> <span class="p">[</span><span class="kr">weak</span> <span class="kc">self</span><span class="p">]</span> <span class="k">in</span> <span class="bp">print</span><span class="p">(</span><span class="kc">self</span><span class="p">!.</span><span class="n">title</span><span class="p">)</span> <span class="p">}</span>   <span class="c1">// 弱引用捕获</span>
<span class="n">myFunction</span> <span class="p">{</span> <span class="p">[</span><span class="kr">unowned</span> <span class="kc">self</span><span class="p">]</span> <span class="k">in</span> <span class="bp">print</span><span class="p">(</span><span class="kc">self</span><span class="p">.</span><span class="n">title</span><span class="p">)</span> <span class="p">}</span> <span class="c1">// 无主引用捕获</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">在捕获列表中，也可以将任意表达式的值绑定到一个常量上。该表达式会在闭包被创建时进行求值，闭包会按照指定的引用类型来捕获表达式的值。例如：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="c1">// 以弱引用捕获 self.parent 并赋值给 parent</span>
<span class="n">myFunction</span> <span class="p">{</span> <span class="p">[</span><span class="kr">weak</span> <span class="n">parent</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">parent</span><span class="p">]</span> <span class="k">in</span> <span class="bp">print</span><span class="p">(</span><span class="n">parent</span><span class="p">!.</span><span class="n">title</span><span class="p">)</span> <span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">关于闭包表达式的更多信息和例子，请参阅 <a class="md_compiled" href="../02_language_guide/07_Closures.md#closure-expressions">闭包表达式</a>。关于捕获列表的更多信息和例子，请参阅 <a class="md_compiled" href="../02-language-guide/24-Automatic-Reference-Counting.md#resolving-strong-reference-cycles-for-closures">解决闭包引起的循环强引用</a>。</span>
</p>


<blockquote class="blockquote_lines_3 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">闭包表达式语法<br /></span>
    <span class="md_line md_line_end">&nbsp;</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_41" class="h16"><span class="span_for_h">closure-expression {#closure-expression}</span></h4>

<blockquote class="blockquote_lines_3 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<em>闭包表达式</em> → <strong>{</strong> <a class="md_compiled" href="#closure-signature">闭包签名</a><sub>可选</sub> <a class="md_compiled" href="#statements">语句</a> <strong>}</strong>
    <span class="md_line md_line_end">&nbsp;</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_42" class="h16"><span class="span_for_h">closure-signature {#closure-signature}</span></h4>

<blockquote class="blockquote_lines_8 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start md_line_end">&nbsp;</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start">闭包签名* → <a class="md_compiled" href="#parameter-clause">参数子句</a> <a class="md_compiled" href="05-Declarations.md#function-result">函数结果</a><sub>可选</sub> <strong>in</strong><br /></span>
    <span class="md_line">&nbsp;<br /></span>
<em>闭包签名</em> → <a class="md_compiled" href="#identifier-list">标识符列表</a> <a class="md_compiled" href="05-Declarations.md#function-result">函数结果</a><sub>可选</sub> <strong>in</strong>
    <span class="md_line">&nbsp;<br /></span>
<em>闭包签名</em> → <a class="md_compiled" href="#capture-list">捕获列表</a> <a class="md_compiled" href="05-Declarations.md#parameter-clause">参数子句</a> <a class="md_compiled" href="./06-Declarations.md#function-result">函数结果</a><sub>可选</sub> <strong>in</strong>
    <span class="md_line">&nbsp;<br /></span>
<em>闭包签名</em> → <a class="md_compiled" href="#capture-list">捕获列表</a> <a class="md_compiled" href="02-Lexical-Structure.md#identifier-list">标识符列表</a> <a class="md_compiled" href="./06-Declarations.md#function-result">函数结果</a><sub>可选</sub> <strong>in</strong>
    <span class="md_line">&nbsp;<br /></span>
<em>闭包签名</em> → <a class="md_compiled" href="#capture-list">捕获列表</a> <strong>in</strong>
    <span class="md_line md_line_end">&nbsp;</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_43" class="h16"><span class="span_for_h">capture-list {#capture-list}</span></h4>

<blockquote class="blockquote_lines_3 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start md_line_end">&nbsp;</span>
</p>


<p class="md_block">
    <span style='font-family:捕获列表项列表'  class="md_line md_line_start">捕获列表* → [ <a class="md_compiled" href="#capture-list-items">捕获列表项列表</a> <strong>]</strong><br /></span>
    <span class="md_line md_line_end">&nbsp;</span>
</p>

</blockquote>
<h4 id="toc_44" class="h16"><span class="span_for_h">capture-list-items {#capture-list-items}</span></h4>

<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<em>捕获列表项列表</em> → <a class="md_compiled" href="#capture-list-item">捕获列表项</a> | <a class="md_compiled" href="#capture-list-item">捕获列表项</a> <strong>,</strong> <a class="md_compiled" href="#capture-list-items">捕获列表项列表</a>
    <span class="md_line md_line_end">&nbsp;</span>
</p>

</blockquote>
<h4 id="toc_45" class="h16"><span class="span_for_h">capture-list-item {#capture-list-item}</span></h4>

<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<em>捕获列表项</em> → <a class="md_compiled" href="#capture-specifier">捕获说明符</a><sub>可选</sub> <a class="md_compiled" href="#expression">表达式</a>
    <span class="md_line md_line_end">&nbsp;</span>
</p>

</blockquote>
<h4 id="toc_46" class="h16"><span class="span_for_h">capture-specifier {#capture-specifier}</span></h4>

<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<em>捕获说明符</em> → <strong>weak</strong> | <strong>unowned</strong> | <strong>unowned(safe)</strong> | <strong>unowned(unsafe)</strong>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h3 id="toc_47" class="h16"><span class="span_for_h">隐式成员表达式 {#implicit-member-expression}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">若类型可被推断出来，可以使用<em class="md_patched_em">隐式成员表达式</em>来访问某个类型的成员（例如某个枚举成员或某个类型方法），形式如下：</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start">.<code>成员名称</code><br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">例如：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="n">MyEnumeration</span><span class="p">.</span><span class="n">SomeValue</span>
<span class="n">x</span> <span class="p">=</span> <span class="p">.</span><span class="n">AnotherValue</span>
</pre></div>

<!--block_code_end-->
<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start">隐式成员表达式语法<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_48" class="h16"><span class="span_for_h">implicit-member-expression {#implicit-member-expression}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<em>隐式成员表达式</em> → <strong>.</strong> <a class="md_compiled" href="./02_Lexical_Structure.md#identifier">标识符</a>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h3 id="toc_49" class="h16"><span class="span_for_h">圆括号表达式 {#parenthesized-expression}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end"><em>圆括号表达式</em>是由圆括号包围的表达式。你可以用圆括号说明成组的表达式的先后操作。成组的圆括号不会改变表达式的类型 - 例如 <code>(1)</code> 的类型就是简单的 <code>Int</code>。</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start">圆括号表达式语法<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_50" class="h16"><span class="span_for_h">parenthesized-expression {#parenthesized-expression}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<em>圆括号表达式</em> → <strong>( <a class="md_compiled" href="#expression">表达式</a> )</strong>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h3 id="toc_51" class="h16"><span class="span_for_h">元组表达式 {#Tuple-Expression}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end"><em>元组表达式</em>由圆括号和其中多个逗号分隔的子表达式组成。每个子表达式前面可以有一个标识符，用冒号隔开。元组表达式形式如下：</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">(<code>标识符 1</code> : <code>表达式 1</code>, <code>标识符 2</code> : <code>表达式 2</code>, <code>...</code>)<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">元组表达式里的每一个标识符在表达式作用域里必须是唯一的。在嵌套的元组表达式中，同嵌套层级里的标识符也必须是唯一的。例如，<code>(a: 10, a: 20)</code> 是不合法的，因为标签 <code>a</code> 在同一层级出现了两次。然而，<code>(a: 10, b: (a: 1, x: 2))</code> 是合法的，尽管 <code>a</code> 出现了两次，但有一次在外层元组里，一次在内层元组里。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">元组表达式可以一个表达式都没有，也可以包含两个或是更多的表达式。单个表达式用括号括起来就是括号表达式了。</span>
</p>


<blockquote class="blockquote_lines_6 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">注意<br /></span>
    <span class="md_line md_line_end">&nbsp;</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start">在 Swift 中，空的元组表达式和空的元组类型都写作 <code>()</code>。由于 <code>Void</code> 是 <code>()</code> 的类型别名，因此可以使用它来表示空的元组类型。虽然如此，<code>Void</code> 就像所有的类型别名一样，永远是一个类型——不能表示空的元组表达式。<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>


<p class="md_block">
    <span class="md_line md_line_start">元组表达式语法<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_52" class="h16"><span class="span_for_h">tuple-expression {#tuple-expression}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<em>元组表达式</em> → <strong>( )</strong> | <strong>(</strong><a class="md_compiled" href="#tuple-element">元组元素</a>， <a class="md_compiled" href="#tuple-element-list">元组元素列表</a> <strong>)</strong>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_53" class="h16"><span class="span_for_h">tuple-element-list {#tuple-element-list}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<em>元组元素列表</em> → <a class="md_compiled" href="#tuple-element">元组元素</a> | <a class="md_compiled" href="#tuple-element">元组元素</a> <strong>,</strong> <a class="md_compiled" href="#tuple-element-list">元组元素列表</a>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_54" class="h16"><span class="span_for_h">tuple-element {#tuple-element}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<em>元组元素</em> → <a class="md_compiled" href="#expression">表达式</a> | <a class="md_compiled" href="identifier">标识符</a> <strong>:</strong> <a class="md_compiled" href="#expression">表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h3 id="toc_55" class="h16"><span class="span_for_h">通配符表达式 {#wildcard-expression}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end"><em>通配符表达式</em>可以在赋值过程中显式忽略某个值。例如下面的代码中，<code>10</code> 被赋值给 <code>x</code>，而 <code>20</code> 则被忽略：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">_</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="c1">// x 为 10，20 被忽略</span>
</pre></div>

<!--block_code_end-->
<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start">通配符表达式语法<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_56" class="h16"><span class="span_for_h">wildcard-expression {#wildcard-expression}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<em>通配符表达式</em> → <strong>_</strong>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h3 id="toc_57" class="h16"><span class="span_for_h">Key-path 表达式 {#key-path-expression}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">Key-path 表达式引用一个类型的属性或下标。在动态语言中使场景可以使用 Key-path 表达式，例如观察键值对。格式为：</span>
</p>


<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<strong>\类型名.路径</strong>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end"><em>类型名</em>是一个具体类型的名称，包含任何泛型参数，例如 <code>String</code>、<code>[Int]</code> 或 <code>Set&lt;Int&gt;</code>。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end"><em>路径</em>可由属性名称、下标、可选链表达式或者强制解包表达式组成。以上任意 key-path 组件可以以任何顺序重复多次。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">在编译期，key-path 表达式会被一个 <a class="md_compiled" href="https://developer.apple.com/documentation/swift/keypath">KeyPath</a> 类的实例替换。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">对于所有类型，都可以通过传递 key-path 参数到下标方法 <code>subscript(keyPath:)</code> 来访问它的值。例如：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">SomeStructure</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">someValue</span><span class="p">:</span> <span class="nb">Int</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">s</span> <span class="p">=</span> <span class="n">SomeStructure</span><span class="p">(</span><span class="n">someValue</span><span class="p">:</span> <span class="mi">12</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">pathToProperty</span> <span class="p">=</span> <span class="err">\</span><span class="n">SomeStructure</span><span class="p">.</span><span class="n">someValue</span>

<span class="kd">let</span> <span class="nv">value</span> <span class="p">=</span> <span class="n">s</span><span class="p">[</span><span class="n">keyPath</span><span class="p">:</span> <span class="n">pathToProperty</span><span class="p">]</span>
<span class="c1">// 值为 12</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">在一些可以通过类型推断来确定所访问的具体类型的上下文中，可以省略 key-path 前的类型名字。下面的代码使用 <code>\.someProperty</code> 代替了 <code>SomeClass.someProperty</code> ：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">class</span> <span class="nc">SomeClass</span><span class="p">:</span> <span class="bp">NSObject</span> <span class="p">{</span>
    <span class="kr">@objc</span> <span class="kd">var</span> <span class="nv">someProperty</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">someProperty</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">someProperty</span> <span class="p">=</span> <span class="n">someProperty</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">c</span> <span class="p">=</span> <span class="n">SomeClass</span><span class="p">(</span><span class="n">someProperty</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">c</span><span class="p">.</span><span class="n">observe</span><span class="p">(</span><span class="err">\</span><span class="p">.</span><span class="n">someProperty</span><span class="p">)</span> <span class="p">{</span> <span class="n">object</span><span class="p">,</span> <span class="n">change</span> <span class="k">in</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">使用 <code>self</code> 作为路径可以创建一个恒等 key path (<code>\.self</code>)。恒等 key path 可以作为整个实例的引用，因此你仅需一步操作便可以利用它来访问以及修改其存储的所有数据。例如：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">var</span> <span class="nv">compoundValue</span> <span class="p">=</span> <span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1">// 等价于 compoundValue = (a: 10, b: 20)</span>
<span class="n">compoundValue</span><span class="p">[</span><span class="n">keyPath</span><span class="p">:</span> <span class="err">\</span><span class="p">.</span><span class="kc">self</span><span class="p">]</span> <span class="p">=</span> <span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="mi">20</span><span class="p">)</span>
</pre></div>

<!--block_code_end-->
<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">通过点语法，可以让路径包含多个属性名称，以此来访问某实例的属性的属性。下面的代码使用 key-path 表达式 <code>\OuterStructure.outer.someValue</code> 来访问 <code>OuterStructure</code> 类型中 <code>outer</code> 属性的 <code>someValue</code> 属性。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">OuterStructure</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">outer</span><span class="p">:</span> <span class="n">SomeStructure</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">someValue</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">outer</span> <span class="p">=</span> <span class="n">SomeStructure</span><span class="p">(</span><span class="n">someValue</span><span class="p">:</span> <span class="n">someValue</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">nested</span> <span class="p">=</span> <span class="n">OuterStructure</span><span class="p">(</span><span class="n">someValue</span><span class="p">:</span> <span class="mi">24</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">nestedKeyPath</span> <span class="p">=</span> <span class="err">\</span><span class="n">OuterStructure</span><span class="p">.</span><span class="n">outer</span><span class="p">.</span><span class="n">someValue</span>

<span class="kd">let</span> <span class="nv">nestedValue</span> <span class="p">=</span> <span class="n">nested</span><span class="p">[</span><span class="n">keyPath</span><span class="p">:</span> <span class="n">nestedKeyPath</span><span class="p">]</span>
<span class="c1">// nestedValue 的值为 24</span>
</pre></div>

<!--block_code_end-->
<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">路径中也可以包含使用中括号的下标访问，只要下标访问的参数类型满足 <code>Hashable</code> 协议即可。下面的例子在 key path 中使用了下标来访问数组的第二个元素。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">let</span> <span class="nv">greetings</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="s">&quot;hola&quot;</span><span class="p">,</span> <span class="s">&quot;bonjour&quot;</span><span class="p">,</span> <span class="s">&quot;안녕&quot;</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">myGreeting</span> <span class="p">=</span> <span class="n">greetings</span><span class="p">[</span><span class="n">keyPath</span><span class="p">:</span> <span class="err">\</span><span class="p">[</span><span class="nb">String</span><span class="p">].[</span><span class="mi">1</span><span class="p">]]</span>
<span class="c1">// myGreeting 的值为 &#39;hola&#39;</span>
</pre></div>

<!--block_code_end-->
<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">下标访问中使用的值可以是一个变量或者字面量，并且 key-path 表达式会使用值语义来捕获此值。下面的代码在 key-path 表达式和闭包中都使用了 <code>index</code> 变量来访问 <code>greetings</code> 数组的第三个元素。当 <code>index</code> 被修改时，key-path 表达式仍旧引用数组第三个元素，而闭包则使用了新的索引值。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">var</span> <span class="nv">index</span> <span class="p">=</span> <span class="mi">2</span>
<span class="kd">let</span> <span class="nv">path</span> <span class="p">=</span> <span class="err">\</span><span class="p">[</span><span class="nb">String</span><span class="p">].[</span><span class="n">index</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">fn</span><span class="p">:</span> <span class="p">([</span><span class="nb">String</span><span class="p">])</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">=</span> <span class="p">{</span> <span class="n">strings</span> <span class="k">in</span> <span class="n">strings</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">greetings</span><span class="p">[</span><span class="n">keyPath</span><span class="p">:</span> <span class="n">path</span><span class="p">])</span>
<span class="c1">// 打印 &quot;bonjour&quot;</span>
<span class="bp">print</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">greetings</span><span class="p">))</span>
<span class="c1">// 打印 &quot;bonjour&quot;</span>

<span class="c1">// 将 &#39;index&#39; 设置为一个新的值不会影响到 &#39;path&#39;</span>
<span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="bp">print</span><span class="p">(</span><span class="n">greetings</span><span class="p">[</span><span class="n">keyPath</span><span class="p">:</span> <span class="n">path</span><span class="p">])</span>
<span class="c1">// 打印 &quot;bonjour&quot;</span>

<span class="c1">// &#39;fn&#39; 闭包使用了新值。</span>
<span class="bp">print</span><span class="p">(</span><span class="n">fn</span><span class="p">(</span><span class="n">greetings</span><span class="p">))</span>
<span class="c1">// 打印 &quot;안녕&quot;</span>
</pre></div>

<!--block_code_end-->
<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">路径可以使用可选链和强制解包。下面的代码在 key path 中使用了可选链来访问可选字符串的属性。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">let</span> <span class="nv">firstGreeting</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span> <span class="p">=</span> <span class="n">greetings</span><span class="p">.</span><span class="bp">first</span>
<span class="bp">print</span><span class="p">(</span><span class="n">firstGreeting</span><span class="p">?.</span><span class="bp">count</span> <span class="k">as</span> <span class="nb">Any</span><span class="p">)</span>
<span class="c1">// 打印 &quot;Optional(5)&quot;</span>

<span class="c1">// 使用 key path 实现同样的功能</span>
<span class="kd">let</span> <span class="nv">count</span> <span class="p">=</span> <span class="n">greetings</span><span class="p">[</span><span class="n">keyPath</span><span class="p">:</span> <span class="err">\</span><span class="p">[</span><span class="nb">String</span><span class="p">].</span><span class="bp">first</span><span class="p">?.</span><span class="bp">count</span><span class="p">]</span>
<span class="bp">print</span><span class="p">(</span><span class="bp">count</span> <span class="k">as</span> <span class="nb">Any</span><span class="p">)</span>
<span class="c1">// 打印 &quot;Optional(5)&quot;</span>
</pre></div>

<!--block_code_end-->
<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">可以混合使用各种 key-path 组件来访问一些深度嵌套类型的值。下面的代码通过组合不同的组件，使用 key-path 表达式访问了一个字典数组中不同的值和属性。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">let</span> <span class="nv">interestingNumbers</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;prime&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">],</span>
                          <span class="s">&quot;triangular&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">28</span><span class="p">],</span>
                          <span class="s">&quot;hexagonal&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">91</span><span class="p">]]</span>
<span class="bp">print</span><span class="p">(</span><span class="n">interestingNumbers</span><span class="p">[</span><span class="n">keyPath</span><span class="p">:</span> <span class="err">\</span><span class="p">[</span><span class="nb">String</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]].[</span><span class="s">&quot;prime&quot;</span><span class="p">]]</span> <span class="k">as</span> <span class="nb">Any</span><span class="p">)</span>
<span class="c1">// 打印 &quot;Optional([2, 3, 5, 7, 11, 13, 17])&quot;</span>
<span class="bp">print</span><span class="p">(</span><span class="n">interestingNumbers</span><span class="p">[</span><span class="n">keyPath</span><span class="p">:</span> <span class="err">\</span><span class="p">[</span><span class="nb">String</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]].[</span><span class="s">&quot;prime&quot;</span><span class="p">]</span><span class="o">!</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="c1">// 打印 &quot;2&quot;</span>
<span class="bp">print</span><span class="p">(</span><span class="n">interestingNumbers</span><span class="p">[</span><span class="n">keyPath</span><span class="p">:</span> <span class="err">\</span><span class="p">[</span><span class="nb">String</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]].[</span><span class="s">&quot;hexagonal&quot;</span><span class="p">]</span><span class="o">!</span><span class="p">.</span><span class="bp">count</span><span class="p">])</span>
<span class="c1">// 打印 &quot;7&quot;</span>
<span class="bp">print</span><span class="p">(</span><span class="n">interestingNumbers</span><span class="p">[</span><span class="n">keyPath</span><span class="p">:</span> <span class="err">\</span><span class="p">[</span><span class="nb">String</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]].[</span><span class="s">&quot;hexagonal&quot;</span><span class="p">]</span><span class="o">!</span><span class="p">.</span><span class="bp">count</span><span class="p">.</span><span class="n">bitWidth</span><span class="p">])</span>
<span class="c1">// 打印 &quot;64&quot;</span>
</pre></div>

<!--block_code_end-->
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">关于更多如何使用 key path 与 Objective-C APIs 交互的信息，请参阅 <a class="md_compiled" href="https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift">在 Swift 中使用 Objective-C 运行时特性</a>。关于更多 key-value 编程和 key-value 观察的信息，请参阅 <a class="md_compiled" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple-ref/doc/uid/10000107i">Key-Value 编程</a> 和 <a class="md_compiled" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple-ref/doc/uid/10000177i">Key-Value 观察编程</a>。</span>
</p>


<blockquote class="blockquote_lines_3 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">key-path 表达式语法<br /></span>
    <span class="md_line md_line_end">&nbsp;</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_58" class="h16"><span class="span_for_h">key-path-expression {#key-path-expression}</span></h4>

<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<em>key-path 表达式</em> → <strong>\</strong>  <a class="md_compiled" href="./03_Types.md#type">类型</a><sub>可选</sub>  <strong>.</strong>  <a class="md_compiled" href="#key-path-components">多个 key-path 组件</a>
    <span class="md_line md_line_end">&nbsp;</span>
</p>

</blockquote>
<h4 id="toc_59" class="h16"><span class="span_for_h">key-path-components {#key-path-components}</span></h4>

<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<em>多个 key-path 组件</em> → <a class="md_compiled" href="#key-path-component">key-path 组件</a> | <a class="md_compiled" href="#key-path-component">key-path 组件</a> <strong>.</strong> <a class="md_compiled" href="#key-path-components">多个 key-path 组件</a>
    <span class="md_line md_line_end">&nbsp;</span>
</p>

</blockquote>
<h4 id="toc_60" class="h16"><span class="span_for_h">key-path-component {#key-path-component}</span></h4>

<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<em>key-path 组件</em> →  <a class="md_compiled" href="./02_Lexical_Structure.md#identifier">标识符</a> <a class="md_compiled" href="#key-path-postfixes">多个 key-path 后缀</a><sub>可选<sub> | <a class="md_compiled" href="#key-path-postfixes">多个 key-path 后缀</a>
    <span class="md_line md_line_end">&nbsp;</span>
</p>

</blockquote>
<h4 id="toc_61" class="h16"><span class="span_for_h">key-path-postfixes {#key-path-postfixes}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start md_line_end">&nbsp;</span>
</p>

</blockquote>
<h4 id="toc_62" class="h16"><span class="span_for_h"><em>多个 key-path 后缀</em> →  <a class="md_compiled" href="#key-path-postfix">key-path 后缀</a> <a class="md_compiled" href="#key-path-postfixes">多个 key-path 后缀</a><sub>可选<sub> key-path-postfixes {#key-path-postfixes}</span></h4>

<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<em>key-path 后缀</em> → <strong>?</strong> | <strong>!</strong> | <strong>self</strong> | <strong>[</strong> <a class="md_compiled" href="#function-call-argument-list">函数调用参数表</a> <strong>]</strong> 
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<span class="md_repeated_n md_repeated_n_1"></span><h3 id="toc_63" class="h16"><span class="span_for_h">选择器表达式 {#selector-expression}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end"><em>选择器表达式</em>可以让你通过选择器来引用在 Objective-C 中方法（method）和属性（property）的 setter 和 getter 方法。</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">#selector(方法名)<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start">#selector(getter: 属性名)<br /></span>
    <span class="md_line md_line_end">#selector(setter: 属性名)</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">方法名和属性名必须是存在于 Objective-C 运行时中的方法和属性的引用。选择器表达式的返回值是一个 Selector 类型的实例。例如：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">class</span> <span class="nc">SomeClass</span><span class="p">:</span> <span class="bp">NSObject</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">property</span><span class="p">:</span> <span class="nb">String</span>
    <span class="kr">@objc</span><span class="p">(</span><span class="n">doSomethingWithInt</span><span class="p">:)</span>
    <span class="kd">func</span> <span class="nf">doSomething</span><span class="p">(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    
    <span class="kd">init</span><span class="p">(</span><span class="n">property</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">property</span> <span class="p">=</span> <span class="n">property</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">selectorForMethod</span> <span class="p">=</span> <span class="k">#selector</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">.</span><span class="n">doSomething</span><span class="p">(</span><span class="o">-</span><span class="p">:))</span>
<span class="kd">let</span> <span class="nv">selectorForPropertyGetter</span> <span class="p">=</span> <span class="k">#selector</span><span class="p">(</span><span class="n">getter</span><span class="p">:</span> <span class="n">SomeClass</span><span class="p">.</span><span class="n">property</span><span class="p">)</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">当为属性的 getter 创建选择器时，属性名可以是变量属性或者常量属性的引用。但是当为属性的 setter 创建选择器时，属性名只可以是对变量属性的引用。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">方法名称可以包含圆括号来进行分组，并使用 as 操作符来区分具有相同方法名但类型不同的方法，例如:</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">extension</span> <span class="nc">SomeClass</span> <span class="p">{</span>
    <span class="kr">@objc</span><span class="p">(</span><span class="n">doSomethingWithString</span><span class="p">:)</span>
    <span class="kd">func</span> <span class="nf">doSomething</span><span class="p">(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">anotherSelector</span> <span class="p">=</span> <span class="k">#selector</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">.</span><span class="n">doSomething</span><span class="p">(</span><span class="o">-</span><span class="p">:)</span> <span class="k">as</span> <span class="p">(</span><span class="n">SomeClass</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Void</span><span class="p">)</span>
</pre></div>

<!--block_code_end-->
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">由于选择器是在编译时创建的，因此编译器可以检查方法或者属性是否存在，以及是否在运行时暴露给了 Objective-C 。</span>
</p>


<blockquote class="blockquote_lines_4 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start">注意<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line">虽然方法名或者属性名是个表达式，但是它不会被求值。<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">更多关于如何在 Swift 代码中使用选择器来与 Objective-C API 进行交互的信息，请参阅 <a class="md_compiled" href="https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift">在 Swift 中使用 Objective-C 运行时特性</a>。</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start">选择器表达式语法<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_64" class="h16"><span class="span_for_h">selector-expression {#selector-expression}</span></h4>

<blockquote class="blockquote_lines_3 blockquote_without_image">
<p class="md_block">
<em>选择器表达式</em> → __#selector-- <strong>(</strong> <a class="md_compiled" href="#expression">表达式</a> <strong>)</strong>
    <span class="md_line">&nbsp;<br /></span>
<em>选择器表达式</em> → __#selector-- <strong>(</strong> <a class="md_compiled" href="#expression">getter:表达式</a> <strong>)</strong>
    <span class="md_line">&nbsp;<br /></span>
<em>选择器表达式</em> → __#selector-- <strong>(</strong> <a class="md_compiled" href="#expression">setter:表达式</a> <strong>)</strong>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h2 id="toc_65" class="h16"><span class="span_for_h">Key-path 字符串表达式 {#key-path-string-expressions}</span></h2>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">key-path 字符串表达式可以访问一个引用 Objective-C 属性的字符串，通常在 key-value 编程和 key-value 观察 APIs 中使用。其格式如下：</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start"><code>#keyPath</code> ( <code>属性名</code> )<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">属性名必须是一个可以在 Objective-C 运行时使用的属性的引用。在编译期，key-path 字符串表达式会被一个字符串字面量替换。例如：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">class</span> <span class="nc">SomeClass</span><span class="p">:</span> <span class="bp">NSObject</span> <span class="p">{</span>
    <span class="kr">@objc</span> <span class="kd">var</span> <span class="nv">someProperty</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">init</span><span class="p">(</span><span class="n">someProperty</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">someProperty</span> <span class="p">=</span> <span class="n">someProperty</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">c</span> <span class="p">=</span> <span class="n">SomeClass</span><span class="p">(</span><span class="n">someProperty</span><span class="p">:</span> <span class="mi">12</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">keyPath</span> <span class="p">=</span> <span class="p">#</span><span class="n">keyPath</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">.</span><span class="n">someProperty</span><span class="p">)</span>

<span class="k">if</span> <span class="kd">let</span> <span class="nv">value</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">forKey</span><span class="p">:</span> <span class="n">keyPath</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 打印 &quot;12&quot;</span>
</pre></div>

<!--block_code_end-->
<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">当在一个类中使用 key-path 字符串表达式时，可以省略类名，直接使用属性名来访问这个类的某个属性。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">extension</span> <span class="nc">SomeClass</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">getSomeKeyPath</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
<span class="o">&gt;</span> 
        <span class="k">return</span> <span class="p">#</span><span class="n">keyPath</span><span class="p">(</span><span class="n">someProperty</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="bp">print</span><span class="p">(</span><span class="n">keyPath</span> <span class="p">==</span> <span class="n">c</span><span class="p">.</span><span class="n">getSomeKeyPath</span><span class="p">())</span>
<span class="c1">// 打印 &quot;true&quot;</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">由于 key-path 字符串表达式在编译期才创建，编译期可以检查属性是否存在，以及属性是否暴露给 Objective-C 运行时。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">关于更多如何使用 key path 与 Objective-C APIs 交互的信息，请参阅 <a class="md_compiled" href="./https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift">在 Swift 中使用 Objective-C 运行时特性</a>。关于更多 key-value 编程和 key-value 观察的信息，请参阅 <a class="md_compiled" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.md#//apple-ref/doc/uid/10000107i">Key-Value 编程</a> 和 <a class="md_compiled" href="./https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.md#//apple-ref/doc/uid/10000177i">Key-Value 观察编程</a>。</span>
</p>


<blockquote class="blockquote_lines_6 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">注意<br /></span>
    <span class="md_line md_line_end">&nbsp;</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start">尽管<em class="md_patched_em">属性名</em>是一个表达式，但它永远不会被求值<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>


<p class="md_block">
    <span class="md_line md_line_start">key-path 字符串表达式语法<br /></span>
    <span class="md_line md_line_end">&nbsp;</span>
</p>

</blockquote>
<h4 id="toc_66" class="h16"><span class="span_for_h">key-path-string-expression {#key-path-string-expression}</span></h4>

<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<em>key-path 字符串表达式</em> → <strong>#keyPath (</strong> <a class="md_compiled" href="#expression">表达式</a>  <strong>)</strong>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h2 id="toc_67" class="h16"><span class="span_for_h">后缀表达式 {#postfix-expressions}</span></h2>

<p class="md_block">
    <span class="md_line md_line_start md_line_end"><em>后缀表达式</em>就是在某个表达式的后面运用后缀运算符或其他后缀语法。从语法构成上来看，基本表达式也是后缀表达式。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">关于这些运算符的更多信息，请参阅 <a class="md_compiled" href="../02_language_guide/02_Basic_Operators.md">基本运算符</a> 和 <a class="md_compiled" href="../02_language_guide/27_Advanced_Operators.md">高级运算符</a>。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">关于 Swift 标准库提供的运算符的更多信息，请参阅 <a class="md_compiled" href="https://developer.apple.com/documentation/swift/operator_declarations">运算符定义</a>。</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start">后缀表达式语法<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_68" class="h16"><span class="span_for_h">postfix-expression {#postfix-expression}</span></h4>

<blockquote class="blockquote_lines_10 blockquote_without_image">
<p class="md_block">
<em>后缀表达式</em> → <a class="md_compiled" href="#primary-expression">基本表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<em>后缀表达式</em> → <a class="md_compiled" href="#postfix-expression">后缀表达式</a> <a class="md_compiled" href="02-Lexical-Structure.md#postfix-operator">后缀运算符</a>
    <span class="md_line">&nbsp;<br /></span>
<em>后缀表达式</em> → <a class="md_compiled" href="#function-call-expression">函数调用表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<em>后缀表达式</em> → <a class="md_compiled" href="#initializer-expression">构造器表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<em>后缀表达式</em> → <a class="md_compiled" href="#explicit-member-expression">显式成员表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<em>后缀表达式</em> → <a class="md_compiled" href="#postfix-self-expression">后缀 self 表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<em>后缀表达式</em> → <a class="md_compiled" href="#dynamic-type-expression">dynamicType 表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<em>后缀表达式</em> → <a class="md_compiled" href="#subscript-expression">下标表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<em>后缀表达式</em> → <a class="md_compiled" href="#forced-value-expression">强制取值表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<em>后缀表达式</em> → <a class="md_compiled" href="#optional-chaining-expression">可选链表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h3 id="toc_69" class="h16"><span class="span_for_h">函数调用表达式 {#function-call-expression}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end"><em>函数调用表达式</em>由函数名和参数列表组成，形式如下：</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start"><code>函数名</code>(<code>参数 1</code>, <code>参数 2</code>)<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">函数名可以是值为函数类型的任意表达式。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">如果函数声明中指定了参数的名字，那么在调用的时候也必须得写出来。这种函数调用表达式具有以下形式：</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start"><code>函数名</code>(<code>参数名 1</code>: <code>参数 1</code>, <code>参数名 2</code>: <code>参数 2</code>)<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">如果函数的最后一个参数是函数类型，可以在函数调用表达式的尾部（右圆括号之后）加上一个闭包，该闭包会作为函数的最后一个参数。如下两种写法是等价的：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="c1">// someFunction 接受整数和闭包参数</span>
<span class="n">someFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="p">{</span><span class="nv">$0</span> <span class="p">==</span> <span class="mi">13</span><span class="p">})</span>
<span class="n">someFunction</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span><span class="nv">$0</span> <span class="p">==</span> <span class="mi">13</span><span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">如果闭包是该函数的唯一参数，那么圆括号可以省略。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="c1">// someFunction 只接受一个闭包参数</span>
<span class="n">myData</span><span class="p">.</span><span class="n">someMethod</span><span class="p">()</span> <span class="p">{</span><span class="nv">$0</span> <span class="p">==</span> <span class="mi">13</span><span class="p">}</span>
<span class="n">myData</span><span class="p">.</span><span class="n">someMethod</span> <span class="p">{</span><span class="nv">$0</span> <span class="p">==</span> <span class="mi">13</span><span class="p">}</span>
</pre></div>

<!--block_code_end-->
<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">函数调用表达式语法<br /></span>
    <span class="md_line md_line_end">&nbsp;</span>
</p>

</blockquote>
<h4 id="toc_70" class="h16"><span class="span_for_h">function-call-expression {#function-call-expression}</span></h4>

<blockquote class="blockquote_lines_4 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<em>函数调用表达式</em> → <a class="md_compiled" href="#postfix-expression">后缀表达式</a> <a class="md_compiled" href="#function-call-argument-clause">函数调用参数子句</a>
    <span class="md_line">&nbsp;<br /></span>
<em>函数调用表达式</em> → <a class="md_compiled" href="#postfix-expression">后缀表达式</a> <a class="md_compiled" href="#function-call-argument-clause">函数调用参数子句</a><sub>可选</sub> <a class="md_compiled" href="#trailing-closure">尾随闭包</a>
    <span class="md_line md_line_end">&nbsp;</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_71" class="h16"><span class="span_for_h">function-call-argument-clause {#function-call-argument-clause}</span></h4>

<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<em>函数调用参数子句</em> → <strong>(</strong>  <strong>)</strong>  | <strong>(</strong> <a class="md_compiled" href="#function-call-argument-list">函数调用参数表</a> <strong>)</strong>
    <span class="md_line md_line_end">&nbsp;</span>
</p>

</blockquote>
<h4 id="toc_72" class="h16"><span class="span_for_h">function-call-argument-list {#function-call-argument-list}</span></h4>

<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<em>函数调用参数表</em> → <a class="md_compiled" href="#function-call-argument">函数调用参数</a> | <a class="md_compiled" href="#function-call-argument">函数调用参数</a> <strong>,</strong> <a class="md_compiled" href="#function-call-argument-list"><em>函数调用参数表</em></a>
    <span class="md_line md_line_end">&nbsp;</span>
</p>

</blockquote>
<h4 id="toc_73" class="h16"><span class="span_for_h">function-call-argument {#function-call-argument}</span></h4>

<blockquote class="blockquote_lines_4 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<em>函数调用参数</em> → <a class="md_compiled" href="#expression">表达式</a> | <a class="md_compiled" href="02-Lexical-Structure.md#identifier">标识符</a> <strong>:</strong> <a class="md_compiled" href="#expression">表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<em>函数调用参数</em> → <a class="md_compiled" href="./02_Lexical_Structure.md#operator">运算符</a> | <a class="md_compiled" href="./02-Lexical-Structure.md#identifier">标识符</a> <strong>:</strong> <a class="md_compiled" href="./02-Lexical-Structure.md#operator">运算符</a>
    <span class="md_line md_line_end">&nbsp;</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_74" class="h16"><span class="span_for_h">trailing-closure {#trailing-closure}</span></h4>

<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">&nbsp;<br /></span>
<em>尾随闭包</em> → <a class="md_compiled" href="#closure-expression">闭包表达式</a>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h3 id="toc_75" class="h16"><span class="span_for_h">构造器表达式 {#initializer-expression}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end"><em>构造器表达式</em>用于访问某个类型的构造器，形式如下：</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start"><code>表达式</code>.init(<code>构造器参数</code>)<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">你可以在函数调用表达式中使用构造器表达式来初始化某个类型的新实例。也可以使用构造器表达式来代理给父类构造器。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">class</span> <span class="nc">SomeSubClass</span><span class="p">:</span> <span class="n">SomeSuperClass</span> <span class="p">{</span>
    <span class="kr">override</span> <span class="kd">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 此处为子类构造过程</span>
        <span class="kc">super</span><span class="p">.</span><span class="kd">init</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">和函数类似，构造器表达式可以作为一个值。 例如：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="c1">// 类型注解是必须的，因为 String 类型有多种构造器</span>
<span class="kd">let</span> <span class="nv">initializer</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">=</span> <span class="nb">String</span><span class="p">.</span><span class="kd">init</span>
<span class="kd">let</span> <span class="nv">oneTwoThree</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="bp">map</span><span class="p">(</span><span class="n">initializer</span><span class="p">).</span><span class="bp">reduce</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">combine</span><span class="p">:</span> <span class="o">+</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="n">oneTwoThree</span><span class="p">)</span>
<span class="c1">// 打印“123”</span>
</pre></div>

<!--block_code_end-->
<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">如果通过名字来指定某个类型，可以不用构造器表达式而直接使用类型的构造器。在其他情况下，你必须使用构造器表达式。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">let</span> <span class="nv">s1</span> <span class="p">=</span> <span class="n">SomeType</span><span class="p">.</span><span class="kd">init</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// 有效</span>
<span class="kd">let</span> <span class="nv">s2</span> <span class="p">=</span> <span class="n">SomeType</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span>      <span class="c1">// 有效</span>

<span class="kd">let</span> <span class="nv">s4</span> <span class="p">=</span> <span class="n">someValue</span><span class="p">.</span><span class="kc">dynamicType</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span>      <span class="c1">// 错误</span>
<span class="kd">let</span> <span class="nv">s3</span> <span class="p">=</span> <span class="n">someValue</span><span class="p">.</span><span class="kc">dynamicType</span><span class="p">.</span><span class="kd">init</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="mi">7</span><span class="p">)</span> <span class="c1">// 有效</span>
</pre></div>

<!--block_code_end-->
<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start">构造器表达式语法<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_76" class="h16"><span class="span_for_h">initializer-expression {#initializer-expression}</span></h4>

<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
<em>构造器表达式</em> → <a class="md_compiled" href="#postfix-expression">后缀表达式</a> <strong>.</strong> <strong>init</strong>
    <span class="md_line">&nbsp;<br /></span>
<em>构造器表达式</em> → <a class="md_compiled" href="#postfix-expression">后缀表达式</a> <strong>.</strong> <strong>init</strong> <strong>(</strong> <a class="md_compiled" href="#argument-names">参数名称</a> <strong>)</strong>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h3 id="toc_77" class="h16"><span class="span_for_h">显式成员表达式 {#explicit-member-expression}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end"><em>显式成员表达式</em>允许我们访问命名类型、元组或者模块的成员，其形式如下：</span>
</p>


<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_code_block">
<code>表达式</code>.<code>成员名</code>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">命名类型的某个成员在原始实现或者扩展中定义，例如：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">class</span> <span class="nc">SomeClass</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">someProperty</span> <span class="p">=</span> <span class="mi">42</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">c</span> <span class="p">=</span> <span class="n">SomeClass</span><span class="p">()</span>
<span class="kd">let</span> <span class="nv">y</span> <span class="p">=</span> <span class="n">c</span><span class="p">.</span><span class="n">someProperty</span> <span class="c1">// 访问成员</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">元组的成员会隐式地根据表示它们出现顺序的整数来命名，以 0 开始，例如：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">var</span> <span class="nv">t</span> <span class="p">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="n">t</span><span class="p">.</span><span class="mi">0</span> <span class="p">=</span> <span class="n">t</span><span class="p">.</span><span class="mi">1</span>
<span class="c1">// 现在元组 t 为 (20, 20, 30)</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">对于模块的成员来说，只能直接访问顶级声明中的成员。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">使用 <code>dynamicMemberLookup</code> 属性声明的类型包含可以在运行时查找的成员，具体请参阅 <a class="md_compiled" href="./07_Attributes.md">属性</a>。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">为了区分只有参数名有所不同的方法或构造器，在圆括号中写出参数名，参数名后紧跟一个冒号，对于没有参数名的参数，使用下划线代替参数名。而对于重载方法，则需使用类型注解进行区分。例如：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">class</span> <span class="nc">SomeClass</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">someMethod</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kd">func</span> <span class="nf">someMethod</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kd">func</span> <span class="nf">overloadedMethod</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kd">func</span> <span class="nf">overloadedMethod</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">Bool</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">instance</span> <span class="p">=</span> <span class="n">SomeClass</span><span class="p">()</span>

<span class="kd">let</span> <span class="nv">a</span> <span class="p">=</span> <span class="n">instance</span><span class="p">.</span><span class="n">someMethod</span>              <span class="c1">// 有歧义</span>
<span class="kd">let</span> <span class="nv">b</span> <span class="p">=</span> <span class="n">instance</span><span class="p">.</span><span class="n">someMethod</span><span class="p">(</span><span class="kc">_</span><span class="p">:</span><span class="n">y</span><span class="p">:)</span>        <span class="c1">// 无歧义</span>

<span class="kd">let</span> <span class="nv">d</span> <span class="p">=</span> <span class="n">instance</span><span class="p">.</span><span class="n">overloadedMethod</span>        <span class="c1">// 有歧义</span>
<span class="kd">let</span> <span class="nv">d</span> <span class="p">=</span> <span class="n">instance</span><span class="p">.</span><span class="n">overloadedMethod</span><span class="p">(</span><span class="kc">_</span><span class="p">:</span><span class="n">y</span><span class="p">:)</span>  <span class="c1">// 有歧义</span>
<span class="kd">let</span> <span class="nv">d</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Bool</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Void</span>  <span class="p">=</span> <span class="n">instance</span><span class="p">.</span><span class="n">overloadedMethod</span><span class="p">(</span><span class="kc">_</span><span class="p">:</span><span class="n">y</span><span class="p">:)</span>  <span class="c1">// 无歧义</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">如果点号（<code>.</code>）出现在行首，它会被视为显式成员表达式的一部分，而不是隐式成员表达式的一部分。例如如下代码所展示的被分为多行的链式方法调用：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">let</span> <span class="nv">x</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
    <span class="p">.</span><span class="bp">sort</span><span class="p">()</span>
    <span class="p">.</span><span class="bp">filter</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="p">}</span>
    <span class="p">.</span><span class="bp">map</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">*</span> <span class="mi">100</span> <span class="p">}</span>
</pre></div>

<!--block_code_end-->
<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start">显式成员表达式语法<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_78" class="h16"><span class="span_for_h">explicit-member-expression {#explicit-member-expression}</span></h4>

<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
<em>显式成员表达式</em> → <a class="md_compiled" href="#postfix-expression">后缀表达式</a> <strong>.</strong> <a class="md_compiled" href="02-Lexical-Structure.md#decimal-digit">十进制数字</a>
    <span class="md_line">&nbsp;<br /></span>
<em>显式成员表达式</em> → <a class="md_compiled" href="#postfix-expression">后缀表达式</a> <strong>.</strong> <a class="md_compiled" href="02-Lexical-Structure.md#identifier">标识符</a> <a class="md_compiled" href="./09-Generic-Parameters-and-Arguments.md#generic-argument-clause">泛型实参子句</a><sub>可选</sub><br/>
    <span class="md_line">&nbsp;<br /></span>
<em>显式成员表达式</em> → <a class="md_compiled" href="#postfix-expression">后缀表达式</a> <strong>.</strong> <a class="md_compiled" href="02-Lexical-Structure.md#identifier">标识符</a> <strong>(</strong> <a class="md_compiled" href="#argument-names">参数名称</a> <strong>)</strong></p>

</blockquote>
<h4 id="toc_79" class="h16"><span class="span_for_h">argument-names {#argument-names}</span></h4>

<blockquote class=" blockquote_without_image"><em>参数名称</em> → <a class="md_compiled" href="#argument-name">参数名</a> <a class="md_compiled" href="#argument-names">参数名称</a><sub>可选</sub><br/></blockquote>
<h4 id="toc_80" class="h16"><span class="span_for_h">argument-name {#argument-name}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<em>参数名</em> → <a class="md_compiled" href="./02_Lexical_Structure.md#identifier">标识符</a> <strong>:</strong>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h3 id="toc_81" class="h16"><span class="span_for_h">后缀 self 表达式 {#postfix-self-expression}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">后缀 <code>self</code> 表达式由某个表达式或类型名紧跟 <code>.self</code> 组成，其形式如下：</span>
</p>


<blockquote class="blockquote_lines_4 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start"><code>表达式</code>.self<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line"><code>类型</code>.self<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">第一种形式返回表达式的值。例如：<code>x.self</code> 返回 <code>x</code>。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">第二种形式返回相应的类型。我们可以用它来获取某个实例的类型作为一个值来使用。例如，<code>SomeClass.self</code> 会返回 <code>SomeClass</code> 类型本身，你可以将其传递给相应函数或者方法作为参数。</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start">后缀 self 表达式语法<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_82" class="h16"><span class="span_for_h">postfix-self-expression {#postfix-self-expression}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<em>后缀 self 表达式</em> → <a class="md_compiled" href="#postfix-expression">后缀表达式</a> <strong>.</strong> <strong>self</strong>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h3 id="toc_83" class="h16"><span class="span_for_h">下标表达式 {#subscript-expression}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">可通过<em class="md_patched_em">下标表达式</em>访问相应的下标，形式如下：</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span style='font-family:索引表达式'  class="md_line md_line_start"><code>表达式</code>[<code>索引表达式</code>]<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">要获取下标表达式的值，可将索引表达式作为下标表达式的参数来调用下标 getter。下标 setter 的调用方式与之一样。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">关于下标的声明，请参阅 <a class="md_compiled" href="./06_Declarations.md#protocol-subscript-declaration">协议下标声明</a>。</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start">下标表达式语法<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_84" class="h16"><span class="span_for_h">subscript-expression {#subscript-expression}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<em>下标表达式</em> → <a class="md_compiled" href="#postfix-expression">后缀表达式</a> <strong>[</strong> <a class="md_compiled" href="#expression-list">表达式列表</a> <strong>]</strong>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h3 id="toc_85" class="h16"><span class="span_for_h">强制取值表达式 {#forced-Value-expression}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">当你确定可选值不是 <code>nil</code> 时，可以使用<em class="md_patched_em">强制取值表达式</em>来强制解包，形式如下：</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start"><code>表达式</code>!<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">如果该表达式的值不是 <code>nil</code>，则返回解包后的值。否则，抛出运行时错误。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">返回的值可以被修改，无论是修改值本身，还是修改值的成员。例如：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">var</span> <span class="nv">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">?</span> <span class="p">=</span> <span class="mi">0</span>
<span class="n">x</span><span class="p">!</span><span class="o">++</span>
<span class="c1">// x 现在是 1</span>

<span class="kd">var</span> <span class="nv">someDictionary</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;a&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s">&quot;b&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]]</span>
<span class="n">someDictionary</span><span class="p">[</span><span class="s">&quot;a&quot;</span><span class="p">]</span><span class="o">!</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">100</span>
<span class="c1">// someDictionary 现在是 [b: [10, 20], a: [100, 2, 3]]</span>
</pre></div>

<!--block_code_end-->
<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start">强制取值语法<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_86" class="h16"><span class="span_for_h">forced-value-expression {#forced-value-expression}</span></h4>

<blockquote class="blockquote_lines_1 blockquote_without_image">
<p class="md_block">
<em>强制取值表达式</em> → <a class="md_compiled" href="#postfix-expression">后缀表达式</a> <strong>!</strong>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h3 id="toc_87" class="h16"><span class="span_for_h">可选链表达式 {#optional-chaining-expression}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end"><em>可选链表达式</em>提供了一种使用可选值的便捷方法，形式如下：</span>
</p>


<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start"><code>表达式</code>?<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">后缀 <code>?</code> 运算符会根据表达式生成可选链表达式而不会改变表达式的值。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">如果某个后缀表达式包含可选链表达式，那么它的执行过程会比较特殊。如果该可选链表达式的值是 <code>nil</code>，整个后缀表达式会直接返回 <code>nil</code>。如果该可选链表达式的值不是 <code>nil</code>，则返回可选链表达式解包后的值，并将该值用于后缀表达式中剩余的表达式。在这两种情况下，整个后缀表达式的值都会是可选类型。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">如果某个后缀表达式中包含了可选链表达式，那么只有最外层的表达式会返回一个可选类型。例如，在下面的例子中，如果 <code>c</code> 不是 <code>nil</code>，那么它的值会被解包，然后通过 <code>.property</code> 访问它的属性，接着进一步通过 <code>.performAction()</code> 调用相应方法。整个 <code>c?.property.performAction()</code> 表达式返回一个可选类型的值，而不是多重可选类型。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">var</span> <span class="nv">c</span><span class="p">:</span> <span class="n">SomeClass</span><span class="p">?</span>
<span class="kd">var</span> <span class="nv">result</span><span class="p">:</span> <span class="nb">Bool</span><span class="p">?</span> <span class="p">=</span> <span class="n">c</span><span class="p">?.</span><span class="n">property</span><span class="p">.</span><span class="n">performAction</span><span class="p">()</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">上面的例子跟下面的不使用可选链表达式的例子等价：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">var</span> <span class="nv">result</span><span class="p">:</span> <span class="nb">Bool</span><span class="p">?</span> <span class="p">=</span> <span class="kc">nil</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">unwrappedC</span> <span class="p">=</span> <span class="n">c</span> <span class="p">{</span>
    <span class="n">result</span> <span class="p">=</span> <span class="n">unwrappedC</span><span class="p">.</span><span class="n">property</span><span class="p">.</span><span class="n">performAction</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">可选链表达式解包后的值可以被修改，无论是修改值本身，还是修改值的成员。如果可选链表达式的值为 <code>nil</code>，则表达式右侧的赋值操作不会被执行。例如：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">someFunctionWithSideEffects</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="c1">// 译者注：为了能看出此函数是否被执行，加上了一句打印</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;someFunctionWithSideEffects&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">42</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nv">someDictionary</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;a&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s">&quot;b&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">]]</span>

<span class="n">someDictionary</span><span class="p">[</span><span class="s">&quot;not here&quot;</span><span class="p">]?[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="n">someFunctionWithSideEffects</span><span class="p">()</span>
<span class="c1">// someFunctionWithSideEffects 不会被执行</span>
<span class="c1">// someDictionary 依然是 [&quot;b&quot;: [10, 20], &quot;a&quot;: [1, 2, 3]]</span>

<span class="n">someDictionary</span><span class="p">[</span><span class="s">&quot;a&quot;</span><span class="p">]?[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="n">someFunctionWithSideEffects</span><span class="p">()</span>
<span class="c1">// someFunctionWithSideEffects 被执行并返回 42</span>
<span class="c1">// someDictionary 现在是 [&quot;b&quot;: [10, 20], &quot;a&quot;: [42, 2, 3]]</span>
</pre></div>

<!--block_code_end-->
<blockquote class="blockquote_lines_2 blockquote_without_image">
<p class="md_block last_md_block_in_page">
    <span class="md_line md_line_start">可选链表达式语法<br /></span>
    <span class="md_line">&nbsp;<br /></span>
<!--blockquote--></p>

</blockquote>
<h4 id="toc_88" class="h16"><span class="span_for_h">optional-chaining-expression {#optional-chaining-expression}</span></h4>

<blockquote class=" blockquote_without_image"><em>可选链表达式</em> → <a class="md_compiled" href="#postfix-expression">后缀表达式</a> <strong>?</strong>
<!--blockquote--></blockquote>
        </div>
    </div>
    
        <script type= "text/javascript">
            window.MathJax = {
              tex: {
                inlineMath: [ ['$','$']],
                displayMath: [ ['$$','$$'] ]
              },
              svg: {fontCache: 'none'},
              startup: {
                    ready: () => {
                      MathJax.startup.defaultReady();
                      MathJax.startup.promise.then(() => {
                        if (typeof(send_to_app_client)!='undefined'){send_to_app_client({'action': 'start_to_export_pdf'})}
                      });
                    }
                  },
              options: {
                renderActions: {
                  addMenu: [0]
                }
              }
            };
        </script>
        <script src="https://markeditor-files.oss-cn-hangzhou.aliyuncs.com/fb_static/lib/markdown/MathJax/tex-svg.js" type= "text/javascript"></script>
        
        
    <!--mermaid-->
</body>
</html>