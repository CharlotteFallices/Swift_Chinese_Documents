
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="renderer" content="webkit">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/>
    <meta content="yes" name="apple-mobile-web-app-capable"/>
    <meta content="black" name="apple-mobile-web-app-status-bar-style"/>
    <meta content="telephone=no" name="format-detection"/>
    <meta name="renderer" content="webkit"/>
    <title>函数</title>
    <link rel="stylesheet" href="data:text/css;base64,CiAgICBoMSwgaDIsIGgzLCBoNSwgaDYsICBpbWcsIHN2ZywgcHJlLCB0YWJsZSwgdHJ7cGFnZS1icmVhay1pbnNpZGU6IGF2b2lkfQoKICAgIAogICAgLnBvc3R7CiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjsKICAgIH0KICAgIGJvZHkgewogICAgICAgIGJhY2tncm91bmQ6ICMxNzFEMjE7CiAgICAgICAgZm9udC1zaXplOiAxNHB4OwogICAgICAgIGxpbmUtaGVpZ2h0OjIuNDsKICAgICAgICBmb250LWZhbWlseTogIkhlbHZldGljYSBOZXVlIiwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmOwogICAgICAgIGZvbnQtd2VpZ2h0OiBub3JtYWw7CiAgICAgICAgY29sb3I6ICNBNUIwQzA7CiAgICAgICAgcGFkZGluZzogMCAzOHB4OwogICAgICAgIG1heC13aWR0aDogODIwcHg7CiAgICAgICAgbWFyZ2luOiAwIGF1dG87CgogICAgICAgIHdvcmQtd3JhcDpicmVhay13b3JkOwogICAgICAgIHdvcmQtYnJlYWs6IG5vcm1hbDsKICAgICAgICBvdmVyZmxvdy13cmFwOmJyZWFrLXdvcmQ7CiAgICAgICAgdGV4dC1hbGlnbjoganVzdGlmeTsKCgogICAgICAgIG92ZXJmbG93LXg6IGhpZGRlbjsKICAgICAgICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVMZWdpYmlsaXR5OwogICAgICAgIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogbm9uZTsKICAgIH0KCiAgICBicnsKICAgICAgICBsaW5lLWhlaWdodDogMi40OwogICAgfQoKCgogICAgQG1lZGlhIChtYXgtd2lkdGg6IDYwMHB4KSB7CiAgICAgICAgYm9keXsKICAgICAgICAgICAgcGFkZGluZzogMCAzMHB4OwogICAgICAgIH0KICAgIH0KCiAgICBAbWVkaWEgKG1heC13aWR0aDogNDgwcHgpIHsKICAgICAgICBib2R5ewogICAgICAgICAgICBwYWRkaW5nOiAwIDIwcHg7CiAgICAgICAgfQogICAgfQoKICAgIC5naXN0ewogICAgICAgIHdvcmQtYnJlYWs6IG5vcm1hbDsKICAgIH0KCiAgICAucG9zdHsKICAgICAgICBtYXJnaW4tdG9wOiAxMHB4OwogICAgICAgIG1hcmdpbi1ib3R0b206IDUwcHg7CiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlOwogICAgfQoKCgogICAgaW1newogICAgICAgIG1heC13aWR0aDogOTglOwogICAgICAgIG1hcmdpbjogMC44ZW0gYXV0byAwLjhlbSBhdXRvOwogICAgfQoKICAgIGgxIGltZywgaDIgaW1nLCBoMyBpbWcsIGg0IGltZywgaDUgaW1nLCBoNiBpbWd7CiAgICAgICAgbWFyZ2luOiBhdXRvOwogICAgfQoKICAgIC54Ml9pbWFnZXsKICAgICAgICB6b29tOiA1MCU7CiAgICB9CgogICAgLngzX2ltYWdlewogICAgICAgIHpvb206IDMzLjMzJTsKICAgIH0KCiAgICAueDRfaW1hZ2V7CiAgICAgICAgem9vbTogMjUlOwogICAgfQoKCiAgICBwIGltZ3sKICAgICAgICBtYXJnaW46IDAgYXV0bzsKICAgIH0KCiAgICBwewogICAgICAgIC8qb3ZlcmZsb3c6aGlkZGVuOyovCiAgICAgICAgbWFyZ2luOiAxLjBlbSAwIDEuOWVtIDA7CiAgICB9CgogICAgcC5tZF9ibG9ja19hc19vcGVuaW5newogICAgICAgIG1hcmdpbi1ib3R0b206IC0wLjVlbSAhaW1wb3J0YW50OwogICAgfQoKICAgIGxpIHB7CiAgICAgICAgbGluZS1oZWlnaHQ6IDIuMTY7CiAgICAgICAgbWFyZ2luOiAwOwogICAgfQoKICAgIC5wX3BhcnQgewogICAgICAgIG1hcmdpbjogMTBweCAwOwogICAgfQoKICAgIC5wX3BhcnQgcHsKICAgICAgICBtYXJnaW46IDAgMCAwLjZlbSAwOwogICAgfQoKICAgIC8qIHRleHQgaW5kZW50IGZvciBjaGluZXNlIHN0YXJ0cyovCiAgICAvKmgyLCBoMywgaDQsIGg1LCBoNiwgLnBfcGFydCBwLCAudG9kb19pdGVtLCBwewogICAgICAgIHRleHQtaW5kZW50OiAwcHg7CiAgICB9Ki8KICAgIHRhYmxlLCBwcmUsIHN2Z3sKICAgICAgICBtYXJnaW4tbGVmdDogMHB4OwogICAgICAgIG1hcmdpbi1yaWdodDogMHB4OwogICAgfQogICAgCiAgICBzcGFuIHN2Z3sKICAgICAgICBtYXJnaW4tbGVmdDogMDsKICAgICAgICBtYXJnaW4tcmlnaHQ6IDA7CiAgICB9CgogICAgLmxpbmVub2RpdiBwcmV7CiAgICAgICAgbWFyZ2luLWxlZnQ6IDA7CiAgICAgICAgbWFyZ2luLXJpZ2h0OiAwOwoKICAgIH0KICAgIAogICAgLmhpZ2hsaWdodCBwcmV7CiAgICAgICAgbWFyZ2luLWxlZnQ6IDA7CiAgICAgICAgbWFyZ2luLXJpZ2h0OiAwOwogICAgfQogICAgCiAgICAuaGlnaGxpZ2h0dGFibGUgLmNvZGUgeyBwb3NpdGlvbjogcmVsYXRpdmV9CiAgICAKICAgIC5oaWdobGlnaHR0YWJsZSBkaXYud2l0aF9saW5lc3sgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IHdpZHRoOiAxMDAlO30KICAgIAogICAgLmhpZ2hsaWdodHRhYmxlIGRpdi53aXRoX2xpbmVzIHByZXsKICAgICAgICBwYWRkaW5nLWxlZnQ6IDEwcHg7CiAgICB9CgoKCiAgICAvKiB0ZXh0IGluZGVudCBmb3IgY2hpbmVzZSBlbmRzKi8KCgogICAgYmxvY2txdW90ZSAucF9wYXJ0IHAsIGxpIC5wX3BhcnQgcHsKICAgICAgICB0ZXh0LWluZGVudDogMCAhaW1wb3J0YW50OwogICAgfQoKCiAgICBocnsKICAgICAgICBtYXJnaW46IDM4cHggMDsKICAgICAgICBib3JkZXI6IG5vbmU7CiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IGRhc2hlZCByZ2JhKDIwNSwgMjA1LCAyMDUsIDAuMzUpOwogICAgICAgIGNvbG9yOiByZ2JhKDIwNSwgMjA1LCAyMDUsIDAuMzUpOwogICAgICAgIGhlaWdodDogMXB4OwogICAgICAgIGxpbmUtaGVpZ2h0OjFweDsKICAgICAgICBmb250LXNpemU6MXB4OwogICAgICAgIG92ZXJmbG93LXk6IGhpZGRlbjsKICAgIH0KCgogICAgaDF7CiAgICAgICAgY29sb3I6ICNENUYwRjg7CiAgICAgICAgZm9udC1zaXplOiAxLjdlbTsKICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0OwogICAgICAgIG1hcmdpbjogMDsKICAgICAgICBwYWRkaW5nOiAwOwogICAgICAgIGxpbmUtaGVpZ2h0OiAxLjdlbTsKICAgICAgICBtYXJnaW4tdG9wOiAwLjhlbTsKICAgICAgICBtYXJnaW4tYm90dG9tOiAwLjZlbTsKICAgIH0KCiAgICBoMSwgaDIsIGgzLCBoNHsKICAgICAgICBjb2xvcjogI0Q1RjBGODsKICAgIH0KICAgIAogICAgaDF7Y29sb3I6I0Q1RjBGOH0KCgoKICAgIGgyLCBoM3sKICAgICAgICBsaW5lLWhlaWdodDogMS41ZW07CiAgICAgICAgbWFyZ2luLXRvcDogMS44ZW07CiAgICAgICAgbWFyZ2luLWJvdHRvbTogMC41ZW07CiAgICB9CgogICAgLmgxNi5tZF9maXJzdF9oLm1kX2ZpcnN0X3BhcnQgewogICAgICAgIG1hcmdpbi10b3A6IDVweDsKICAgIH0KICAgIAogICAgLnNwYW5fZm9yX2h7CiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7CiAgICB9CgoKICAgIGgyIHsKICAgICAgICBmb250LXNpemU6IDEuNWVtOwogICAgfQoKICAgIGgzIHsKICAgICAgICBmb250LXNpemU6IDEuMjVlbQogICAgfQoKICAgIGg0IHsKICAgICAgICBmb250LXNpemU6IDEuMTVlbTsKICAgIH0KCiAgICBoNSB7CiAgICAgICAgZm9udC1zaXplOiAxLjFlbTsKICAgIH0KCiAgICBoNiB7Zm9udC1zaXplOiAxZW19CgoKICAgIGgxLCBoMiwgaDMsIGg0LCBoNSwgaDZ7CiAgICAgICAgZm9udC1mYW1pbHk6ICJQaW5nRmFuZyBTQyI7CiAgICB9CgoKICAgIG9sIHsKICAgICAgICBtYXJnaW46IDA7CiAgICB9CgogICAgdWx7CiAgICAgICAgcGFkZGluZzogNXB4IDM4cHg7CiAgICAgICAgbWFyZ2luOiAwOwogICAgfQoKICAgIHVsIGxpLCBsaXsKICAgICAgICBwYWRkaW5nOiAwOwogICAgICAgIG1hcmdpbjogMDsKICAgIH0KCiAgICB1bCBwLCBvbCBwewogICAgICAgIG92ZXJmbG93OiB2aXNpYmxlOwogICAgfQoKCiAgICBibG9ja3F1b3RlIHsKICAgICAgICAtbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7CiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDsKICAgICAgICBtYXJnaW46IDEuNmVtIDA7CiAgICAgICAgcGFkZGluZzogMCAwIDAgMS4yZW07CiAgICAgICAgYm9yZGVyLWxlZnQ6IDRweCBzb2xpZCAjMkE4MUM1OwogICAgICAgIGNvbG9yOiAjOUE5QTlBOwogICAgICAgIG1pbi1oZWlnaHQ6MjBweDsKICAgIH0KCgogICAgYmxvY2txdW90ZSBwIHsKICAgICAgICBtYXJnaW46IDAuOGVtIDA7CiAgICB9CgogICAgYmxvY2txdW90ZSBzcGFuLm1kX2xpbmUgewogICAgICAgIG1hcmdpbi1ib3R0b206IDAuMjVlbTsKICAgICAgICBtYXJnaW4tdG9wOiAwLjI1ZW07CiAgICB9CgogICAgYmxvY2txdW90ZSB1bHsKICAgICAgICBwYWRkaW5nOiAwIDE1cHg7CiAgICB9CgogICAgYmxvY2txdW90ZSBzbWFsbCB7CiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrOwogICAgICAgIG1hcmdpbjogMC44ZW0gMCAwLjhlbSAxLjVlbTsKICAgICAgICBmb250LXNpemU6IDAuOWVtOwogICAgICAgIGNvbG9yOiAjY2NjOwogICAgfQoKCgoKCgogICAgdGFibGUgewogICAgICAgIGxpbmUtaGVpZ2h0OiAxLjc7CiAgICAgICAgLW1vei1ib3gtc2l6aW5nOiBib3JkZXItYm94OwogICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7CiAgICAgICAgbWFyZ2luOiAxZW0gMDsKICAgICAgICB3aWR0aDogMTAwJTsKICAgICAgICBtYXgtd2lkdGg6IDEwMCU7CiAgICAgICAgYm9yZGVyLXdpZHRoOiAxcHg7CiAgICAgICAgYm9yZGVyLXN0eWxlOiBzb2xpZDsKICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsKICAgICAgICBib3JkZXItc3BhY2luZzogMDsKICAgICAgICB3b3JkLWJyZWFrOiBub3JtYWw7CiAgICB9CiAgICAKICAgIC8qIGZvciB3ZWNoYXQgb25seSBzdGFydHMgKi8KICAgIHRhYmxlIHRyewogICAgICAgIGJvcmRlci1yaWdodC1zdHlsZTogc29saWQ7CiAgICAgICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAxcHg7CiAgICB9CiAgICAKICAgIHRhYmxlIHRib2R5ewogICAgICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDFweDsKICAgICAgICBib3JkZXItYm90dG9tLXN0eWxlOiBzb2xpZDsKICAgIH0KICAgIC8qIGZvciB3ZWNoYXQgb25seSBlbmRzICovCgoKICAgIHRhYmxlLCB0YWJsZSB0ciwgdGFibGUgdHIgdGQsIHRhYmxlIHRyIHRoLCB0YWJsZSB0Ym9keSB7CiAgICAgICAgYm9yZGVyLWNvbG9yOiByZ2JhKDIwNSwgMjA1LCAyMDUsIDAuMzUpOwogICAgfQoKICAgIHRhYmxlIHRoIHsKICAgICAgICBmb250LXdlaWdodDogYm9sZDsKICAgIH0KCiAgICB0ciB0aCB7CiAgICAgICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMXB4OwogICAgICAgIGJvcmRlci1ib3R0b20tc3R5bGU6IHNvbGlkOwogICAgICAgIHRleHQtYWxpZ246IGxlZnQ7CiAgICB9CgogICAgdHIgdGgsIHRyIHRkIHsKICAgICAgICBwYWRkaW5nOiAxMHB4IDIwcHg7CiAgICAgICAgYm9yZGVyLXJpZ2h0OiAxcHggc29saWQ7CiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYmEoMjA1LCAyMDUsIDIwNSwgMC4zNSk7CiAgICB9CgogICAgdGJvZHkgdHI6bGFzdC1jaGlsZCB0ZHsKICAgICAgICBib3JkZXItYm90dG9tOiAwOwogICAgfQoKICAgIHRyIHRoOmxhc3QtY2hpbGQsIHRyIHRkOmxhc3QtY2hpbGQgewogICAgICAgIGJvcmRlci1yaWdodDogMDsKICAgIH0KCiAgICB0YWJsZSB0Ym9keSA+IHRyOm50aC1jaGlsZChvZGQpID4gdGQsIHRhYmxlIHRib2R5ID4gdHI6bnRoLWNoaWxkKG9kZCkgPiB0aCB7CiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyMzUsIDIzNSwgMjM1LCAwLjIpOwogICAgfQoKCgoKICAgIGNvZGV7CiAgICAgICAgYmFja2dyb3VuZDogcmdiYSgyMzUsIDIzNSwgMjM1LCAwLjM1KTsKICAgICAgICBjb2xvcjogIzc4RTI5MTsKICAgICAgICBwYWRkaW5nOiAwIDVweDsKICAgICAgICBtYXJnaW46IDAgMnB4OwogICAgfQoKICAgIHByZXsKICAgICAgICBtYXJnaW4tdG9wOiAxLjJlbTsKICAgICAgICBtYXJnaW4tYm90dG9tOiAxLjJlbTsKICAgICAgICBwYWRkaW5nOiAxNXB4IDEwcHg7CiAgICAgICAgZGlzcGxheTogYmxvY2s7CiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgyMDUsIDIwNSwgMjA1LCAwLjM1KTsKICAgICAgICAvKmJhY2tncm91bmQ6IHJnYmEoMjM1LCAyMzUsIDIzNSwgMC4zNSk7Ki8KICAgICAgICBmb250LXNpemU6IDkwJTsKICAgICAgICBsaW5lLWhlaWdodDoyLjQ7CiAgICAgICAgd2hpdGUtc3BhY2U6IHByZS13cmFwOwogICAgICAgIG92ZXJmbG93LXk6IGhpZGRlbjsKICAgICAgICBvdmVyZmxvdy14OiBhdXRvOwogICAgICAgIHdvcmQtd3JhcDogbm9ybWFsOwogICAgfQogICAgCiAgICAuY29kZWhpbGl0ZSBwcmV7CiAgICAgICAgd2hpdGUtc3BhY2U6IHByZTsKICAgIH0KCiAgICAuaGlnaGxpZ2h0dGFibGUgdGR7CiAgICAgICAgLypiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDIzNSwgMjM1LCAyMzUsIDAuMzUpICFpbXBvcnRhbnQ7Ki8KICAgIH0KCiAgICAud2l0aF9saW5lcyBwcmV7CiAgICAgICAgYm9yZGVyOm5vbmU7CiAgICAgICAgbWFyZ2luLXRvcDogMC4yZW07CiAgICAgICAgbWFyZ2luLWJvdHRvbTogMC4yZW07CiAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7CiAgICB9CgogICAgLmlzX2NvZGVfZmlsZSBwcmV7CiAgICAgICAgYm9yZGVyOiBub25lOwogICAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50OwogICAgfQoKICAgIC5jb2RlaGlsaXRlIHByZXsKICAgICAgICAvKndvcmQtd3JhcDogbm9ybWFsOyovCiAgICAgICAgZm9udC1zaXplOiAxM3B4OwogICAgfQoKICAgIHByZSBjb2RlewogICAgICAgIGJvcmRlcjpub25lOwogICAgICAgIGJhY2tncm91bmQ6IG5vbmU7CiAgICAgICAgcGFkZGluZzogMDsKICAgICAgICBtYXJnaW46IDA7CiAgICB9CgogICAgcHJlIHB7CiAgICAgICAgbWFyZ2luOiAwOwogICAgICAgIHBhZGRpbmc6IDA7CiAgICB9CgogICAgLmNvZGVoaWxpdGUgdGgsIC5jb2RlaGlsaXRlIHRkewogICAgICAgIGxpbmUtaGVpZ2h0OiAxLjhlbTsKICAgIH0KCgogICAgYXsKICAgICAgICBjb2xvcjogIzc3Qjg3RjsKICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7CiAgICAgICAgLy9ib3JkZXItYm90dG9tOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7CiAgICB9CgogICAgYTpob3ZlcnsKICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTsKICAgICAgICAvL2JvcmRlci1ib3R0b206IDFweCBzb2xpZCAjNzdCODdGOwogICAgfQoKICAgIHN0cm9uZyB7CiAgICAgICAgY29sb3I6ICNGRkZGRkY7CiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7CiAgICB9CgoKICAgIC8qIGZvciBtYXJrZG93biAqLwoKICAgIC5saW5lbm9zIHByZXsKCQliYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDsKCQlib3JkZXI6IG5vbmU7Cgl9CgoJLmxpbmVub3N7CgkgICAgcGFkZGluZzogMCA1cHggMCA1cHg7CgkgICAgd2lkdGg6IDAuMDAxJTsKCX0KCgkuaGlnaGxpZ2h0dGFibGUgIC5saW5lbm9zIHByZXsKCSAgICBwYWRkaW5nOiA1cHggMTBweDsKCX0KCQoJLmhpZ2hsaWdodHRhYmxlICAuY29kZSBwcmV7CgkgICAgcGFkZGluZzogMDsKCX0KCiAgICAudG9jewogICAgICAgIGJhY2tncm91bmQ6IE5vbmU7CiAgICAgICAgYm9yZGVyLXJhZGl1czogNXB4OwogICAgICAgIGJvcmRlcjogMXB4IHNvbGlkIE5vbmU7CiAgICAgICAgbWFyZ2luOiAyN3B4IDAgNDdweCAwOwogICAgICAgIHBhZGRpbmc6IDEwcHggMDsKICAgIH0KCiAgICAudG9jIHVsewogICAgICAgIC8vcGFkZGluZzogNXB4IDQycHg7CiAgICB9CgogICAgLnRvYyB1bCBsaXsKICAgICAgICBwYWRkaW5nOiAwOwogICAgICAgIG1hcmdpbjogMDsKICAgIH0KICAgIC50b2MgYXsKICAgICAgICBjb2xvcjogI0E1QjBDMDsKICAgIH0KCgoKICAgIC50b2RvX2l0ZW17CiAgICAgICAgbGlzdC1zdHlsZTogbm9uZTsKICAgICAgICBtYXJnaW4tbGVmdDogLTEuNWVtCiAgICB9CiAgICAudG9kb19pdGVtIC50b2RvX2l0ZW0gewogICAgICAgIG1hcmdpbi1sZWZ0OiBhdXRvOwogICAgfQoKICAgIC50b2RvX2RvbmVfaXRlbXsKICAgICAgICBjb2xvcjogIzU1NTU1NTsKICAgIH0KCiAgICAudG9kb191bmRvbmVfaXRlbXsKICAgICAgICBjb2xvcjogI0RERERERDsKICAgIH0KCgogICAgdWwgbGkudG9kb19pdGVtewoJbGlzdC1zdHlsZS10eXBlOiBub25lOwogICAgfQoKICAgIHVsIGxpLnRvZG9faXRlbTpiZWZvcmV7CiAgICAgICAgY29udGVudDogJ+KYkCc7CiAgICAgICAgLypwYWRkaW5nLXJpZ2h0OiAwLjJlbTsqLwogICAgICAgIGZvbnQtZmFtaWx5OiBhcmlhbDsKICAgIH0KCiAgICB1bCBsaS50b2RvX2RvbmVfaXRlbTpiZWZvcmV7CiAgICAgICAgY29udGVudDogJ+KYkSc7CiAgICAgICAgLypwYWRkaW5nLXJpZ2h0OiAwLjJlbTsqLwogICAgICAgIGZvbnQtZmFtaWx5OiBhcmlhbDsKICAgIH0KCiAgICB1bCBsaS50b2RvX2l0ZW0gaW5wdXR7CiAgICAgICAgZGlzcGxheTpub25lCiAgICB9CgoKICAgIC8qcHlnbWVudHMqLwoKICAgIC5jb2RlaGlsaXRlewogICAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7CiAgICB9CgogICAgLyp0YWJsZS5oaWdobGlnaHR0YWJsZXsgYm9yZGVyOm5vbmU7IH0KICAgIC5oaWdobGlnaHR0YWJsZSB0ZHsgYm9yZGVyOiBub25lOyBwYWRkaW5nOiAwO30qLwoKICAgIC5mbG93LWdyYXBoaWMsIC5tZF9ibG9ja19zZWN0aW9uX2Zvcl9mbG93X2dyYXBoaWN7dGV4dC1hbGlnbjogY2VudGVyfQogICAgLmZsb3ctZ3JhcGhpYyB7IG92ZXJmbG93LXg6IGF1dG87fQogICAgLm1lcm1haWQsIC5tZF9ibG9ja19zZWN0aW9uX2Zvcl9tZXJtYWlke3RleHQtYWxpZ246IGNlbnRlcn0KICAgIAogICAgLmZsb3ctZ3JhcGhpYywgLm1lcm1haWR7CiAgICAgICAgYmFja2dyb3VuZDogI2ZmZmZmZjsKICAgIH0KCgogICAgdGFibGUsIHRyLCB0ZCwgdGgsIHRib2R5LCB0aGVhZCwgdGZvb3QsIC5tZF9lY2hhcnRzLCBibG9ja3F1b3RlIC5tZF9saW5lewogICAgICAgIHBhZ2UtYnJlYWstaW5zaWRlOiBhdm9pZCAhaW1wb3J0YW50OwogICAgfQoKICAgIC5mb290bm90ZXMgLm1kX2xpbmV7CiAgICAgICAgZGlzcGxheTogaW5saW5lICFpbXBvcnRhbnQ7CiAgICB9CgoKICAgIC5pbWdfcnRfOTB7CiAgICAgICAgdHJhbnNmb3JtOnJvdGF0ZSg5MGRlZyk7CiAgICAgICAgLW1zLXRyYW5zZm9ybTpyb3RhdGUoOTBkZWcpOwogICAgICAgIC1tb3otdHJhbnNmb3JtOnJvdGF0ZSg5MGRlZyk7CiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDkwZGVnKTsKICAgICAgICAtby10cmFuc2Zvcm06cm90YXRlKDkwZGVnKTsKICAgIH0KICAgIC5pbWdfcnRfMTgwewogICAgICAgIHRyYW5zZm9ybTpyb3RhdGUoMTgwZGVnKTsKICAgICAgICAtbXMtdHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpOwogICAgICAgIC1tb3otdHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpOwogICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpOwogICAgICAgIC1vLXRyYW5zZm9ybTpyb3RhdGUoMTgwZGVnKTsKICAgIH0KICAgIC5pbWdfcnRfMjcwewogICAgICAgIHRyYW5zZm9ybTpyb3RhdGUoMjcwZGVnKTsKICAgICAgICAtbXMtdHJhbnNmb3JtOnJvdGF0ZSgyNzBkZWcpOwogICAgICAgIC1tb3otdHJhbnNmb3JtOnJvdGF0ZSgyNzBkZWcpOwogICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgyNzBkZWcpOwogICAgICAgIC1vLXRyYW5zZm9ybTpyb3RhdGUoMjcwZGVnKTsKICAgIH0KCiAgICAubWRfaGFzX2Jsb2NrX2JlbG93ewogICAgICAgIG1hcmdpbi1ib3R0b206IDAuMWVtICFpbXBvcnRhbnQ7CiAgICB9CiAgICAubWRfaGFzX2Jsb2NrX2JlbG93X2ltZ3sKICAgICAgICBtYXJnaW4tYm90dG9tOiAtMC42ZW0gIWltcG9ydGFudDsKICAgIH0KCgogICAgLmNvZGVoaWxpdGUgLmVycnsKICAgICAgICBib3JkZXI6IG5vbmUgIWltcG9ydGFudDsKICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50OwogICAgfQoKCgogICAgICAgIHNwYW4ubWRfbGluZXttYXJnaW4tYm90dG9tOjAuNWVtOyBkaXNwbGF5OmJsb2NrOyBsaW5lLWhlaWdodDoyLjF9CiAgICAgICAgLm1kX2xpbmUgYnJ7IGRpc3BsYXk6IG5vbmU7fQogICAgICAgIC5jb2RlaGlsaXRlIC5obGwgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmZmNjIH0KLmNvZGVoaWxpdGUgIHsgYmFja2dyb3VuZDogI2ZmZmZmZjsgfQouY29kZWhpbGl0ZSAuYyB7IGNvbG9yOiAjMTc3NTAwIH0gLyogQ29tbWVudCAqLwouY29kZWhpbGl0ZSAuZXJyIHsgY29sb3I6ICMwMDAwMDAgfSAvKiBFcnJvciAqLwouY29kZWhpbGl0ZSAuayB7IGNvbG9yOiAjQTkwRDkxIH0gLyogS2V5d29yZCAqLwouY29kZWhpbGl0ZSAubCB7IGNvbG9yOiAjMUMwMUNFIH0gLyogTGl0ZXJhbCAqLwouY29kZWhpbGl0ZSAubiB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZSAqLwouY29kZWhpbGl0ZSAubyB7IGNvbG9yOiAjMDAwMDAwIH0gLyogT3BlcmF0b3IgKi8KLmNvZGVoaWxpdGUgLmNoIHsgY29sb3I6ICMxNzc1MDAgfSAvKiBDb21tZW50Lkhhc2hiYW5nICovCi5jb2RlaGlsaXRlIC5jbSB7IGNvbG9yOiAjMTc3NTAwIH0gLyogQ29tbWVudC5NdWx0aWxpbmUgKi8KLmNvZGVoaWxpdGUgLmNwIHsgY29sb3I6ICM2MzM4MjAgfSAvKiBDb21tZW50LlByZXByb2MgKi8KLmNvZGVoaWxpdGUgLmNwZiB7IGNvbG9yOiAjMTc3NTAwIH0gLyogQ29tbWVudC5QcmVwcm9jRmlsZSAqLwouY29kZWhpbGl0ZSAuYzEgeyBjb2xvcjogIzE3NzUwMCB9IC8qIENvbW1lbnQuU2luZ2xlICovCi5jb2RlaGlsaXRlIC5jcyB7IGNvbG9yOiAjMTc3NTAwIH0gLyogQ29tbWVudC5TcGVjaWFsICovCi5jb2RlaGlsaXRlIC5rYyB7IGNvbG9yOiAjQTkwRDkxIH0gLyogS2V5d29yZC5Db25zdGFudCAqLwouY29kZWhpbGl0ZSAua2QgeyBjb2xvcjogI0E5MEQ5MSB9IC8qIEtleXdvcmQuRGVjbGFyYXRpb24gKi8KLmNvZGVoaWxpdGUgLmtuIHsgY29sb3I6ICNBOTBEOTEgfSAvKiBLZXl3b3JkLk5hbWVzcGFjZSAqLwouY29kZWhpbGl0ZSAua3AgeyBjb2xvcjogI0E5MEQ5MSB9IC8qIEtleXdvcmQuUHNldWRvICovCi5jb2RlaGlsaXRlIC5rciB7IGNvbG9yOiAjQTkwRDkxIH0gLyogS2V5d29yZC5SZXNlcnZlZCAqLwouY29kZWhpbGl0ZSAua3QgeyBjb2xvcjogI0E5MEQ5MSB9IC8qIEtleXdvcmQuVHlwZSAqLwouY29kZWhpbGl0ZSAubGQgeyBjb2xvcjogIzFDMDFDRSB9IC8qIExpdGVyYWwuRGF0ZSAqLwouY29kZWhpbGl0ZSAubSB7IGNvbG9yOiAjMUMwMUNFIH0gLyogTGl0ZXJhbC5OdW1iZXIgKi8KLmNvZGVoaWxpdGUgLnMgeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nICovCi5jb2RlaGlsaXRlIC5uYSB7IGNvbG9yOiAjODM2QzI4IH0gLyogTmFtZS5BdHRyaWJ1dGUgKi8KLmNvZGVoaWxpdGUgLm5iIHsgY29sb3I6ICNBOTBEOTEgfSAvKiBOYW1lLkJ1aWx0aW4gKi8KLmNvZGVoaWxpdGUgLm5jIHsgY29sb3I6ICMzRjZFNzUgfSAvKiBOYW1lLkNsYXNzICovCi5jb2RlaGlsaXRlIC5ubyB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZS5Db25zdGFudCAqLwouY29kZWhpbGl0ZSAubmQgeyBjb2xvcjogIzAwMDAwMCB9IC8qIE5hbWUuRGVjb3JhdG9yICovCi5jb2RlaGlsaXRlIC5uaSB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZS5FbnRpdHkgKi8KLmNvZGVoaWxpdGUgLm5lIHsgY29sb3I6ICMwMDAwMDAgfSAvKiBOYW1lLkV4Y2VwdGlvbiAqLwouY29kZWhpbGl0ZSAubmYgeyBjb2xvcjogIzAwMDAwMCB9IC8qIE5hbWUuRnVuY3Rpb24gKi8KLmNvZGVoaWxpdGUgLm5sIHsgY29sb3I6ICMwMDAwMDAgfSAvKiBOYW1lLkxhYmVsICovCi5jb2RlaGlsaXRlIC5ubiB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZS5OYW1lc3BhY2UgKi8KLmNvZGVoaWxpdGUgLm54IHsgY29sb3I6ICMwMDAwMDAgfSAvKiBOYW1lLk90aGVyICovCi5jb2RlaGlsaXRlIC5weSB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZS5Qcm9wZXJ0eSAqLwouY29kZWhpbGl0ZSAubnQgeyBjb2xvcjogIzAwMDAwMCB9IC8qIE5hbWUuVGFnICovCi5jb2RlaGlsaXRlIC5udiB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZS5WYXJpYWJsZSAqLwouY29kZWhpbGl0ZSAub3cgeyBjb2xvcjogIzAwMDAwMCB9IC8qIE9wZXJhdG9yLldvcmQgKi8KLmNvZGVoaWxpdGUgLm1iIHsgY29sb3I6ICMxQzAxQ0UgfSAvKiBMaXRlcmFsLk51bWJlci5CaW4gKi8KLmNvZGVoaWxpdGUgLm1mIHsgY29sb3I6ICMxQzAxQ0UgfSAvKiBMaXRlcmFsLk51bWJlci5GbG9hdCAqLwouY29kZWhpbGl0ZSAubWggeyBjb2xvcjogIzFDMDFDRSB9IC8qIExpdGVyYWwuTnVtYmVyLkhleCAqLwouY29kZWhpbGl0ZSAubWkgeyBjb2xvcjogIzFDMDFDRSB9IC8qIExpdGVyYWwuTnVtYmVyLkludGVnZXIgKi8KLmNvZGVoaWxpdGUgLm1vIHsgY29sb3I6ICMxQzAxQ0UgfSAvKiBMaXRlcmFsLk51bWJlci5PY3QgKi8KLmNvZGVoaWxpdGUgLnNhIHsgY29sb3I6ICNDNDFBMTYgfSAvKiBMaXRlcmFsLlN0cmluZy5BZmZpeCAqLwouY29kZWhpbGl0ZSAuc2IgeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLkJhY2t0aWNrICovCi5jb2RlaGlsaXRlIC5zYyB7IGNvbG9yOiAjMjMwMENFIH0gLyogTGl0ZXJhbC5TdHJpbmcuQ2hhciAqLwouY29kZWhpbGl0ZSAuZGwgeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLkRlbGltaXRlciAqLwouY29kZWhpbGl0ZSAuc2QgeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLkRvYyAqLwouY29kZWhpbGl0ZSAuczIgeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLkRvdWJsZSAqLwouY29kZWhpbGl0ZSAuc2UgeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLkVzY2FwZSAqLwouY29kZWhpbGl0ZSAuc2ggeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLkhlcmVkb2MgKi8KLmNvZGVoaWxpdGUgLnNpIHsgY29sb3I6ICNDNDFBMTYgfSAvKiBMaXRlcmFsLlN0cmluZy5JbnRlcnBvbCAqLwouY29kZWhpbGl0ZSAuc3ggeyBjb2xvcjogI0M0MUExNiB9IC8qIExpdGVyYWwuU3RyaW5nLk90aGVyICovCi5jb2RlaGlsaXRlIC5zciB7IGNvbG9yOiAjQzQxQTE2IH0gLyogTGl0ZXJhbC5TdHJpbmcuUmVnZXggKi8KLmNvZGVoaWxpdGUgLnMxIHsgY29sb3I6ICNDNDFBMTYgfSAvKiBMaXRlcmFsLlN0cmluZy5TaW5nbGUgKi8KLmNvZGVoaWxpdGUgLnNzIHsgY29sb3I6ICNDNDFBMTYgfSAvKiBMaXRlcmFsLlN0cmluZy5TeW1ib2wgKi8KLmNvZGVoaWxpdGUgLmJwIHsgY29sb3I6ICM1QjI2OUEgfSAvKiBOYW1lLkJ1aWx0aW4uUHNldWRvICovCi5jb2RlaGlsaXRlIC5mbSB7IGNvbG9yOiAjMDAwMDAwIH0gLyogTmFtZS5GdW5jdGlvbi5NYWdpYyAqLwouY29kZWhpbGl0ZSAudmMgeyBjb2xvcjogIzAwMDAwMCB9IC8qIE5hbWUuVmFyaWFibGUuQ2xhc3MgKi8KLmNvZGVoaWxpdGUgLnZnIHsgY29sb3I6ICMwMDAwMDAgfSAvKiBOYW1lLlZhcmlhYmxlLkdsb2JhbCAqLwouY29kZWhpbGl0ZSAudmkgeyBjb2xvcjogIzAwMDAwMCB9IC8qIE5hbWUuVmFyaWFibGUuSW5zdGFuY2UgKi8KLmNvZGVoaWxpdGUgLnZtIHsgY29sb3I6ICMwMDAwMDAgfSAvKiBOYW1lLlZhcmlhYmxlLk1hZ2ljICovCi5jb2RlaGlsaXRlIC5pbCB7IGNvbG9yOiAjMUMwMUNFIH0gLyogTGl0ZXJhbC5OdW1iZXIuSW50ZWdlci5Mb25nICovCiAgICAvKiBwYWdlX2NzcyAqLwoKICAgIAogICAgaHRtbHsKICAgICAgICBiYWNrZ3JvdW5kOiAjMTAxNjFBOwogICAgfQogICAgYm9keXsKICAgICAgICB3aWR0aDogOTAlOwogICAgICAgIG1heC13aWR0aDogOTYwcHg7CiAgICAgICAgYmFja2dyb3VuZDogIzE3MUQyMTsKICAgICAgICBtYXJnaW46IDNlbSBhdXRvIDA7CiAgICAgICAgcGFkZGluZy10b3A6IDJlbTsKICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjMTAxNjFBOwogICAgICAgIGJvcmRlci13aWR0aDogMCAxcHg7CiAgICB9CgogICAgLnBvc3R7CiAgICAgICAgcGFkZGluZzogNSUgMTAlOwogICAgICAgIG1hcmdpbi10b3A6IDA7CiAgICAgICAgbWFyZ2luLWJvdHRvbTogMDsKICAgIH0KICAgIAoKICAgIC50aXRsZV9jb250YWluZXJ7CiAgICAgICAgbWFyZ2luOiAtMmVtIDAgMy41ZW07CiAgICAgICAgcGFkZGluZy1ib3R0b206IDJlbTsKICAgICAgICBib3JkZXItYm90dG9tOiAzcHggZG91YmxlICMxMDE2MUE7CiAgICB9CiAgICAudGl0bGVfY29udGFpbmVyIGgxewogICAgICAgIG1hcmdpbi10b3A6IDEuMmVtOwogICAgICAgIG1hcmdpbi1ib3R0b206IDAuNmVtOwogICAgICAgIGxpbmUtaGVpZ2h0OiAxLjM1OwogICAgICAgIGZvbnQtc2l6ZTogMi4yNWVtOwogICAgfQogICAgLnRpdGxlX2NvbnRhaW5lciBoMnsKICAgICAgICBjb2xvcjogIzlBOUE5QTsKICAgICAgICBmb250LXNpemU6IDFlbTsKICAgICAgICBmb250LXdlaWdodDogbm9ybWFsOwogICAgICAgIHBhZGRpbmctYm90dG9tOiAyZW07CiAgICAgICAgbGluZS1oZWlnaHQ6IDEuMzU7CiAgICAgICAgbWFyZ2luLWJvdHRvbTogLTJlbTsKICAgIH0KCiAgICBAbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDc2MHB4KXsKICAgICAgICBodG1sewogICAgICAgICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDsKICAgICAgICB9CiAgICAgICAgYm9keXsKICAgICAgICAgICAgbWFyZ2luOiAwOwogICAgICAgIH0KICAgICAgICAucG9zdHsKICAgICAgICAgICAgcGFkZGluZzogMDsKICAgICAgICB9CiAgICB9CiAgICAvKiBwYWdlX2NzcyAqLwoKICAgIA==">
    <!--header_scripts-->
</head>
<body>
    <div class="post">
        <div class="post_body">
            
            <h1 id="toc_0" class="h16 md_first_h"><span class="span_for_h">函数</span></h1>

<p class="md_block">
    <span class="md_line md_line_start md_line_end"><em>函数</em>是一段完成特定任务的独立代码片段。你可以通过给函数命名来标识某个函数的功能，这个名字可以被用来在需要的时候“调用”这个函数来完成它的任务。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">Swift 统一的函数语法非常的灵活，可以用来表示任何函数，包括从最简单的没有参数名字的 C 风格函数，到复杂的带局部和外部参数名的 Objective-C 风格函数。参数可以提供默认值，以简化函数调用。参数也可以既当做传入参数，也当做传出参数，也就是说，一旦函数执行结束，传入的参数值将被修改。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">在 Swift 中，每个函数都有一个由函数的参数值类型和返回值类型组成的类型。你可以把函数类型当做任何其他普通变量类型一样处理，这样就可以更简单地把函数当做别的函数的参数，也可以从其他函数中返回函数。函数的定义可以写在其他函数定义中，这样可以在嵌套函数范围内实现功能封装。</span>
</p>

<h2 id="toc_1" class="h16"><span class="span_for_h">函数的定义与调用 {#Defining-and-Calling-Functions}</span></h2>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">当你定义一个函数时，你可以定义一个或多个有名字和类型的值，作为函数的输入，称为<em class="md_patched_em">参数</em>，也可以定义某种类型的值作为函数执行结束时的输出，称为<em class="md_patched_em">返回类型</em>。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">每个函数有个<em class="md_patched_em">函数名</em>，用来描述函数执行的任务。要使用一个函数时，用函数名来“调用”这个函数，并传给它匹配的输入值（称作<em class="md_patched_em">实参</em>）。函数的实参必须与函数参数表里参数的顺序一致。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">下面例子中的函数的名字是 <code>greet(person:)</code>，之所以叫这个名字，是因为这个函数用一个人的名字当做输入，并返回向这个人问候的语句。为了完成这个任务，你需要定义一个输入参数——一个叫做 <code>person</code> 的 <code>String</code> 值，和一个包含给这个人问候语的 <code>String</code> 类型的返回值：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">greet</span><span class="p">(</span><span class="n">person</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">greeting</span> <span class="p">=</span> <span class="s">&quot;Hello, &quot;</span> <span class="o">+</span> <span class="n">person</span> <span class="o">+</span> <span class="s">&quot;!&quot;</span>
    <span class="k">return</span> <span class="n">greeting</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">所有的这些信息汇总起来成为函数的<em class="md_patched_em">定义</em>，并以 <code>func</code> 作为前缀。指定函数返回类型时，用返回箭头 <code>-&gt;</code>（一个连字符后跟一个右尖括号）后跟返回类型的名称的方式来表示。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">该定义描述了函数的功能，它期望接收什么作为参数和执行结束时它返回的结果是什么类型。这样的定义使得函数可以在别的地方以一种清晰的方式被调用：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="bp">print</span><span class="p">(</span><span class="n">greet</span><span class="p">(</span><span class="n">person</span><span class="p">:</span> <span class="s">&quot;Anna&quot;</span><span class="p">))</span>
<span class="c1">// 打印“Hello, Anna!”</span>
<span class="bp">print</span><span class="p">(</span><span class="n">greet</span><span class="p">(</span><span class="n">person</span><span class="p">:</span> <span class="s">&quot;Brian&quot;</span><span class="p">))</span>
<span class="c1">// 打印“Hello, Brian!”</span>
</pre></div>

<!--block_code_end-->
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">调用 <code>greet(person:)</code> 函数时，在圆括号中传给它一个 <code>String</code> 类型的实参，例如 <code>greet(person: "Anna")</code>。正如上面所示，因为这个函数返回一个 <code>String</code> 类型的值，所以 <code>greet</code> 可以被包含在 <code>print(_:separator:terminator:)</code> 的调用中，用来输出这个函数的返回值。</span>
</p>


<blockquote class="blockquote_lines_3 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">注意<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line md_line_end"><code>print(_:separator:terminator:)</code> 函数的第一个参数并没有设置一个标签，而其他的参数因为已经有了默认值，因此是可选的。关于这些函数语法上的变化详见下方关于 函数参数标签和参数名以及默认参数值。</span>
</p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">在 <code>greet(person:)</code> 的函数体中，先定义了一个新的名为 <code>greeting</code> 的 <code>String</code> 常量，同时，把对 <code>personName</code> 的问候消息赋值给了 <code>greeting</code> 。然后用 <code>return</code> 关键字把这个问候返回出去。一旦 <code>return greeting</code> 被调用，该函数结束它的执行并返回 <code>greeting</code> 的当前值。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">你可以用不同的输入值多次调用 <code>greet(person:)</code>。上面的例子展示的是用 <code>"Anna"</code> 和 <code>"Brian"</code> 调用的结果，该函数分别返回了不同的结果。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">为了简化这个函数的定义，可以将问候消息的创建和返回写成一句：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">greetAgain</span><span class="p">(</span><span class="n">person</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;Hello again, &quot;</span> <span class="o">+</span> <span class="n">person</span> <span class="o">+</span> <span class="s">&quot;!&quot;</span>
<span class="p">}</span>
<span class="bp">print</span><span class="p">(</span><span class="n">greetAgain</span><span class="p">(</span><span class="n">person</span><span class="p">:</span> <span class="s">&quot;Anna&quot;</span><span class="p">))</span>
<span class="c1">// 打印“Hello again, Anna!”</span>
</pre></div>

<!--block_code_end--><h2 id="toc_2" class="h16"><span class="span_for_h">函数参数与返回值 {#Function-Parameters-and-Return-Values}</span></h2>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">函数参数与返回值在 Swift 中非常的灵活。你可以定义任何类型的函数，包括从只带一个未名参数的简单函数到复杂的带有表达性参数名和不同参数选项的复杂函数。</span>
</p>

<h3 id="toc_3" class="h16"><span class="span_for_h">无参数函数 {#functions-without-parameters}</span></h3>

<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">函数可以没有参数。下面这个函数就是一个无参数函数，当被调用时，它返回固定的 <code>String</code> 消息：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">sayHelloWorld</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;hello, world&quot;</span>
<span class="p">}</span>
<span class="bp">print</span><span class="p">(</span><span class="n">sayHelloWorld</span><span class="p">())</span>
<span class="c1">// 打印“hello, world”</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">尽管这个函数没有参数，但是定义中在函数名后还是需要一对圆括号。当被调用时，也需要在函数名后写一对圆括号。</span>
</p>

<h3 id="toc_4" class="h16"><span class="span_for_h">多参数函数 {#functions-with-multiple-parameters}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">函数可以有多种输入参数，这些参数被包含在函数的括号之中，以逗号分隔。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">下面这个函数用一个人名和是否已经打过招呼作为输入，并返回对这个人的适当问候语:</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">greet</span><span class="p">(</span><span class="n">person</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">alreadyGreeted</span><span class="p">:</span> <span class="nb">Bool</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">alreadyGreeted</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">greetAgain</span><span class="p">(</span><span class="n">person</span><span class="p">:</span> <span class="n">person</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">greet</span><span class="p">(</span><span class="n">person</span><span class="p">:</span> <span class="n">person</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="bp">print</span><span class="p">(</span><span class="n">greet</span><span class="p">(</span><span class="n">person</span><span class="p">:</span> <span class="s">&quot;Tim&quot;</span><span class="p">,</span> <span class="n">alreadyGreeted</span><span class="p">:</span> <span class="kc">true</span><span class="p">))</span>
<span class="c1">// 打印“Hello again, Tim!”</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">你可以通过在括号内使用逗号分隔来传递一个 <code>String</code> 参数值和一个标识为 <code>alreadyGreeted</code> 的 <code>Bool</code> 值，来调用 <code>greet(person:alreadyGreeted:)</code> 函数。注意这个函数和上面 <code>greet(person:)</code> 是不同的。虽然它们都有着同样的名字 <code>greet</code>，但是 <code>greet(person:alreadyGreeted:)</code> 函数需要两个参数，而 <code>greet(person:)</code> 只需要一个参数。</span>
</p>

<h3 id="toc_5" class="h16"><span class="span_for_h">无返回值函数 {#functions-without-return-values}</span></h3>

<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">函数可以没有返回值。下面是 <code>greet(person:)</code> 函数的另一个版本，这个函数直接打印一个 <code>String</code> 值，而不是返回它：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">greet</span><span class="p">(</span><span class="n">person</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Hello, </span><span class="si">\(</span><span class="n">person</span><span class="si">)</span><span class="s">!&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">greet</span><span class="p">(</span><span class="n">person</span><span class="p">:</span> <span class="s">&quot;Dave&quot;</span><span class="p">)</span>
<span class="c1">// 打印“Hello, Dave!”</span>
</pre></div>

<!--block_code_end-->
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">因为这个函数不需要返回值，所以这个函数的定义中没有返回箭头（-&gt;）和返回类型。</span>
</p>


<blockquote class="blockquote_lines_3 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">注意<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line md_line_end">严格地说，即使没有明确定义返回值，该 <code>greet(Person：)</code> 函数仍然返回一个值。没有明确定义返回类型的函数的返回一个 <code>Void</code> 类型特殊值，该值为一个空元组，写成 ()。</span>
</p>

</blockquote>

<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">调用函数时，可以忽略该函数的返回值：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">printAndCount</span><span class="p">(</span><span class="n">string</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">string</span><span class="p">.</span><span class="bp">count</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">printWithoutCounting</span><span class="p">(</span><span class="n">string</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">_</span> <span class="p">=</span> <span class="n">printAndCount</span><span class="p">(</span><span class="n">string</span><span class="p">:</span> <span class="n">string</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">printAndCount</span><span class="p">(</span><span class="n">string</span><span class="p">:</span> <span class="s">&quot;hello, world&quot;</span><span class="p">)</span>
<span class="c1">// 打印“hello, world”，并且返回值 12</span>
<span class="n">printWithoutCounting</span><span class="p">(</span><span class="n">string</span><span class="p">:</span> <span class="s">&quot;hello, world&quot;</span><span class="p">)</span>
<span class="c1">// 打印“hello, world”，但是没有返回任何值</span>
</pre></div>

<!--block_code_end-->
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">第一个函数 <code>printAndCount(string:)</code>，输出一个字符串并返回 <code>Int</code> 类型的字符数。第二个函数 <code>printWithoutCounting(string:)</code> 调用了第一个函数，但是忽略了它的返回值。当第二个函数被调用时，消息依然会由第一个函数输出，但是返回值不会被用到。</span>
</p>


<blockquote class="blockquote_lines_3 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">注意<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line md_line_end">返回值可以被忽略，但定义了有返回值的函数必须返回一个值，如果在函数定义底部没有返回任何值，将导致编译时错误。</span>
</p>

</blockquote>
<h3 id="toc_6" class="h16"><span class="span_for_h">多重返回值函数 {#functions-with-multiple-return-values}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">你可以用元组（tuple）类型让多个值作为一个复合值从函数中返回。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">下例中定义了一个名为 <code>minMax(array:)</code> 的函数，作用是在一个 <code>Int</code> 类型的数组中找出最小值与最大值。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">minMax</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">])</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="bp">min</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="bp">max</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">currentMin</span> <span class="p">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="kd">var</span> <span class="nv">currentMax</span> <span class="p">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">value</span> <span class="k">in</span> <span class="n">array</span><span class="p">[</span><span class="mf">1.</span><span class="p">.&lt;</span><span class="n">array</span><span class="p">.</span><span class="bp">count</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">currentMin</span> <span class="p">{</span>
            <span class="n">currentMin</span> <span class="p">=</span> <span class="n">value</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">currentMax</span> <span class="p">{</span>
            <span class="n">currentMax</span> <span class="p">=</span> <span class="n">value</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">currentMin</span><span class="p">,</span> <span class="n">currentMax</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end"> <code>minMax(array:)</code> 函数返回一个包含两个 <code>Int</code> 值的元组，这些值被标记为 <code>min</code> 和 <code>max</code> ，以便查询函数的返回值时可以通过名字访问它们。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">在 <code>minMax(array:)</code> 的函数体中，在开始的时候设置两个工作变量 <code>currentMin</code> 和 <code>currentMax</code> 的值为数组中的第一个数。然后函数会遍历数组中剩余的值并检查该值是否比 <code>currentMin</code> 和 <code>currentMax</code> 更小或更大。最后数组中的最小值与最大值作为一个包含两个 <code>Int</code> 值的元组返回。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">因为元组的成员值已被命名，因此可以通过 <code>.</code> 语法来检索找到的最小值与最大值：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">let</span> <span class="nv">bounds</span> <span class="p">=</span> <span class="n">minMax</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">109</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">71</span><span class="p">])</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;min is </span><span class="si">\(</span><span class="n">bounds</span><span class="p">.</span><span class="bp">min</span><span class="si">)</span><span class="s"> and max is </span><span class="si">\(</span><span class="n">bounds</span><span class="p">.</span><span class="bp">max</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">// 打印“min is -6 and max is 109”</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">需要注意的是，元组的成员不需要在元组从函数中返回时命名，因为它们的名字已经在函数返回类型中指定了。</span>
</p>

<h3 id="toc_7" class="h16"><span class="span_for_h">可选元组返回类型 {#optional-tuple-return-types}</span></h3>

<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">如果函数返回的元组类型有可能整个元组都“没有值”，你可以使用<em class="md_patched_em">可选的</em> 元组返回类型反映整个元组可以是 <code>nil</code> 的事实。你可以通过在元组类型的右括号后放置一个问号来定义一个可选元组，例如 <code>(Int, Int)?</code> 或 <code>(String, Int, Bool)?</code></span>
</p>


<blockquote class="blockquote_lines_3 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">注意<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line md_line_end">可选元组类型如 <code>(Int, Int)?</code> 与元组包含可选类型如 <code>(Int?, Int?)</code> 是不同的。可选的元组类型，整个元组是可选的，而不只是元组中的每个元素值。</span>
</p>

</blockquote>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">前面的 <code>minMax(array:)</code> 函数返回了一个包含两个 <code>Int</code> 值的元组。但是函数不会对传入的数组执行任何安全检查，如果 <code>array</code> 参数是一个空数组，如上定义的 <code>minMax(array:)</code> 在试图访问 <code>array[0]</code> 时会触发一个运行时错误。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">为了安全地处理这个“空数组”问题，将 <code>minMax(array:)</code> 函数改写为使用可选元组返回类型，并且当数组为空时返回 <code>nil</code>：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">minMax</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">])</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="bp">min</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="bp">max</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)?</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">array</span><span class="p">.</span><span class="bp">isEmpty</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
    <span class="kd">var</span> <span class="nv">currentMin</span> <span class="p">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="kd">var</span> <span class="nv">currentMax</span> <span class="p">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">value</span> <span class="k">in</span> <span class="n">array</span><span class="p">[</span><span class="mf">1.</span><span class="p">.&lt;</span><span class="n">array</span><span class="p">.</span><span class="bp">count</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">currentMin</span> <span class="p">{</span>
            <span class="n">currentMin</span> <span class="p">=</span> <span class="n">value</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">currentMax</span> <span class="p">{</span>
            <span class="n">currentMax</span> <span class="p">=</span> <span class="n">value</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">currentMin</span><span class="p">,</span> <span class="n">currentMax</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">你可以使用可选绑定来检查 <code>minMax(array:)</code> 函数返回的是一个存在的元组值还是 <code>nil</code>：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="k">if</span> <span class="kd">let</span> <span class="nv">bounds</span> <span class="p">=</span> <span class="n">minMax</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">109</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">71</span><span class="p">])</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;min is </span><span class="si">\(</span><span class="n">bounds</span><span class="p">.</span><span class="bp">min</span><span class="si">)</span><span class="s"> and max is </span><span class="si">\(</span><span class="n">bounds</span><span class="p">.</span><span class="bp">max</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 打印“min is -6 and max is 109”</span>
</pre></div>

<!--block_code_end--><h3 id="toc_8" class="h16"><span class="span_for_h">隐式返回的函数 {#functions-with-an-implicit-return}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">如果一个函数的整个函数体是一个单行表达式，这个函数可以隐式地返回这个表达式。举个例子，以下的函数有着同样的作用：</span>
</p>


<pre><code>func greeting(for person: String) -&gt; String {
    "Hello, " + person + "!"
}
print(greeting(for: "Dave"))
// 打印 "Hello, Dave!"

func anotherGreeting(for person: String) -&gt; String {
    return "Hello, " + person + "!"
}
print(anotherGreeting(for: "Dave"))
// 打印 "Hello, Dave!"</code></pre>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end"><code>greeting(for:)</code> 函数的完整定义是打招呼内容的返回，这就意味着它能使用隐式返回这样更简短的形式。<code>anothergreeting(for:)</code> 函数返回同样的内容，却因为 <code>return</code> 关键字显得函数更长。任何一个可以被写成一行 <code>return</code> 语句的函数都可以忽略 <code>return</code>。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">正如你将会在 <a class="md_compiled" href="./10_Properties.md">简略的 Getter 声明</a> 里看到的， 一个属性的 getter 也可以使用隐式返回的形式。</span>
</p>

<span class="md_repeated_n md_repeated_n_1"></span><h2 id="toc_9" class="h16"><span class="span_for_h">函数参数标签和参数名称 {#Function-Argument-Labels-and-Parameter-Names}</span></h2>

<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">每个函数参数都有一个<em class="md_patched_em">参数标签（argument label）</em>以及一个<em class="md_patched_em">参数名称（parameter name）</em>。参数标签在调用函数的时候使用；调用的时候需要将函数的参数标签写在对应的参数前面。参数名称在函数的实现中使用。默认情况下，函数参数使用参数名称来作为它们的参数标签。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">someFunction</span><span class="p">(</span><span class="n">firstParameterName</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">secondParameterName</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 在函数体内，firstParameterName 和 secondParameterName 代表参数中的第一个和第二个参数值</span>
<span class="p">}</span>
<span class="n">someFunction</span><span class="p">(</span><span class="n">firstParameterName</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">secondParameterName</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">所有的参数都必须有一个独一无二的名字。虽然多个参数拥有同样的参数标签是可能的，但是一个唯一的函数标签能够使你的代码更具可读性。</span>
</p>

<h3 id="toc_10" class="h16"><span class="span_for_h">指定参数标签 {#specifying-argument-labels}</span></h3>

<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">你可以在参数名称前指定它的参数标签，中间以空格分隔：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">someFunction</span><span class="p">(</span><span class="n">argumentLabel</span> <span class="n">parameterName</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 在函数体内，parameterName 代表参数值</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">这个版本的 <code>greet(person:)</code> 函数，接收一个人的名字和他的家乡，并且返回一句问候：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">greet</span><span class="p">(</span><span class="n">person</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">from</span> <span class="n">hometown</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;Hello </span><span class="si">\(</span><span class="n">person</span><span class="si">)</span><span class="s">!  Glad you could visit from </span><span class="si">\(</span><span class="n">hometown</span><span class="si">)</span><span class="s">.&quot;</span>
<span class="p">}</span>
<span class="bp">print</span><span class="p">(</span><span class="n">greet</span><span class="p">(</span><span class="n">person</span><span class="p">:</span> <span class="s">&quot;Bill&quot;</span><span class="p">,</span> <span class="n">from</span><span class="p">:</span> <span class="s">&quot;Cupertino&quot;</span><span class="p">))</span>
<span class="c1">// 打印“Hello Bill!  Glad you could visit from Cupertino.”</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">参数标签的使用能够让一个函数在调用时更有表达力，更类似自然语言，并且仍保持了函数内部的可读性以及清晰的意图。</span>
</p>

<h3 id="toc_11" class="h16"><span class="span_for_h">忽略参数标签 {#omitting-argument-labels}</span></h3>

<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">如果你不希望为某个参数添加一个标签，可以使用一个下划线（<code>_</code>）来代替一个明确的参数标签。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">someFunction</span><span class="p">(</span><span class="kc">_</span> <span class="n">firstParameterName</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">secondParameterName</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
     <span class="c1">// 在函数体内，firstParameterName 和 secondParameterName 代表参数中的第一个和第二个参数值</span>
<span class="p">}</span>
<span class="n">someFunction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">secondParameterName</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">如果一个参数有一个标签，那么在调用的时候必须使用标签来标记这个参数。</span>
</p>

<h3 id="toc_12" class="h16"><span class="span_for_h">默认参数值 {#default-parameter-values}</span></h3>

<p class="md_block  md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">你可以在函数体中通过给参数赋值来为任意一个参数定义<em class="md_patched_em">默认值（Deafult Value）</em>。当默认值被定义后，调用这个函数时可以忽略这个参数。</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">someFunction</span><span class="p">(</span><span class="n">parameterWithoutDefault</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">parameterWithDefault</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">12</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 如果你在调用时候不传第二个参数，parameterWithDefault 会值为 12 传入到函数体中。</span>
<span class="p">}</span>
<span class="n">someFunction</span><span class="p">(</span><span class="n">parameterWithoutDefault</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">parameterWithDefault</span><span class="p">:</span> <span class="mi">6</span><span class="p">)</span> <span class="c1">// parameterWithDefault = 6</span>
<span class="n">someFunction</span><span class="p">(</span><span class="n">parameterWithoutDefault</span><span class="p">:</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">// parameterWithDefault = 12</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">将不带有默认值的参数放在函数参数列表的最前。一般来说，没有默认值的参数更加的重要，将不带默认值的参数放在最前保证在函数调用时，非默认参数的顺序是一致的，同时也使得相同的函数在不同情况下调用时显得更为清晰。</span>
</p>

<h3 id="toc_13" class="h16"><span class="span_for_h">可变参数 {#variadic-parameters}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">一个<em class="md_patched_em">可变参数（variadic parameter）</em>可以接受零个或多个值。函数调用时，你可以用可变参数来指定函数参数可以被传入不确定数量的输入值。通过在变量类型名后面加入（<code>...</code>）的方式来定义可变参数。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">可变参数的传入值在函数体中变为此类型的一个数组。例如，一个叫做 <code>numbers</code> 的 <code>Double...</code> 型可变参数，在函数体内可以当做一个叫 <code>numbers</code> 的 <code>[Double]</code> 型的数组常量。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">下面的这个函数用来计算一组任意长度数字的 <em>算术平均数（arithmetic mean)</em>：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">arithmeticMean</span><span class="p">(</span><span class="kc">_</span> <span class="n">numbers</span><span class="p">:</span> <span class="nb">Double</span><span class="p">...)</span> <span class="p">-&gt;</span> <span class="nb">Double</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">total</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">number</span> <span class="k">in</span> <span class="n">numbers</span> <span class="p">{</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">number</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">total</span> <span class="o">/</span> <span class="nb">Double</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="bp">count</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">arithmeticMean</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// 返回 3.0, 是这 5 个数的平均数。</span>
<span class="n">arithmeticMean</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">8.25</span><span class="p">,</span> <span class="mf">18.75</span><span class="p">)</span>
<span class="c1">// 返回 10.0, 是这 3 个数的平均数。</span>
</pre></div>

<!--block_code_end-->
<blockquote class="blockquote_lines_3 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">注意<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line md_line_end">一个函数最多只能拥有一个可变参数。</span>
</p>

</blockquote>
<h3 id="toc_14" class="h16"><span class="span_for_h">输入输出参数 {#in-out-parameters}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">函数参数默认是常量。试图在函数体中更改参数值将会导致编译错误。这意味着你不能错误地更改参数值。如果你想要一个函数可以修改参数的值，并且想要在这些修改在函数调用结束后仍然存在，那么就应该把这个参数定义为<em class="md_patched_em">输入输出参数（In-Out Parameters）</em>。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">定义一个输入输出参数时，在参数定义前加 <code>inout</code> 关键字。一个 <code>输入输出参数</code>有传入函数的值，这个值被函数修改，然后被传出函数，替换原来的值。想获取更多的关于输入输出参数的细节和相关的编译器优化，请查看 <a class="md_compiled" href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple-ref/doc/uid/TP40014097-CH34-ID545">输入输出参数</a> 一节。</span>
</p>


<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">你只能传递变量给输入输出参数。你不能传入常量或者字面量，因为这些量是不能被修改的。当传入的参数作为输入输出参数时，需要在参数名前加 <code>&amp;</code> 符，表示这个值可以被函数修改。</span>
</p>


<blockquote class="blockquote_lines_3 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">注意<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line md_line_end">输入输出参数不能有默认值，而且可变参数不能用 <code>inout</code> 标记。</span>
</p>

</blockquote>

<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">下例中，<code>swapTwoInts(_:_:)</code> 函数有两个分别叫做 <code>a</code> 和 <code>b</code> 的输入输出参数：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">swapTwoInts</span><span class="p">(</span><span class="kc">_</span> <span class="n">a</span><span class="p">:</span> <span class="kr">inout</span> <span class="nb">Int</span><span class="p">,</span> <span class="kc">_</span> <span class="n">b</span><span class="p">:</span> <span class="kr">inout</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">temporaryA</span> <span class="p">=</span> <span class="n">a</span>
    <span class="n">a</span> <span class="p">=</span> <span class="n">b</span>
    <span class="n">b</span> <span class="p">=</span> <span class="n">temporaryA</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end"><code>swapTwoInts(_:_:)</code> 函数简单地交换 <code>a</code> 与 <code>b</code> 的值。该函数先将 <code>a</code> 的值存到一个临时常量 <code>temporaryA</code> 中，然后将 <code>b</code> 的值赋给 <code>a</code>，最后将 <code>temporaryA</code> 赋值给 <code>b</code>。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">你可以用两个 <code>Int</code> 型的变量来调用 <code>swapTwoInts(_:_:)</code>。需要注意的是，<code>someInt</code> 和 <code>anotherInt</code> 在传入 <code>swapTwoInts(_:_:)</code> 函数前，都加了 <code>&amp;</code> 的前缀：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">var</span> <span class="nv">someInt</span> <span class="p">=</span> <span class="mi">3</span>
<span class="kd">var</span> <span class="nv">anotherInt</span> <span class="p">=</span> <span class="mi">107</span>
<span class="n">swapTwoInts</span><span class="p">(&amp;</span><span class="n">someInt</span><span class="p">,</span> <span class="p">&amp;</span><span class="n">anotherInt</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;someInt is now </span><span class="si">\(</span><span class="n">someInt</span><span class="si">)</span><span class="s">, and anotherInt is now </span><span class="si">\(</span><span class="n">anotherInt</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">// 打印“someInt is now 107, and anotherInt is now 3”</span>
</pre></div>

<!--block_code_end-->
<p class="md_block  md_has_block_below md_has_block_below_blockquote">
    <span class="md_line md_line_start md_line_end">从上面这个例子中，我们可以看到 <code>someInt</code> 和 <code>anotherInt</code> 的原始值在 <code>swapTwoInts(_:_:)</code> 函数中被修改，尽管它们的定义在函数体外。</span>
</p>


<blockquote class="blockquote_lines_3 blockquote_without_image">
<p class="md_block">
    <span class="md_line md_line_start">注意<br /></span>
    <span class="md_line">&nbsp;<br /></span>
    <span class="md_line md_line_end">输入输出参数和返回值是不一样的。上面的 <code>swapTwoInts</code> 函数并没有定义任何返回值，但仍然修改了 <code>someInt</code> 和 <code>anotherInt</code> 的值。输入输出参数是函数对函数体外产生影响的另一种方式。</span>
</p>

</blockquote>
<h2 id="toc_15" class="h16"><span class="span_for_h">函数类型 {#Function-Types}</span></h2>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">每个函数都有种特定的<em class="md_patched_em">函数类型</em>，函数的类型由函数的参数类型和返回类型组成。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">例如：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">addTwoInts</span><span class="p">(</span><span class="kc">_</span> <span class="n">a</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="kc">_</span> <span class="n">b</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">multiplyTwoInts</span><span class="p">(</span><span class="kc">_</span> <span class="n">a</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="kc">_</span> <span class="n">b</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">这个例子中定义了两个简单的数学函数：<code>addTwoInts</code> 和 <code>multiplyTwoInts</code>。这两个函数都接受两个 <code>Int</code> 值， 返回一个 <code>Int</code> 值。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">这两个函数的类型是 <code>(Int, Int) -&gt; Int</code>，可以解读为:</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">“这个函数类型有两个 <code>Int</code> 型的参数并返回一个 <code>Int</code> 型的值”。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">下面是另一个例子，一个没有参数，也没有返回值的函数：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">printHelloWorld</span><span class="p">()</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;hello, world&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">这个函数的类型是：<code>() -&gt; Void</code>，或者叫“没有参数，并返回 <code>Void</code> 类型的函数”。</span>
</p>

<h3 id="toc_16" class="h16"><span class="span_for_h">使用函数类型 {#using-function-types}</span></h3>

<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">在 Swift 中，使用函数类型就像使用其他类型一样。例如，你可以定义一个类型为函数的常量或变量，并将适当的函数赋值给它：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">var</span> <span class="nv">mathFunction</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">=</span> <span class="n">addTwoInts</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">这段代码可以被解读为：</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">”定义一个叫做 <code>mathFunction</code> 的变量，类型是‘一个有两个 <code>Int</code> 型的参数并返回一个 <code>Int</code> 型的值的函数’，并让这个新变量指向 <code>addTwoInts</code> 函数”。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end"><code>addTwoInts</code> 和 <code>mathFunction</code> 有同样的类型，所以这个赋值过程在 Swift 类型检查（type-check）中是允许的。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">现在，你可以用 <code>mathFunction</code> 来调用被赋值的函数了：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="bp">print</span><span class="p">(</span><span class="s">&quot;Result: </span><span class="si">\(</span><span class="n">mathFunction</span><span class="si">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="si">))</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">// Prints &quot;Result: 5&quot;</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">有相同匹配类型的不同函数可以被赋值给同一个变量，就像非函数类型的变量一样：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="n">mathFunction</span> <span class="p">=</span> <span class="n">multiplyTwoInts</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;Result: </span><span class="si">\(</span><span class="n">mathFunction</span><span class="si">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="si">))</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">// Prints &quot;Result: 6&quot;</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">就像其他类型一样，当赋值一个函数给常量或变量时，你可以让 Swift 来推断其函数类型：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">let</span> <span class="nv">anotherMathFunction</span> <span class="p">=</span> <span class="n">addTwoInts</span>
<span class="c1">// anotherMathFunction 被推断为 (Int, Int) -&gt; Int 类型</span>
</pre></div>

<!--block_code_end--><h3 id="toc_17" class="h16"><span class="span_for_h">函数类型作为参数类型 {#function-types-as-parameter-types}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">你可以用 <code>(Int, Int) -&gt; Int</code> 这样的函数类型作为另一个函数的参数类型。这样你可以将函数的一部分实现留给函数的调用者来提供。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">下面是另一个例子，正如上面的函数一样，同样是输出某种数学运算结果：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">printMathResult</span><span class="p">(</span><span class="kc">_</span> <span class="n">mathFunction</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">,</span> <span class="kc">_</span> <span class="n">a</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="kc">_</span> <span class="n">b</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Result: </span><span class="si">\(</span><span class="n">mathFunction</span><span class="si">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="si">))</span><span class="s">&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">printMathResult</span><span class="p">(</span><span class="n">addTwoInts</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// 打印“Result: 8”</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">这个例子定义了 <code>printMathResult(_:_:_:)</code> 函数，它有三个参数：第一个参数叫 <code>mathFunction</code>，类型是 <code>(Int, Int) -&gt; Int</code>，你可以传入任何这种类型的函数；第二个和第三个参数叫 <code>a</code> 和 <code>b</code>，它们的类型都是 <code>Int</code>，这两个值作为已给出的函数的输入值。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">当 <code>printMathResult(_:_:_:)</code> 被调用时，它被传入 <code>addTwoInts</code> 函数和整数 <code>3</code> 和 <code>5</code>。它用传入 <code>3</code> 和 <code>5</code> 调用 <code>addTwoInts</code>，并输出结果：<code>8</code>。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end"><code>printMathResult(_:_:_:)</code> 函数的作用就是输出另一个适当类型的数学函数的调用结果。它不关心传入函数是如何实现的，只关心传入的函数是不是一个正确的类型。这使得 <code>printMathResult(_:_:_:)</code> 能以一种类型安全（type-safe）的方式将一部分功能转给调用者实现。</span>
</p>

<h3 id="toc_18" class="h16"><span class="span_for_h">函数类型作为返回类型 {#function-types-as-return-types}</span></h3>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">你可以用函数类型作为另一个函数的返回类型。你需要做的是在返回箭头（-&gt;）后写一个完整的函数类型。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">下面的这个例子中定义了两个简单函数，分别是 <code>stepForward(_:)</code> 和 <code>stepBackward(_:)</code>。<code>stepForward(_:)</code> 函数返回一个比输入值大 <code>1</code> 的值。<code>stepBackward(_:)</code> 函数返回一个比输入值小 <code>1</code> 的值。这两个函数的类型都是 <code>(Int) -&gt; Int</code>：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">stepForward</span><span class="p">(</span><span class="kc">_</span> <span class="n">input</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">input</span> <span class="o">+</span> <span class="mi">1</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">stepBackward</span><span class="p">(</span><span class="kc">_</span> <span class="n">input</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">input</span> <span class="o">-</span> <span class="mi">1</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">如下名为 <code>chooseStepFunction(backward:)</code> 的函数，它的返回类型是 <code>(Int) -&gt; Int</code> 类型的函数。<code>chooseStepFunction(backward:)</code> 根据布尔值 <code>backwards</code> 来返回 <code>stepForward(_:)</code> 函数或 <code>stepBackward(_:)</code> 函数：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">chooseStepFunction</span><span class="p">(</span><span class="n">backward</span><span class="p">:</span> <span class="nb">Bool</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">backward</span> <span class="p">?</span> <span class="n">stepBackward</span> <span class="p">:</span> <span class="n">stepForward</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">你现在可以用 <code>chooseStepFunction(backward:)</code> 来获得两个函数其中的一个：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">var</span> <span class="nv">currentValue</span> <span class="p">=</span> <span class="mi">3</span>
<span class="kd">let</span> <span class="nv">moveNearerToZero</span> <span class="p">=</span> <span class="n">chooseStepFunction</span><span class="p">(</span><span class="n">backward</span><span class="p">:</span> <span class="n">currentValue</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1">// moveNearerToZero 现在指向 stepBackward() 函数。</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line md_line_start md_line_end">上面这个例子中计算出从 <code>currentValue</code> 逐渐接近到0是需要向正数走还是向负数走。<code>currentValue</code> 的初始值是 <code>3</code>，这意味着 <code>currentValue &gt; 0</code> 为真（true），这将使得 <code>chooseStepFunction(_:)</code> 返回 <code>stepBackward(_:)</code> 函数。一个指向返回的函数的引用保存在了 <code>moveNearerToZero</code> 常量中。</span>
</p>


<p class="md_block md_block_as_opening md_has_block_below md_has_block_below_code_block">
    <span class="md_line md_line_start md_line_end">现在，<code>moveNearerToZero</code> 指向了正确的函数，它可以被用来数到零：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="bp">print</span><span class="p">(</span><span class="s">&quot;Counting to zero:&quot;</span><span class="p">)</span>
<span class="c1">// Counting to zero:</span>
<span class="k">while</span> <span class="n">currentValue</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;</span><span class="si">\(</span><span class="n">currentValue</span><span class="si">)</span><span class="s">... &quot;</span><span class="p">)</span>
    <span class="n">currentValue</span> <span class="p">=</span> <span class="n">moveNearerToZero</span><span class="p">(</span><span class="n">currentValue</span><span class="p">)</span>
<span class="p">}</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;zero!&quot;</span><span class="p">)</span>
<span class="c1">// 3...</span>
<span class="c1">// 2...</span>
<span class="c1">// 1...</span>
<span class="c1">// zero!</span>
</pre></div>

<!--block_code_end--><h2 id="toc_19" class="h16"><span class="span_for_h">嵌套函数 {#Nested-Functions}</span></h2>

<p class="md_block">
    <span class="md_line md_line_start md_line_end">到目前为止本章中你所见到的所有函数都叫<em class="md_patched_em">全局函数（global functions）</em>，它们定义在全局域中。你也可以把函数定义在别的函数体中，称作 <em>嵌套函数（nested functions）</em>。</span>
</p>


<p class="md_block">
    <span class="md_line md_line_start md_line_end">默认情况下，嵌套函数是对外界不可见的，但是可以被它们的外围函数（enclosing function）调用。一个外围函数也可以返回它的某一个嵌套函数，使得这个函数可以在其他域中被使用。</span>
</p>


<p class="md_block last_md_block_in_page">
    <span class="md_line md_line_start md_line_end">你可以用返回嵌套函数的方式重写 <code>chooseStepFunction(backward:)</code> 函数：</span>
</p>

<div class="codehilite code_lang_swift  highlight"><pre><span></span><span class="kd">func</span> <span class="nf">chooseStepFunction</span><span class="p">(</span><span class="n">backward</span><span class="p">:</span> <span class="nb">Bool</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">stepForward</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">input</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">stepBackward</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">input</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">}</span>
    <span class="k">return</span> <span class="n">backward</span> <span class="p">?</span> <span class="n">stepBackward</span> <span class="p">:</span> <span class="n">stepForward</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nv">currentValue</span> <span class="p">=</span> <span class="o">-</span><span class="mi">4</span>
<span class="kd">let</span> <span class="nv">moveNearerToZero</span> <span class="p">=</span> <span class="n">chooseStepFunction</span><span class="p">(</span><span class="n">backward</span><span class="p">:</span> <span class="n">currentValue</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1">// moveNearerToZero now refers to the nested stepForward() function</span>
<span class="k">while</span> <span class="n">currentValue</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;</span><span class="si">\(</span><span class="n">currentValue</span><span class="si">)</span><span class="s">... &quot;</span><span class="p">)</span>
    <span class="n">currentValue</span> <span class="p">=</span> <span class="n">moveNearerToZero</span><span class="p">(</span><span class="n">currentValue</span><span class="p">)</span>
<span class="p">}</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;zero!&quot;</span><span class="p">)</span>
<span class="c1">// -4...</span>
<span class="c1">// -3...</span>
<span class="c1">// -2...</span>
<span class="c1">// -1...</span>
<span class="c1">// zero!</span>
</pre></div>

<!--block_code_end-->
        </div>
    </div>
    <!--mathjax-->
    <!--mermaid-->
</body>
</html>